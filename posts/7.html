<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>尚品汇Vue项目总结 | Serein's blog</title><meta name="keywords" content="Vue"><meta name="author" content="Serein"><meta name="copyright" content="Serein"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前端Vue核心 开发一个前端模块可以概括为以下几个步骤：  写静态页面、拆分为静态组件； 发请求（API）； vuex（actions、mutations、state三连操作）； 组件获取仓库数据，动态展示；   尚品汇前台商品系统vue文件目录分析public文件夹：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。pubilc&#x2F;index.html 是一个模板文件，作用是">
<meta property="og:type" content="article">
<meta property="og:title" content="尚品汇Vue项目总结">
<meta property="og:url" content="https://serein.icu/posts/7.html">
<meta property="og:site_name" content="Serein&#39;s blog">
<meta property="og:description" content="前端Vue核心 开发一个前端模块可以概括为以下几个步骤：  写静态页面、拆分为静态组件； 发请求（API）； vuex（actions、mutations、state三连操作）； 组件获取仓库数据，动态展示；   尚品汇前台商品系统vue文件目录分析public文件夹：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。pubilc&#x2F;index.html 是一个模板文件，作用是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg">
<meta property="article:published_time" content="2022-04-08T03:30:00.000Z">
<meta property="article:modified_time" content="2022-04-09T00:53:01.890Z">
<meta property="article:author" content="Serein">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/weather.png"><link rel="canonical" href="https://serein.icu/posts/7"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"一年之内的产物","messageNext":"技术可能存在过期"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Serein","link":"链接: ","source":"来源: Serein's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '尚品汇Vue项目总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-09 08:53:01'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link defer rel="stylesheet" href="/css/customm.css" ><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/icon.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/background.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/index_ee.css"><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Serein's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/headimg_dl.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/Windows/"><i class="fa-fw fa fa-desktop"></i><span> Windows</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Serein's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/Windows/"><i class="fa-fw fa fa-desktop"></i><span> Windows</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">尚品汇Vue项目总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-08T03:30:00.000Z" title="发表于 2022-04-08 11:30:00">2022-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-09T00:53:01.890Z" title="更新于 2022-04-09 08:53:01">2022-04-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">项目实战</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="尚品汇Vue项目总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前端Vue核心"><a href="#前端Vue核心" class="headerlink" title="前端Vue核心"></a>前端Vue核心</h1><blockquote>
<p><strong>开发一个前端模块可以概括为以下几个步骤：</strong></p>
<ol>
<li>写静态页面、拆分为静态组件；</li>
<li>发请求（API）；</li>
<li>vuex（actions、mutations、state三连操作）；</li>
<li>组件获取仓库数据，动态展示；</li>
</ol>
</blockquote>
<h1 id="尚品汇前台商品系统"><a href="#尚品汇前台商品系统" class="headerlink" title="尚品汇前台商品系统"></a>尚品汇前台商品系统</h1><h2 id="vue文件目录分析"><a href="#vue文件目录分析" class="headerlink" title="vue文件目录分析"></a>vue文件目录分析</h2><p><strong>public文件夹</strong>：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。<br><strong>pubilc/index.html</strong> 是一个模板文件，作用是生成项目的入口文件，webpack打包的js,css也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html。</p>
<blockquote>
<p><strong>src文件夹（程序员代码文件夹）</strong><br>assets： 存放公用的静态资源<br>components： 非路由组件（全局组件），其他组件放在views或者pages文件夹中<br>App.vue： 唯一的根组件<br>main.js： 程序入口文件，最先执行的文件</p>
</blockquote>
<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><h3 id="项目运行，浏览器自动打开"><a href="#项目运行，浏览器自动打开" class="headerlink" title="项目运行，浏览器自动打开"></a>项目运行，浏览器自动打开</h3><pre class="line-numbers language-package.json" data-language="package.json"><code class="language-package.json">"scripts": {
  "serve": "vue-cli-service serve --open",
  "build": "vue-cli-service build",
  "lint": "vue-cli-service lint"
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）"><a href="#关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）" class="headerlink" title="关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）"></a>关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）</h3><p><strong>根目录下创建vue.config.js,进行配置</strong></p>
<pre class="line-numbers language-vue.config.js" data-language="vue.config.js"><code class="language-vue.config.js">module.exports = {
  //关闭eslint
  lintOnSave: false
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="src文件夹配置别名-创建jsconfig-json"><a href="#src文件夹配置别名-创建jsconfig-json" class="headerlink" title="src文件夹配置别名,创建jsconfig.json"></a>src文件夹配置别名,创建jsconfig.json</h3><p><strong>用@/代替src/，exclude表示不可以使用该别名的文件</strong></p>
<pre class="line-numbers language-jsconfig.json" data-language="jsconfig.json"><code class="language-jsconfig.json">{
   "compilerOptions": {
       "baseUrl": "./",
           "paths": {
           "@/*": [
               "src/*"
           ]
       }
   },

   "exclude": [
       "node_modules",
       "dist"
   ]
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="组件页面样式"><a href="#组件页面样式" class="headerlink" title="组件页面样式"></a>组件页面样式</h2><p>组件页面的样式使用的是less样式，浏览器不识别该样式，需要下载相关依赖<br><strong>npm install –save less less-loader@5</strong><br>如果想让组件识别less样式，则在组件中设置</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;style scoped lang="less"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="清除vue页面默认的样式"><a href="#清除vue页面默认的样式" class="headerlink" title="清除vue页面默认的样式"></a>清除vue页面默认的样式</h2><p><strong>vue是单页面开发，我们只需要修改public下的index.html文件</strong></p>
<pre class="line-numbers language-index.html" data-language="index.html"><code class="language-index.html">&lt;link rel="stylesheet" href="reset.css"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="views-pages文件夹"><a href="#views-pages文件夹" class="headerlink" title="views/pages文件夹"></a>views/pages文件夹</h2><ul>
<li>创建views/pages文件夹，并创建路由组件</li>
<li>创建router文件夹，并创建index.js进行路由配置，最终在main.js中引入注册<h3 id="路由组件和非路由组件区别"><a href="#路由组件和非路由组件区别" class="headerlink" title="路由组件和非路由组件区别"></a>路由组件和非路由组件区别</h3><blockquote>
<p>非路由组件放在components中，路由组件放在pages或views中<br>非路由组件通过标签使用，路由组件通过路由使用<br>在main.js注册玩路由，所有的路由和非路由组件身上都会拥有$router和$route属性<br>$router：一般进行编程式导航进行路由跳转<br>$route：一般获取路由信息（name path params等）</p>
</blockquote>
<h3 id="路由跳转方式"><a href="#路由跳转方式" class="headerlink" title="路由跳转方式"></a>路由跳转方式</h3></li>
<li>声明式导航router-link标签 ,可以把router-link理解为一个a标签，它 也可以加class修饰</li>
<li>编程式导航 ：声明式导航能做的编程式都能做，而且还可以处理一些业务</li>
</ul>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p><strong>query、params两个属性可以传递参数</strong></p>
<blockquote>
<p>query参数：不属于路径当中的一部分，类似于get请求，地址栏表现为 /search?k1=v1&amp;k2=v2<br>query参数对应的路由信息 path: “/search”<br>params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位 ,地址栏表现为 /search/v1/v2<br>params参数对应的路由信息要修改为path: “/search/:keyword” 这里的/:keyword就是一个params参数的占位符</p>
</blockquote>
<h3 id="params传参问题"><a href="#params传参问题" class="headerlink" title="params传参问题"></a>params传参问题</h3><p><strong>1. 如何指定params参数可传可不传</strong></p>
<blockquote>
<p>如果路由path要求传递params参数,但是没有传递,会发现地址栏URL有问题，详情如下：<br> Search路由项的path已经指定要传一个keyword的params参数，如下所示：<br>  path: “/search/:keyword”,<br>  执行下面进行路由跳转的代码：<br>  this.$router.push({name:”Search”,query:{keyword:this.keyword}})<br>  当前跳转代码没有传递params参数<br>  地址栏信息：<a target="_blank" rel="noopener" href="http://localhost:8080/#/?keyword=asd">http://localhost:8080/#/?keyword=asd</a><br>  此时的地址信息少了/search<br>  正常的地址栏信息: <a target="_blank" rel="noopener" href="http://localhost:8080/#/search?keyword=asd">http://localhost:8080/#/search?keyword=asd</a><br>  解决方法：可以通过改变path来指定params参数可传可不传<br>path: “/search/:keyword?”,?表示该参数可传可不传</p>
</blockquote>
<p><strong>参考连接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44867717/article/details/109773945">https://blog.csdn.net/weixin_44867717/article/details/109773945</a></strong></p>
<p><strong>2. 已知params可传可不传，但是如果传递的时空串，如何解决</strong></p>
<blockquote>
<p>this.$router.push({name:”Search”,query:{keyword:this.keyword},params:{keyword:’’}})<br> 出现的问题和1中的问题相同,地址信息少了/search<br> 解决方法： 加入||undefined，当我们传递的参数为空串时地址栏url也可以保持正常<br>this.$router.push({name:”Search”,query:{keyword:this.keyword},params:{keyword:’’||undefined}})</p>
</blockquote>
<p><strong>3. 路由组件能不能传递props数据？</strong><br>可以，但是只能传递params参数,具体知识为props属性<br><strong>参考连接：<a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/essentials/passing-props.html">https://router.vuejs.org/zh/guide/essentials/passing-props.html</a></strong></p>
<h3 id="传参方法"><a href="#传参方法" class="headerlink" title="传参方法"></a>传参方法</h3><p><strong>字符串形式</strong><br>this.$router.push(“/search/“+this.params传参+”?k=”+this.query传参)</p>
<p><strong>模板字符串</strong><br>this.router.push(“/search/+router.push(“/search/+router.push(“/search/+{this.params传参}?k=${this.query传参}”)<br><strong>注意：</strong> 上面字符串的传参方法可以看出params参数和’/‘结合，query参数和？结合<br><a target="_blank" rel="noopener" href="http://localhost:8080/#/search/asd?keyword=asd">http://localhost:8080/#/search/asd?keyword=asd</a><br>上面url中asd为params的值，keyword=asd为query传递的值。</p>
<p><strong>对象（常用）</strong><br>this.$router.push({name:“路由名字”,params:{传参},query:{传参})<br>以对象方式传参时，如果我们传参中使用了params，只能使用name，不能使用path，如果只是使用query传参，可以使用path </p>
<h2 id="多次执行相同的push问题"><a href="#多次执行相同的push问题" class="headerlink" title="多次执行相同的push问题"></a>多次执行相同的push问题</h2><p>多次执行相同的push问题，控制台会出现警告<br>例如：使用this.$router.push({name:‘Search’,params:{keyword:”…”||undefined}})时，如果多次执行相同的push，控制台会出现警告。</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">let result = this.$router.push({name:"Search",query:{keyword:this.keyword}})
console.log(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>执行一次上面代码：</strong><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84push%E9%97%AE%E9%A2%981.png"><br><strong>多次执行出现警告：</strong><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84push%E9%97%AE%E9%A2%982.png"></p>
<p><strong>原因：</strong> push是一个promise，promise需要传递成功和失败两个参数，我们的push中没有传递。<br>方法：this.$router.push({name:‘Search’,params:{keyword:”…”||undefined}},()=&gt;{},()=&gt;{})后面两项分别代表执行成功和失败的回调函数。<br><strong>这种写法治标不治本，将来在别的组件中push|replace,编程式导航还是会有类似错误</strong><br>push是VueRouter.prototype的一个方法，在router中的index重写该方法即可(看不懂也没关系，这是前端面试题)</p>
<pre class="line-numbers language-index.js" data-language="index.js"><code class="language-index.js">//1、先把VueRouter原型对象的push，保存一份
let originPush = VueRouter.prototype.push;
//2、重写push|replace
//第一个参数：告诉原来的push，跳转的目标位置和传递了哪些参数
VueRouter.prototype.push = function (location,resolve,reject){
  if(resolve &amp;&amp; reject){
    originPush.call(this,location,resolve,reject)
  }else{
    originPush.call(this,location,() =&gt; {},() =&gt; {})
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="定义全局组件"><a href="#定义全局组件" class="headerlink" title="定义全局组件"></a>定义全局组件</h2><p>我们的三级联动组件是全局组件，全局的配置都需要在main.js中配置</p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">//将三级联动组件注册为全局组件
import TypeNav from '@/pages/Home/TypeNav';
//第一个参数：全局组件名字，第二个参数：全局组件
Vue.component(TypeNav.name,TypeNav);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Home组件中使用该全局组件，全局组件可以在任一页面中直接使用，不需要导入声明</p>
<pre class="line-numbers language-index.vue" data-language="index.vue"><code class="language-index.vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!--  三级联动全局组件已经注册为全局组件，因此不需要引入--&gt;
    &lt;TypeNav/&gt;
  &lt;/div&gt;
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><p><strong>axios中文文档，包含详细信息：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/yunye/axios/234845">https://www.kancloud.cn/yunye/axios/234845</a></strong><br>在根目录下创建api文件夹，创建request.js文件</p>
<pre class="line-numbers language-request.js" data-language="request.js"><code class="language-request.js">import axios from "axios";
//1、对axios二次封装
const requests = axios.create({
    //基础路径，requests发出的请求在端口号后面会跟改baseURl
    baseURL:'/api',
    timeout: 5000,
})
//2、配置请求拦截器
requests.interceptors.request.use(config =&gt; {
    //config内主要是对请求头Header配置
    //比如添加token
    return config;
})
//3、配置相应拦截器
requests.interceptors.response.use((res) =&gt; {
    //成功的回调函数
    return  res.data;
},(error) =&gt; {
    //失败的回调函数
    console.log("响应失败"+error)
    return Promise.reject(new Error('fail'))
})
//4、对外暴露
export default requests;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="前端通过代理解决跨域问题"><a href="#前端通过代理解决跨域问题" class="headerlink" title="前端通过代理解决跨域问题"></a>前端通过代理解决跨域问题</h2><p>在根目录下的vue.config.js中配置,proxy为通过代理解决跨域问题。<br>我们在封装axios的时候已经设置了baseURL为api,所以所有的请求都会携带/api，这里我们就将/api进行了转换。如果你的项目没有封装axios，或者没有配置baseURL，建议进行配置。要保证baseURL和这里的代理映射相同，此处都为’/api’</p>
<pre class="line-numbers language-vue.config.js" data-language="vue.config.js"><code class="language-vue.config.js">module.exports = {
    // 关闭ESLINT校验工具
    lintOnSave: false,
    devServer: {
        //代理服务器解决跨域
        proxy: {
            //会把请求路径中的/api换为后面的代理服务器
            '/api': {
                //提供数据的服务器地址
                target: 'http://39.98.123.211',
            }
        },
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy">webpack官网相关知识解读</a><br>网站中的webpack.config.js就是vue.config.js文件</p>
<h2 id="请求接口统一封装"><a href="#请求接口统一封装" class="headerlink" title="请求接口统一封装"></a>请求接口统一封装</h2><p>在文件夹api中创建index.js文件，用于封装所有请求<br><strong>将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可。</strong><br><strong>如下所示：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">//当前模块，API进行统一管理，即对请求接口统一管理
import requests from "@/api/request";
//首页三级分类接口
export const reqCateGoryList = () =&gt; {
    return  requests({
        url: '/product/getBaseCategoryList',
        method: 'GET'
    })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当组件想要使用相关请求时，只需要导入相关函数即可，以上图的reqCateGoryList 为例:</p>
<pre class="line-numbers language-none"><code class="language-none">import {reqCateGoryList} from './api'
//发起请求
reqCateGoryList();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="nprogress进度条插件"><a href="#nprogress进度条插件" class="headerlink" title="nprogress进度条插件"></a>nprogress进度条插件</h2><p>打开一个页面时，往往会伴随一些请求，并且会在页面上方出现进度条。它的原理时，在我们发起请求的时候开启进度条，在请求成功后关闭进度条，所以只需要在request.js中进行配置。</p>
<p><strong>对应的request.js设置</strong></p>
<pre class="line-numbers language-request.js" data-language="request.js"><code class="language-request.js">import axios from "axios";
//引入进度条
import nprogress from 'nprogress';
//引入进度条样式
import "nprogress/nprogress.css";
//1、对axios二次封装
const requests = axios.create({
    //基础路径，requests发出的请求在端口号后面会跟改baseURl
    baseURL:'/api',
    timeout: 5000,
})
//2、配置请求拦截器
requests.interceptors.request.use(config =&gt; {
    //config内主要是对请求头Header配置
    //比如添加token

    //开启进度条
    nprogress.start()
    return config
})
//3、配置相应拦截器
requests.interceptors.response.use((res) =&gt; {
    //成功的回调函数

    //响应成功，关闭进度条
    nprogress.done()
    return  res.data
},(error) =&gt; {
    //失败的回调函数
    console.log("响应失败"+error)
    return Promise.reject(new Error('fail'))
})
//4、对外暴露
export default requests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以通过修改nprogress.css文件的background来修改进度条颜色</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/nprogress%E8%BF%9B%E5%BA%A6%E6%9D%A1.png"></p>
<h2 id="手动引入vuex"><a href="#手动引入vuex" class="headerlink" title="手动引入vuex"></a>手动引入vuex</h2><p>首先确保安装了vuex,根目录创建store文件夹，文件夹下创建index.js，内容如下：</p>
<pre class="line-numbers language-index.js" data-language="index.js"><code class="language-index.js">import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
//对外暴露store的一个实例
export default new Vuex.Store({
    state:{},
    mutations:{},
    actions:{},
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想要使用vuex，还要再main.js中引入<br>main.js:<br>(1) 引入文件<br>(2) 注册store<br><strong>但凡是在main.js中的Vue实例中注册的实体，在所有的组件中都会有（this.$.实体名）属性</strong></p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">import store from './store'
new Vue({
  render: h =&gt; h(App),
  //注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="async-await使用"><a href="#async-await使用" class="headerlink" title="async await使用"></a>async await使用</h2><p>如果我们没有封装请求api，而是直接调用axios，就不需要使用async await<br>案例：我们将一个axios请求封装为了函数，我们在下面代码中调用了该函数：</p>
<pre class="line-numbers language-none"><code class="language-none">import {reqCateGoryList} from '@/api'
export default {
    actions:{
        categoryList(){
            let result =  reqCateGoryList()
            console.log(result)
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>浏览器结果</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A81.png"></p>
<p>返回了一个promise,证明这是一个promise请求，但是我们想要的是图片中的data数据。<br>没有将函数封装前我们都会通过then()回调函数拿到服务器返回的数据，现在我们将其封装了，依然可以使用then获取数据，代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">actions:{
    categoryList(){
        let result =  reqCateGoryList().then(
            res=&gt;{
              console.log("res")
              console.log(res)
              return res
            }
        )
        console.log("result")
        console.log(result)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A82.png"></p>
<p>由于我们的promis是异步请求，我们发现请求需要花费时间，但是它是异步的，所有后面的console.log(“result”)；console.log(result)会先执行，等我们的请求得到响应后，才执行console.log(“res”)；console.log(res)，这也符合异步的原则，但是我们如果在请求下面啊执行的是将那个请求的结果赋值给某个变量，这样就会导致被赋值的变量先执行，并且赋值为undefine，因为此时promise还没有完成</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A83.png"></p>
<p>所以我们引入了async await,async写在函数名前，await写在api函数前面。await含义是<strong>async标识的函数体内的并且在await标识代码后面的代码</strong>先等待await标识的异步请求执行完，再执行。这也使得只有reqCateGoryList执行完，result 得到返回值后，才会执行后面的输出操作</p>
<pre class="line-numbers language-none"><code class="language-none">async categoryList(){
    let result = await reqCateGoryList()
    console.log("result")
    console.log(result)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A84.png"></p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>state、actions、mutations、getters的辅助函数使用，当多次访问store中的上述属性时，要使用4个属性的辅助函数，可以减少代码量<br><strong>在使用上面的函数时，如果需要传递多个参数，需要把多个参数组合为一个对象传入(vuex是不允许多个参数分开传递的)</strong></p>
<pre class="line-numbers language-none"><code class="language-none">async addOrUpdateShopCart({commit},{skuId,skuNum}){
  let result = await reqAddOrUpdateShopCart(skuId,skuNum)
  console.log(result)
  if(result.data === 200){
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/state.html#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">辅助函数官网链接</a></p>
<p><strong>注意：使用action时，函数的第一个参数，必须是{commit}，即使不涉及到mutations操作，也必须加上该参数，否则会报错</strong></p>
<h2 id="loadsh插件防抖和节流"><a href="#loadsh插件防抖和节流" class="headerlink" title="loadsh插件防抖和节流"></a>loadsh插件防抖和节流</h2><p>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。<br>安装lodash插件，该插件提供了防抖和节流的函数，我们可以引入js文件，直接调用。当然也可以自己写防抖和节流的函数<br><a target="_blank" rel="noopener" href="https://www.lodashjs.com/">lodash官网</a><br><a target="_blank" rel="noopener" href="https://www.lodashjs.com/docs/lodash.debounce">防抖函数</a><br><a target="_blank" rel="noopener" href="https://www.lodashjs.com/docs/lodash.throttle">节流函数</a><br><strong>防抖：用户操作很频繁，但是只执行一次，减少业务负担。</strong><br><strong>节流：用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码</strong><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c8b86b09daf0">防抖和节流简述</a></p>
<p>例如：下面代码就是将changeIndex设置了节流，如果操作很频繁，限制50ms执行一次。这里函数定义采用的键值对形式。throttle的返回值就是一个函数，所以直接键值对赋值就可以，函数的参数在function中传入即可。</p>
<pre class="line-numbers language-none"><code class="language-none">import {throttle} from 'lodash'
methods: {
  //鼠标进入修改响应元素的背景颜色
  //采用键值对形式创建函数，将changeIndex定义为节流函数，该函数触发很频繁时，设置50ms才会执行一次
  changeIndex: throttle(function (index){
    this.currentIndex = index
  },50),
  //鼠标移除触发时间
  leaveIndex(){
    this.currentIndex = -1
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="编程式导航-事件委托实现路由跳转"><a href="#编程式导航-事件委托实现路由跳转" class="headerlink" title="编程式导航+事件委托实现路由跳转"></a>编程式导航+事件委托实现路由跳转</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA1.png"></p>
<p>如上图所示，三级标签列表有很多，每一个标签都是一个页面链接，我们要实现通过点击表现进行路由跳转。<br>路由跳转的两种方法：导航式路由，编程式路由</p>
<blockquote>
<p>对于导航式路由，我们有多少个a标签就会生成多少个router-link标签，这样当我们频繁操作时会出现卡顿现象。<br>对于编程式路由，我们是通过触发点击事件实现路由跳转。同理有多少个a标签就会有多少个触发函数。虽然不会出现卡顿，但是也会影响性能。</p>
</blockquote>
<p>上面两种方法无论采用哪一种，都会影响性能。我们提出一种：编程时导航+事件委派 的方式实现路由跳转。事件委派即把子节点的触发事件都委托给父节点。这样只需要一个回调函数goSearch就可以解决。</p>
<p><strong>事件委派问题：</strong></p>
<ol>
<li>如何确定我们点击的一定是a标签呢？如何保证我们只能通过点击a标签才跳转呢？</li>
<li>如何获取子节点标签的商品名称和商品id <strong>(我们是通过商品名称和商品id进行页面跳转的)</strong></li>
</ol>
<p><strong>解决方法：</strong><br>对于问题1：为三个等级的a标签添加自定义属性date-categoryName绑定商品标签名称来标识a标签（其余的标签是没有该属性的）</p>
<p>对于问题2：为三个等级的a标签再添加自定义属性data-category1Id、data-category2Id、data-category3Id来获取三个等级a标签的商品id，用于路由跳转</p>
<p><strong>我们可以通过在函数中传入event参数，获取当前的点击事件，通过event.target属性获取当前点击节点，再通过dataset属性获取节点的属性信息。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex"&gt;
  &lt;div class="item"  v-for="(c1,index) in categoryList" v-show="index!==16" :key="c1.categoryId" :class="{cur:currentIndex===index}"&gt;
    &lt;h3 @mouseenter="changeIndex(index)"&gt;
      &lt;a :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId" &gt;{{c1.categoryName}}&lt;/a&gt;
    &lt;/h3&gt;
    &lt;div class="item-list clearfix" :style="{display:currentIndex===index?'block':'none'}"&gt;
      &lt;div class="subitem" v-for="(c2,index) in c1.categoryChild" :key="c2.categoryId"&gt;
        &lt;dl class="fore"&gt;
          &lt;dt&gt;
            &lt;a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId"&gt;{{c2.categoryName}}&lt;/a&gt;
          &lt;/dt&gt;
          &lt;dd&gt;
            &lt;em v-for="(c3,index) in c2.categoryChild"  :key="c3.categoryId"&gt;
              &lt;a :data-categoryName="c2.categoryName" :data-category3Id="c3.categoryId"&gt;{{c3.categoryName}}&lt;/a&gt;
            &lt;/em&gt;
          &lt;/dd&gt;
        &lt;/dl&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意：event是系统属性，所以我们只需要在函数定义的时候作为参数传入，在函数使用的时候不需要传入该参数。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">//函数使用
&lt;div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex"&gt;
//函数定义
goSearch(event){
  console.log(event.target)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA2.png"></p>
<p>对应的goSearrch函数</p>
<pre class="line-numbers language-none"><code class="language-none">goSearch(event){
    let element = event.target
    //html中会把大写转为小写
    //获取目前鼠标点击标签的categoryname,category1id,category2id,category3id，
    // 通过四个属性是否存在来判断是否为a标签，以及属于哪一个等级的a标签
    let {categoryname,category1id,category2id,category3id} = element.dataset

    //categoryname存在，表示为a标签
    if(categoryname){
        //category1id一级a标签
        //整理路由跳转的参数
        let location = {name:'Search'}//跳转路由name
        let query = {categoryName:categoryname}//路由参数
        if(category1id){
          query.category1Id = category1id
        }else if(category2id){
        //category2id二级a标签
          query.category2Id = category2id
        }else if(category3id){
        //category3id三级a标签
          query.category3Id = category3id
        }
        //整理完参数
        location.query = query
        //路由跳转
        this.$router.push(location)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Vue路由销毁问题"><a href="#Vue路由销毁问题" class="headerlink" title="Vue路由销毁问题"></a>Vue路由销毁问题</h2><p><strong>Vue在路由切换的时候会销毁旧路由</strong><br>我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据<br>由于<strong>Vue在路由切换的时候会销毁旧路由</strong>，当我们再次使用三级列表全局组件时还会发一次请求。<br>如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/Vue%E8%B7%AF%E7%94%B1%E9%94%80%E6%AF%81%E9%97%AE%E9%A2%98.png"></p>
<p>由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次）<br><strong>注意：</strong>虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性。</p>
<h2 id="mock插件使用"><a href="#mock插件使用" class="headerlink" title="mock插件使用"></a>mock插件使用</h2><p>mock用来拦截前端ajax请求，返回我们自定义的数据用于测试前端接口。<br>将不同的数据类型封装为不同的json文件，创建mockServer.js文件<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/mock%E6%8F%92%E4%BB%B6.png"></p>
<p>banner、floor分别为轮播图和页面底部的假数据。</p>
<pre class="line-numbers language-mockServer.js" data-language="mockServer.js"><code class="language-mockServer.js">import Mock  from 'mockjs'
//webpack默认对外暴露：json、图片
import banner from './banner.json'
import floor from './floor.json'

//mock数据：第一个参数请求地址、第二个参：请求数据
Mock.mock("/mock/banner",{code:200,data:banner})
Mock.mock("/mock/floor",{code:200,data:floor})
//记得要在main.js中引入一下
import ''@/mock/mockServer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="vuex数据存储与使用"><a href="#vuex数据存储与使用" class="headerlink" title="vuex数据存储与使用"></a>vuex数据存储与使用</h2><p>我们会把公共的数据放在store中，然后使用时再去store中取。<br>以我们的首页轮播图数据为例。</p>
<ol>
<li>在轮播图组件ListContainer.vue组件加载完毕后发起轮播图数据请求。<pre class="line-numbers language-none"><code class="language-none">mounted() {
  this.$store.dispatch("getBannerList")
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>请求实际是在store中的actions中完成的<pre class="line-numbers language-none"><code class="language-none">actions:{
    //获取首页轮播图数据
    async getBannerList({commit}){
        let result = await reqGetBannerList()
        if(result.code ===  200){
            commit("BANNERLIST",result.data)
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>获取到数据后存入store仓库，在mutations完成<pre class="line-numbers language-none"><code class="language-none">//唯一修改state的部分
mutations:{
    BANNERLIST(state,bannerList){
        state.bannerList = bannerList
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>轮播图组件ListContainer.vue组件在store中获取轮播图数据。由于在这个数据是通过异步请求获得的，所以我们要通过计算属性computed获取轮播图数据<pre class="line-numbers language-ListContainer.vue" data-language="ListContainer.vue"><code class="language-ListContainer.vue">&lt;script&gt;
  import {mapState} from "vuex";
  export default {
    name: "index",
    //主键挂载完毕，请求轮播图图片
    mounted() {
      this.$store.dispatch("getBannerList")
    },
    computed:{
      ...mapState({
        bannerList: (state =&gt; state.home.bannerList)
      })
    }
  }
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p><strong>总结：</strong> 只要是公共数据都会放在store中，之后的实现步骤就是上面的固定步骤。</p>
<h2 id="swiper插件实现轮播图"><a href="#swiper插件实现轮播图" class="headerlink" title="swiper插件实现轮播图"></a>swiper插件实现轮播图</h2><p><a target="_blank" rel="noopener" href="https://www.swiper.com.cn/usage/index.html">swiper官网</a></p>
<p>官网中给出了代码实例：做一个简要总结</p>
<blockquote>
<ol>
<li>安装swiper</li>
<li>在需要使用轮播图的组件内导入swpier和它的css样式</li>
<li>在组件中创建swiper需要的dom标签（html代码，参考官网代码）</li>
<li>创建swiper实例</li>
</ol>
</blockquote>
<p><strong>注意：</strong> 在创建swiper对象时，我们会传递一个参数用于获取展示轮播图的DOM元素，官网直接通过class <strong>（而且这个class不能修改，是swiper的css文件自带的）</strong> 获取。但是这样有缺点：当页面中有多个轮播图时，因为它们使用了相同的class修饰的DOM，就会出现所有的swiper使用同样的数据，这肯定不是我们希望看到的。</p>
<p>解决方法：在轮播图最外层DOM中添加ref属性<br><code>&lt;div class="swiper-container" id="mySwiper" ref="cur"&gt;</code></p>
<p>通过ref属性值获取DOM</p>
<p><code>let mySwiper = new Swiper(this.$refs.cur,{...})</code></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;!--banner轮播--&gt;
  &lt;div class="swiper-container" id="mySwiper" ref="cur"&gt;
    &lt;div class="swiper-wrapper"&gt;
      &lt;div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id"&gt;
        &lt;img :src="carouse.imgUrl" /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 如果需要分页器 --&gt;
    &lt;div class="swiper-pagination"&gt;&lt;/div&gt;
    &lt;!-- 如果需要导航按钮 --&gt;
    &lt;div class="swiper-button-prev" &gt;&lt;/div&gt;
    &lt;div class="swiper-button-next"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;script&gt;
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来要考虑的是什么时候去加载这个swiper，我们第一时间想到的是在mounted中创建这个实例，但是会出现无法加载轮播图片的问题。</p>
<p><strong>原因：</strong></p>
<blockquote>
<p>我们在mounted中先去异步请求了轮播图数据，然后又创建的swiper实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">mounted() {
//请求数据
    this.$store.dispatch("getBannerList")
    //创建swiper实例
    let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
    })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法一：等我们的数据请求完毕后再创建swiper实例。只需要加一个1000ms时间延迟再创建swiper实例.。将上面代码改为：</p>
<pre class="line-numbers language-none"><code class="language-none">mounted() {
    this.$store.dispatch("getBannerList")
    setTimeout(()=&gt;{
      let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
    },1000)
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方法一肯定不是最好的，但是我们开发的第一要义就是实现功能，之后再完善。</p>
<p>解决方法二：我们可以使用watch监听bannerList轮播图列表属性，因为bannerList初始值为空，当它有数据时，我们就可以创建swiper对象</p>
<pre class="line-numbers language-none"><code class="language-none">watch:{
    bannerList(newValue,oldValue){
        let mySwiper = new Swiper(this.$refs.cur,{
          pagination:{
            el: '.swiper-pagination',
            clickable: true,
          },
          // 如果需要前进后退按钮
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
          // 如果需要滚动条
          scrollbar: {
            el: '.swiper-scrollbar',
          },
        })
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使这样也还是无法实现轮播图，原因是，我们轮播图的html中有v-for的循环，我们是通过v-for遍历bannerList中的图片数据，然后展示。我们的watch只能保证在bannerList变化时创建swiper对象，但是并不能保证此时v-for已经执行完了。假如watch先监听到bannerList数据变化，执行回调函数创建了swiper对象，之后v-for才执行，这样也是无法渲染轮播图图片 <strong>（因为swiper对象生效的前提是html即dom结构已经渲染好了）</strong></p>
<p><strong>完美解决方案：</strong> 使用watch+<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">this.$nextTick()</a><br>官方介绍：this. $nextTick它会将回调延迟到下次 DOM <strong>更新循环之后执行</strong>（循环就是这里的v-for）<br><strong>个人理解：</strong> 无非是等我们页面中的结构都有了再去执行回调函数</p>
<p>完整代码</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;
  &lt;!--列表--&gt;
  &lt;div class="list-container"&gt;
    &lt;div class="sortList clearfix"&gt;
      &lt;div class="center"&gt;
        &lt;!--banner轮播--&gt;
        &lt;div class="swiper-container" id="mySwiper"&gt;

          &lt;div class="swiper-wrapper"&gt;
            &lt;div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id"&gt;
              &lt;img :src="carouse.imgUrl" /&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;!-- 如果需要分页器 --&gt;
          &lt;div class="swiper-pagination"&gt;&lt;/div&gt;

          &lt;!-- 如果需要导航按钮 --&gt;
          &lt;div class="swiper-button-prev" &gt;&lt;/div&gt;
          &lt;div class="swiper-button-next"&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
import {mapState} from "vuex";
export default {
  name: "index",
  //主键挂载完毕，ajax请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
    //从仓库中获取轮播图数据
      bannerList: (state) =&gt; {return state.home.bannerList}
    })
  },
  watch:{
    bannerList(newValue,oldValue){
        //this.$nextTick()使用
        this.$nextTick(()=&gt;{
          let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
            pagination:{
              el: '.swiper-pagination',
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },
            // 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })
        })
    }
  }
}
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意：</strong> 之前我们在学习watch时，一般都是监听的定义在data中的属性，但是我们这里是监听的computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。</p>
<h2 id="将轮播图模块提取为全局组件"><a href="#将轮播图模块提取为全局组件" class="headerlink" title="将轮播图模块提取为全局组件"></a>将轮播图模块提取为全局组件</h2><p>需要注意的是我们要把定义swiper对象放在watch中执行，并且还要设置immediate：true属性，这样可以实现，无论数据有没有变化，上来立即监听一次。</p>
<p>全局组件Carousel代码</p>
<pre class="line-numbers language-Carousel.vue" data-language="Carousel.vue"><code class="language-Carousel.vue">&lt;template&gt;
  &lt;div class="swiper-container" ref="cur" id="floor1Swiper"&gt;
    &lt;div class="swiper-wrapper"&gt;
      &lt;div class="swiper-slide" v-for="(carouse,index) in carouselList" :key="carouse.id"&gt;
        &lt;img :src="carouse.imgUrl"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 如果需要分页器 --&gt;
    &lt;div class="swiper-pagination"&gt;&lt;/div&gt;

    &lt;!-- 如果需要导航按钮 --&gt;
    &lt;div class="swiper-button-prev"&gt;&lt;/div&gt;
    &lt;div class="swiper-button-next"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Swiper from "swiper";
export default {
  name: "Carousel",
  props:["carouselList"],
  watch: {
    carouselList: {
      //这里监听，无论数据有没有变化，上来立即监听一次
      immediate: true,
      //监听后执行的函数
      handler(){
        //第一次ListContainer中的轮播图Swiper定义是采用watch+ this.$nextTick()实现

        this.$nextTick(() =&gt; {
          let mySwiper = new Swiper(this.$refs.cur,{
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: '.swiper-pagination',
              // clickable: true
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },

            // 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })
        })
      }
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在main.js中注册全局组件并引入swiper的css样式文件</p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">// 注册轮播图组件
import Carousel from '@/components/Carousel'
Vue.component(Carousel.name,Carousel)
// 引入swiper样式
import 'swiper/css/swiper.css'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在其它组件中使用轮播图模块：<code>&lt;Carousel :carouselList="list.carouselList"/&gt;</code></p>
<h2 id="getters使用"><a href="#getters使用" class="headerlink" title="getters使用"></a>getters使用</h2><p><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/getters.html#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">getters使用</a><br>如果不使用getters属性，我们在组件获取state中的数据表达式为：<strong>this.$store.state.子模块.属性</strong><br>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><strong>注意：</strong> 仓库中的getters是全局属性，是不分模块的。即store中所有模块的getter内的函数都可以通过 <strong>$store.getters.函数名</strong> 获取</p>
<p>下图为store内容<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/getters%E4%BD%BF%E7%94%A8.png"></p>
<p>我们在Search模块中获取商品列表数据就是通过getters实现，<strong>需要注意的是当网络出现故障时应该将返回值设置为空，如果不设置返回值就变成了undefined</strong></p>
<p>store中search模块代码</p>
<pre class="line-numbers language-none"><code class="language-none">import {reqGetSearchInfo} from '@/api';
const state = {
    searchList:{},
}
const mutations = {
    SEARCHLIST(state,searchList){
        state.searchList = searchList
    }
}
const actions = {
    //第二个参数data默认是一个空对象
    async getSearchListr({commit},data={}){
        let result = await reqGetSearchInfo(data)

        if(result.code === 200){
            commit("SEARCHLIST",result.data)
        }
    }
}
const getters = {
    goodsList(state){
        //网络出现故障时应该将返回值设置为空
        return state.searchList.goodsList||[]
    }
}
export default {
    state,
    mutations,
    actions,
    getters,
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Search组件中使用getters获取仓库数据</p>
<pre class="line-numbers language-none"><code class="language-none">//只展示了使用getters的代码
&lt;script&gt;
  //引入mapGetters
  import {mapGetters} from 'vuex'
  export default {
    name: 'Search',
    computed:{
      //使用mapGetters，参数是一个数组，数组的元素对应getters中的函数名
      ...mapGetters(['goodsList'])
    }
  }
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Object-asign实现对象拷贝"><a href="#Object-asign实现对象拷贝" class="headerlink" title="Object.asign实现对象拷贝"></a>Object.asign实现对象拷贝</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f9ec860ecd81">参考链接</a></p>
<pre class="line-numbers language-none"><code class="language-none">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】
举个栗子：
const object1 = {
  a: 1,
  b: 2,
  c: 3
};

const object2 = Object.assign({c: 4, d: 5}, object1);

console.log(object2.c, object2.d);
console.log(object1)  // { a: 1, b: 2, c: 3 }
console.log(object2)  // { c: 3, d: 5, a: 1, b: 2 }

注意：
1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性
2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标
对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如
果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到
原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h2><pre class="line-numbers language-none"><code class="language-none">针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。
let obj1 = { a: 0 , b: { c: 0}}; 
let obj2 = Object.assign({}, obj1); 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj1.a = 1; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj2.a = 2; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}
 
obj2.b.c = 3; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}} 
最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响

// Deep Clone （深拷贝）
obj1 = { a: 0 , b: { c: 0}}; 
let obj3 = JSON.parse(JSON.stringify(obj1)); 
obj1.a = 4; 
obj1.b.c = 4; 
console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="利用路由信息变化实现动态搜索"><a href="#利用路由信息变化实现动态搜索" class="headerlink" title="利用路由信息变化实现动态搜索"></a>利用路由信息变化实现动态搜索</h2><p><strong>最佳方法：</strong> 我们每次进行新的搜索时，我们的query和params参数中的部分内容肯定会改变，而且这两个参数是路由的属性。我们可以通过监听路由信息的变化来动态发起搜索请求</p>
<p>如下图所示，$route是组件的属性，所以watch是可以监听的（watch可以监听组件data中所有的属性）<br><strong>注意：</strong> 组件中data的属性包括：自己定义的、系统自带的（如 $route）、父组件向子组件传递的等等</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%88%A9%E7%94%A8%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8F%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%90%9C%E7%B4%A21.png"></p>
<pre class="line-numbers language-search.vue" data-language="search.vue"><code class="language-search.vue">watch: {
    //监听路由的信息是否发生变化，如果发生变化，再次发起请求
    $route(newValue, oldValue) {
      //每一次请求完毕，应该把相应的1、2、3级分类的id置空的，让他接受下一次的相应1、2、3
      //分类名字与关键字不用清理：因为每一次路由发生变化的时候，都会给他赋予新的数据
      this.searchParams.category1Id = undefined;
      this.searchParams.category2Id = undefined;
      this.searchParams.category3Id = undefined;
      //再次发请求之前整理带给服务器参数
      Object.assign(this.searchParams, this.$route.query, this.$route.params);
      //再次发起ajax请求
      this.getData();
    },
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="面包屑相关操作"><a href="#面包屑相关操作" class="headerlink" title="面包屑相关操作"></a>面包屑相关操作</h2><p>本次项目的面包屑操作主要就是两个删除逻辑。</p>
<ul>
<li>当分类属性（query）删除时删除面包屑同时修改路由信息。</li>
<li>当搜索关键字（params）删除时删除面包屑、修改路由信息、同时删除输入框内的关键字。</li>
</ul>
<ol>
<li><p>query删除时<br>因为此部分在面包屑中是通过categoryName展示的，所以删除时应将该属性值制空或undefined。<br>可以通过路由再次跳转修改路由信息和url链接</p>
<pre class="line-numbers language-none"><code class="language-none">//删除分类
removeBread(){
  this.searchParams.categoryName = undefined
  this.$router.push({name:'Search',params:this.$route.params})
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>params删除时<br>和query删除的唯一不同点是此部分会多一步操作：删除输入框内的关键字（因为params参数是从输入框内获取的）<br>输入框是在Header组件中的<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E9%9D%A2%E5%8C%85%E5%B1%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C1.png"></p>
</li>
</ol>
<p>header和search组件是兄弟组件，要实现该操作就要通过兄弟组件之间进行通信完成。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E9%9D%A2%E5%8C%85%E5%B1%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C2.png"></p>
<p>这里通过$bus实现header和search组件的通信</p>
<ol>
<li><p>在main.js中注册</p>
<pre class="line-numbers language-none"><code class="language-none">new Vue({
  //全局事件总线$bus配置
  beforeCreate() {
    //此处的this就是这个new Vue()对象
    //网络有很多bus通信总结，原理相同，换汤不换药
    Vue.prototype.$bus = this
  },
  render: h =&gt; h(App),
  //router2、注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>search组件使用$bus通信，第一个参数可以理解为为通信的暗号，还可以有第二个参数（用于传递数据），我们这里只是用于通知header组件进行相应操作，所以没有设置第二个参数</p>
<pre class="line-numbers language-none"><code class="language-none">//删除搜索关键字
removeBreadParams(){
    this.searchParams.keyword = undefined
    //通知兄弟组件header删除输入框的keyword关键字
    this.$bus.$emit("clear")
    this.$router.push({name:'Search',query:this.$route.query})
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>header组件接受$bus通信，注意：组件挂载时就监听clear事件</p>
<pre class="line-numbers language-none"><code class="language-none">mounted() {
  //  组件挂载时就监听clear事件，clear事件在search模块中定义
  //  当删除关键字面包屑时，触发该事件，同时header的输入框绑定的keyword要删除
    this.$bus.$on("clear",()=&gt;{
      this.keyword = ''
    })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
</ol>
<h2 id="SearchSelector子组件传参及面包屑操作"><a href="#SearchSelector子组件传参及面包屑操作" class="headerlink" title="SearchSelector子组件传参及面包屑操作"></a>SearchSelector子组件传参及面包屑操作</h2><p>SearchSelector组件有两个属性也会生成面包屑，分别为品牌名、手机属性。<br>如下图所示<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/SearchSelector%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E5%8F%8A%E9%9D%A2%E5%8C%85%E5%B1%91%E6%93%8D%E4%BD%9C.png"></p>
<p>此处生成面包屑时会涉及到子组件向父组件传递信息操作，之后的操作面包屑操作原理相同。唯一的区别是，这里删除面包屑时不需要修改地址栏url，因为url是由路由地址确定的，并且只有query、params两个参数变化回影响路由地址变化。</p>
<p>总结：面包屑由四个属性影响：parads、query、品牌、手机属性<br>面包屑生成逻辑<br>判断searchParams相关属性是否存在，存在即显示<br>面包屑删除逻辑</p>
<pre class="line-numbers language-Search.vue" data-language="Search.vue"><code class="language-Search.vue">&lt;script&gt;
  import SearchSelector from './SearchSelector/SearchSelector'
  import {mapGetters} from 'vuex'
  export default {
    name: 'Search',
    components: {
      SearchSelector
    },
    data(){
      return{
        //动态获取searchParams
        searchParams:{
          category1Id: "",//一级分类id
          category2Id: "",//二级分类id
          category3Id: "",//三级分类id
          categoryName: "",
          keyword: "",
          order: "1:desc",
          pageNo: 1,
          pageSize: 10,
          props: [],//平台售卖属性
          trademark: ""//品牌
        },
      }
    },
    //在组件挂在之前动态编辑searchParams的值，因为组件挂在之后会使用到searchParams
    beforeMount() {
      //Object.assign方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
      //Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象
      Object.assign(this.searchParams,this.$route.query,this.$route.params)
    },
    methods:{
      //搜索
      searchInfo(){
        this.$store.dispatch("getSearchListr",this.searchParams)
      },
      //删除分类(query)面包屑
      removeBread(){
        this.searchParams.categoryName = undefined
        this.$router.push({name:'Search',params:this.$route.params})
      },
      //删除搜索关键字(params)面包屑
      removeBreadParams(){
        this.searchParams.keyword = undefined
        //通知兄弟组件header删除输入框的keyword关键字
        this.$bus.$emit("clear")
        this.$router.push({name:'Search',query:this.$route.query})
      },
      //获取子组件传递的品牌信息（自定义事件）
      tradeMarkInfo(tradeMark){
        //接口文档中trademark的信息是"ID:品牌名称"形式
        this.searchParams.trademark = `${tradeMark.tmId}:${tradeMark.tmName}`
        this.searchInfo()
      },
      //删除品牌面包屑
      removeTradeMark(){
        this.searchParams.trademark = undefined
        this.searchInfo()
      },
      //获取子组件传递的属性信息（自定义事件）
      attrInfo(attr,attrValue){
        //searchParams.props元素为字符串形式，api文档有介绍
        let props = `${attr.attrId}:${attrValue}:${attr.attrName}`
        //数组去重
        if(this.searchParams.props.indexOf(props)===-1){
          this.searchParams.props.push(props)
          this.searchInfo()
        }
      },
      //删除属性面包屑
      removeAttr(index){
        this.searchParams.props.splice(index,1)
      }
    },
    mounted() {
      this.searchInfo()
    },
    computed:{
      ...mapGetters(['goodsList'])
    },
    //watch可以监听组件上的属性
    watch:{
      $route:{
        handler(newValue,oldValue){
          console.log(this.$route)
          Object.assign(this.searchParams,this.$route.query,this.$route.params)
          this.searchInfo()
          //如果下一次搜索时只有params参数，拷贝后会发现searchParams会保留上一次的query参数
          //所以每次请求结束后将相应参数制空
          this.searchParams.category1Id = undefind;
          this.searchParams.category2Id = undefind;
          this.searchParams.category3Id = undefind;
        },
      }
    },
  }
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="商品排序"><a href="#商品排序" class="headerlink" title="商品排序"></a>商品排序</h2><p>排序的逻辑比较简单，只是改变一下请求参数中的order字段，后端会根据order值返回不同的数据来实现升降序<br>order属性值为字符串，例如‘1：asc’、‘2：desc’。1代表综合，2代表价格，asc代表升序，desc代表降序<br>我们的升降序是通过箭头图标来辨别的，如图所示：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F1.png"></p>
<p>图标是iconfont网站的图标，通过引入在线css的方式引入图标<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F2.png"></p>
<p>在public文件index引入该css<br><code>&lt;link rel="stylesheet" href="https://at.alicdn.com/t/font_2994457_qqwrvmss9l9.css"&gt;</code></p>
<p>在search模块使用该图标</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;div class="sui-navbar"&gt;
    &lt;div class="navbar-inner filter"&gt;
      &lt;ul class="sui-nav"&gt;
        &lt;!-- 这里isOne、isTwo、isAsc、isDesc是计算属性，如果不使用计算属性要在页面中写很长的代码--&gt;
        &lt;li :class="{active:isOne}" @click="changeOrder('1')"&gt;
          &lt;!--阿里图标前置类iconfont--&gt;
          &lt;a &gt;综合&lt;span v-show="isOne" class="iconfont" :class="{'icon-up':isAsc,'icon-down':isDesc}"&gt;&lt;/span&gt;&lt;/a&gt;
        &lt;/li&gt;
        &lt;li :class={active:isTwo} @click="changeOrder('2')"&gt;
          &lt;a &gt;价格&lt;span v-show="isTwo" class="iconfont" :class="{'icon-up':isAsc,'icon-down':isDesc}"&gt;&lt;/span&gt;&lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>isOne、isTwo、isAsc、isDesc计算属性代码</p>
<pre class="line-numbers language-none"><code class="language-none">computed:{
    ...mapGetters(['goodsList']),
    isOne(){
      return this.searchParams.order.indexOf('1')!==-1
    },
    isTwo(){
      return this.searchParams.order.indexOf('2')!==-1
    },
    isDesc(){
      return this.searchParams.order.indexOf('desc')!==-1
    },
    isAsc(){
      return this.searchParams.order.indexOf('asc')!==-1
    },
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>点击‘综合’或‘价格’的触发函数changeOrder</p>
<pre class="line-numbers language-none"><code class="language-none">//flag用于区分综合、价格，1：综合，2：价格
changeOrder(flag){
    let newSearchOrder = this.searchParams.order
    //将order拆为两个字段orderFlag(1:2)、order(asc:desc)
    let orderFlag = this.searchParams.order.split(':')[0]
    let order = this.searchParams.order.split(':')[1]
    //由综合到价格、由价格到综合
    if(orderFlag!==flag){
      //点击的不是同一个按钮
      newSearchOrder = `${flag}:desc`
      this.searchInfo()
    }else{
      //多次点击的是不是同一个按钮
      newSearchOrder = `${flag}:${order==='desc'?'asc':'desc'}`
    }
    //需要给order重新赋值
    this.searchParams.order = newSearchOrder;
    //再次发请求
    this.searchInfo();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
















<h1 id="尚品汇后台管理系统"><a href="#尚品汇后台管理系统" class="headerlink" title="尚品汇后台管理系统"></a>尚品汇后台管理系统</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Serein</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://serein.icu/posts/7.html">https://serein.icu/posts/7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://serein.icu" target="_blank">Serein's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/zhifubao.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/zhifubao.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/6.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/6.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Promise学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3.html" title="Vue2进阶知识"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">Vue2进阶知识</div></div></a></div><div><a href="/posts/4.html" title="Vue3快速上手"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">Vue3快速上手</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/headimg_dl.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Serein</div><div class="author-info__description">热爱大前端并怀揣着梦想</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://serein.icu/"><i class="fab fa-home"></i><span>个人主页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/EATBFL/EATBFL.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1297711534&amp;website=www.serein.icu" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">兴趣爱好才是最大的动力，何不与我共同来攀知识高峰，一览众山小！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AFVue%E6%A0%B8%E5%BF%83"><span class="toc-number">1.</span> <span class="toc-text">前端Vue核心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%9A%E5%93%81%E6%B1%87%E5%89%8D%E5%8F%B0%E5%95%86%E5%93%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">尚品汇前台商品系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">vue文件目录分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">项目配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80"><span class="toc-number">2.2.1.</span> <span class="toc-text">项目运行，浏览器自动打开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%ADeslint%E6%A0%A1%E9%AA%8C%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%8D%E5%85%B3%E9%97%AD%E4%BC%9A%E6%9C%89%E5%90%84%E7%A7%8D%E8%A7%84%E8%8C%83%EF%BC%8C%E4%B8%8D%E6%8C%89%E7%85%A7%E8%A7%84%E8%8C%83%E5%B0%B1%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#src%E6%96%87%E4%BB%B6%E5%A4%B9%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D-%E5%88%9B%E5%BB%BAjsconfig-json"><span class="toc-number">2.2.3.</span> <span class="toc-text">src文件夹配置别名,创建jsconfig.json</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">组件页面样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4vue%E9%A1%B5%E9%9D%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">清除vue页面默认的样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#views-pages%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.5.</span> <span class="toc-text">views&#x2F;pages文件夹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.1.</span> <span class="toc-text">路由组件和非路由组件区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">路由跳转方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">2.6.</span> <span class="toc-text">路由传参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#params%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.1.</span> <span class="toc-text">params传参问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">传参方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84push%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.</span> <span class="toc-text">多次执行相同的push问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-number">2.8.</span> <span class="toc-text">定义全局组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85axios"><span class="toc-number">2.9.</span> <span class="toc-text">封装axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.</span> <span class="toc-text">前端通过代理解决跨域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85"><span class="toc-number">2.11.</span> <span class="toc-text">请求接口统一封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nprogress%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8F%92%E4%BB%B6"><span class="toc-number">2.12.</span> <span class="toc-text">nprogress进度条插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BC%95%E5%85%A5vuex"><span class="toc-number">2.13.</span> <span class="toc-text">手动引入vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await%E4%BD%BF%E7%94%A8"><span class="toc-number">2.14.</span> <span class="toc-text">async await使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex"><span class="toc-number">2.15.</span> <span class="toc-text">vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loadsh%E6%8F%92%E4%BB%B6%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">2.16.</span> <span class="toc-text">loadsh插件防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="toc-number">2.17.</span> <span class="toc-text">编程式导航+事件委托实现路由跳转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E8%B7%AF%E7%94%B1%E9%94%80%E6%AF%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.18.</span> <span class="toc-text">Vue路由销毁问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mock%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">2.19.</span> <span class="toc-text">mock插件使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">2.20.</span> <span class="toc-text">vuex数据存储与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swiper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE"><span class="toc-number">2.21.</span> <span class="toc-text">swiper插件实现轮播图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%A8%A1%E5%9D%97%E6%8F%90%E5%8F%96%E4%B8%BA%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-number">2.22.</span> <span class="toc-text">将轮播图模块提取为全局组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getters%E4%BD%BF%E7%94%A8"><span class="toc-number">2.23.</span> <span class="toc-text">getters使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-asign%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.24.</span> <span class="toc-text">Object.asign实现对象拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.25.</span> <span class="toc-text">对象深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8F%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%90%9C%E7%B4%A2"><span class="toc-number">2.26.</span> <span class="toc-text">利用路由信息变化实现动态搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%8C%85%E5%B1%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">2.27.</span> <span class="toc-text">面包屑相关操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SearchSelector%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E5%8F%8A%E9%9D%A2%E5%8C%85%E5%B1%91%E6%93%8D%E4%BD%9C"><span class="toc-number">2.28.</span> <span class="toc-text">SearchSelector子组件传参及面包屑操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F"><span class="toc-number">2.29.</span> <span class="toc-text">商品排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%9A%E5%93%81%E6%B1%87%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">尚品汇后台管理系统</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/7.html" title="尚品汇Vue项目总结"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="尚品汇Vue项目总结"/></a><div class="content"><a class="title" href="/posts/7.html" title="尚品汇Vue项目总结">尚品汇Vue项目总结</a><time datetime="2022-04-08T03:30:00.000Z" title="发表于 2022-04-08 11:30:00">2022-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6.html" title="Promise学习笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/6.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Promise学习笔记"/></a><div class="content"><a class="title" href="/posts/6.html" title="Promise学习笔记">Promise学习笔记</a><time datetime="2022-03-28T09:30:00.000Z" title="发表于 2022-03-28 17:30:00">2022-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5.html" title="ES6学习笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/4.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="ES6学习笔记"/></a><div class="content"><a class="title" href="/posts/5.html" title="ES6学习笔记">ES6学习笔记</a><time datetime="2022-03-18T13:00:00.000Z" title="发表于 2022-03-18 21:00:00">2022-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4.html" title="Vue3快速上手"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/5.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Vue3快速上手"/></a><div class="content"><a class="title" href="/posts/4.html" title="Vue3快速上手">Vue3快速上手</a><time datetime="2022-03-14T06:00:00.000Z" title="发表于 2022-03-14 14:00:00">2022-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3.html" title="Vue2进阶知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/3.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Vue2进阶知识"/></a><div class="content"><a class="title" href="/posts/3.html" title="Vue2进阶知识">Vue2进阶知识</a><time datetime="2022-03-14T04:00:00.000Z" title="发表于 2022-03-14 12:00:00">2022-03-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Serein</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'L4e8DCjFsSv0rSH273oEwafp-MdYXbMMI',
      appKey: 'LtRxHbGm7RB4OJge5cOJ2bdL',
      placeholder: '畅所欲言！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'l4e8dcjf.api.lncldglobal.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://serein.icu/posts/7.html'
    this.page.identifier = 'posts/7.html'
    this.page.title = '尚品汇Vue项目总结'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://Serein.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer id="dsq-count-scr" src="//xianqi.disqus.com/count.js" async></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/animate.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="//code.tidio.co/kn1idpwt8fdo1pdgxkxq0w4m1zo4ponz.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>