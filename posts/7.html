<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>尚品汇Vue项目总结 | Serein's blog</title><meta name="keywords" content="Vue"><meta name="author" content="Serein"><meta name="copyright" content="Serein"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前端Vue核心 开发一个前端模块可以概括为以下几个步骤：  写静态页面、拆分为静态组件； 发请求（API）； vuex（actions、mutations、state三连操作）； 组件获取仓库数据，动态展示；   尚品汇前台商品系统vue文件目录分析public文件夹：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。pubilc&#x2F;index.html 是一个模板文件，作用是">
<meta property="og:type" content="article">
<meta property="og:title" content="尚品汇Vue项目总结">
<meta property="og:url" content="https://serein.icu/posts/7.html">
<meta property="og:site_name" content="Serein&#39;s blog">
<meta property="og:description" content="前端Vue核心 开发一个前端模块可以概括为以下几个步骤：  写静态页面、拆分为静态组件； 发请求（API）； vuex（actions、mutations、state三连操作）； 组件获取仓库数据，动态展示；   尚品汇前台商品系统vue文件目录分析public文件夹：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。pubilc&#x2F;index.html 是一个模板文件，作用是">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg">
<meta property="article:published_time" content="2022-04-08T03:30:00.000Z">
<meta property="article:modified_time" content="2022-04-13T10:26:40.453Z">
<meta property="article:author" content="Serein">
<meta property="article:tag" content="Vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/weather.png"><link rel="canonical" href="https://serein.icu/posts/7"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"一年之内的产物","messageNext":"技术可能存在过期"},
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: Serein","link":"链接: ","source":"来源: Serein's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '尚品汇Vue项目总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-13 18:26:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><link defer rel="stylesheet" href="/css/customm.css" ><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/icon.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/background.css"><link defer rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/css/index_ee.css"><meta name="generator" content="Hexo 5.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="Serein's blog" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/headimg_dl.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/Windows/"><i class="fa-fw fa fa-desktop"></i><span> Windows</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Serein's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-archive"></i><span> 归档</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fas fa-book"></i><span> 说说</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时轴</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 清单</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/List/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/List/gallery/"><i class="fa-fw fa fa-image"></i><span> 相册</span></a></li><li><a class="site-page child" href="/List/movies/"><i class="fa-fw fa fa-film"></i><span> 视频</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tools/"><i class="fa-fw fa fa-suitcase"></i><span> 百宝箱</span></a></div><div class="menus_item"><a class="site-page" href="/Windows/"><i class="fa-fw fa fa-desktop"></i><span> Windows</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">尚品汇Vue项目总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-08T03:30:00.000Z" title="发表于 2022-04-08 11:30:00">2022-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-13T10:26:40.453Z" title="更新于 2022-04-13 18:26:40">2022-04-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/">项目实战</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="尚品汇Vue项目总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="前端Vue核心"><a href="#前端Vue核心" class="headerlink" title="前端Vue核心"></a>前端Vue核心</h1><blockquote>
<p><strong>开发一个前端模块可以概括为以下几个步骤：</strong></p>
<ol>
<li>写静态页面、拆分为静态组件；</li>
<li>发请求（API）；</li>
<li>vuex（actions、mutations、state三连操作）；</li>
<li>组件获取仓库数据，动态展示；</li>
</ol>
</blockquote>
<h1 id="尚品汇前台商品系统"><a href="#尚品汇前台商品系统" class="headerlink" title="尚品汇前台商品系统"></a>尚品汇前台商品系统</h1><h2 id="vue文件目录分析"><a href="#vue文件目录分析" class="headerlink" title="vue文件目录分析"></a>vue文件目录分析</h2><p><strong>public文件夹</strong>：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。<br><strong>pubilc/index.html</strong> 是一个模板文件，作用是生成项目的入口文件，webpack打包的js,css也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html。</p>
<blockquote>
<p><strong>src文件夹（程序员代码文件夹）</strong><br>assets： 存放公用的静态资源<br>components： 非路由组件（全局组件），其他组件放在views或者pages文件夹中<br>App.vue： 唯一的根组件<br>main.js： 程序入口文件，最先执行的文件</p>
</blockquote>
<h2 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h2><h3 id="项目运行，浏览器自动打开"><a href="#项目运行，浏览器自动打开" class="headerlink" title="项目运行，浏览器自动打开"></a>项目运行，浏览器自动打开</h3><pre class="line-numbers language-package.json" data-language="package.json"><code class="language-package.json">"scripts": {
  "serve": "vue-cli-service serve --open",
  "build": "vue-cli-service build",
  "lint": "vue-cli-service lint"
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）"><a href="#关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）" class="headerlink" title="关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）"></a>关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）</h3><p><strong>根目录下创建vue.config.js,进行配置</strong></p>
<pre class="line-numbers language-vue.config.js" data-language="vue.config.js"><code class="language-vue.config.js">module.exports = {
  //关闭eslint
  lintOnSave: false
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="src文件夹配置别名-创建jsconfig-json"><a href="#src文件夹配置别名-创建jsconfig-json" class="headerlink" title="src文件夹配置别名,创建jsconfig.json"></a>src文件夹配置别名,创建jsconfig.json</h3><p><strong>用@/代替src/，exclude表示不可以使用该别名的文件</strong></p>
<pre class="line-numbers language-jsconfig.json" data-language="jsconfig.json"><code class="language-jsconfig.json">{
   "compilerOptions": {
       "baseUrl": "./",
           "paths": {
           "@/*": [
               "src/*"
           ]
       }
   },

   "exclude": [
       "node_modules",
       "dist"
   ]
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="组件页面样式"><a href="#组件页面样式" class="headerlink" title="组件页面样式"></a>组件页面样式</h2><p>组件页面的样式使用的是less样式，浏览器不识别该样式，需要下载相关依赖<br><strong>npm install –save less less-loader@5</strong><br>如果想让组件识别less样式，则在组件中设置</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;style scoped lang="less"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="清除vue页面默认的样式"><a href="#清除vue页面默认的样式" class="headerlink" title="清除vue页面默认的样式"></a>清除vue页面默认的样式</h2><p><strong>vue是单页面开发，我们只需要修改public下的index.html文件</strong></p>
<pre class="line-numbers language-index.html" data-language="index.html"><code class="language-index.html">&lt;link rel="stylesheet" href="reset.css"&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<h2 id="views-pages文件夹"><a href="#views-pages文件夹" class="headerlink" title="views/pages文件夹"></a>views/pages文件夹</h2><ul>
<li>创建views/pages文件夹，并创建路由组件</li>
<li>创建router文件夹，并创建index.js进行路由配置，最终在main.js中引入注册<h3 id="路由组件和非路由组件区别"><a href="#路由组件和非路由组件区别" class="headerlink" title="路由组件和非路由组件区别"></a>路由组件和非路由组件区别</h3><blockquote>
<p>非路由组件放在components中，路由组件放在pages或views中<br>非路由组件通过标签使用，路由组件通过路由使用<br>在main.js注册玩路由，所有的路由和非路由组件身上都会拥有$router和$route属性<br>$router：一般进行编程式导航进行路由跳转<br>$route：一般获取路由信息（name path params等）</p>
</blockquote>
<h3 id="路由跳转方式"><a href="#路由跳转方式" class="headerlink" title="路由跳转方式"></a>路由跳转方式</h3></li>
<li>声明式导航router-link标签 ,可以把router-link理解为一个a标签，它 也可以加class修饰</li>
<li>编程式导航 ：声明式导航能做的编程式都能做，而且还可以处理一些业务</li>
</ul>
<h2 id="路由传参"><a href="#路由传参" class="headerlink" title="路由传参"></a>路由传参</h2><p><strong>query、params两个属性可以传递参数</strong></p>
<blockquote>
<p>query参数：不属于路径当中的一部分，类似于get请求，地址栏表现为 /search?k1=v1&amp;k2=v2<br>query参数对应的路由信息 path: “/search”<br>params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位 ,地址栏表现为 /search/v1/v2<br>params参数对应的路由信息要修改为path: “/search/:keyword” 这里的/:keyword就是一个params参数的占位符</p>
</blockquote>
<h3 id="params传参问题"><a href="#params传参问题" class="headerlink" title="params传参问题"></a>params传参问题</h3><p><strong>1. 如何指定params参数可传可不传</strong></p>
<blockquote>
<p>如果路由path要求传递params参数,但是没有传递,会发现地址栏URL有问题，详情如下：<br> Search路由项的path已经指定要传一个keyword的params参数，如下所示：<br>  path: “/search/:keyword”,<br>  执行下面进行路由跳转的代码：<br>  this.$router.push({name:”Search”,query:{keyword:this.keyword}})<br>  当前跳转代码没有传递params参数<br>  地址栏信息：<a target="_blank" rel="noopener" href="http://localhost:8080/#/?keyword=asd">http://localhost:8080/#/?keyword=asd</a><br>  此时的地址信息少了/search<br>  正常的地址栏信息: <a target="_blank" rel="noopener" href="http://localhost:8080/#/search?keyword=asd">http://localhost:8080/#/search?keyword=asd</a><br>  解决方法：可以通过改变path来指定params参数可传可不传<br>path: “/search/:keyword?”,?表示该参数可传可不传</p>
</blockquote>
<p><strong>参考连接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44867717/article/details/109773945">https://blog.csdn.net/weixin_44867717/article/details/109773945</a></strong></p>
<p><strong>2. 已知params可传可不传，但是如果传递的时空串，如何解决</strong></p>
<blockquote>
<p>this.$router.push({name:”Search”,query:{keyword:this.keyword},params:{keyword:’’}})<br> 出现的问题和1中的问题相同,地址信息少了/search<br> 解决方法： 加入||undefined，当我们传递的参数为空串时地址栏url也可以保持正常<br>this.$router.push({name:”Search”,query:{keyword:this.keyword},params:{keyword:’’||undefined}})</p>
</blockquote>
<p><strong>3. 路由组件能不能传递props数据？</strong><br>可以，但是只能传递params参数,具体知识为props属性<br><strong>参考连接：<a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/essentials/passing-props.html">https://router.vuejs.org/zh/guide/essentials/passing-props.html</a></strong></p>
<h3 id="传参方法"><a href="#传参方法" class="headerlink" title="传参方法"></a>传参方法</h3><p><strong>字符串形式</strong><br>this.$router.push(“/search/“+this.params传参+”?k=”+this.query传参)</p>
<p><strong>模板字符串</strong><br>this.router.push(“/search/+router.push(“/search/+router.push(“/search/+{this.params传参}?k=${this.query传参}”)<br><strong>注意：</strong> 上面字符串的传参方法可以看出params参数和’/‘结合，query参数和？结合<br><a target="_blank" rel="noopener" href="http://localhost:8080/#/search/asd?keyword=asd">http://localhost:8080/#/search/asd?keyword=asd</a><br>上面url中asd为params的值，keyword=asd为query传递的值。</p>
<p><strong>对象（常用）</strong><br>this.$router.push({name:“路由名字”,params:{传参},query:{传参})<br>以对象方式传参时，如果我们传参中使用了params，只能使用name，不能使用path，如果只是使用query传参，可以使用path </p>
<h2 id="多次执行相同的push问题"><a href="#多次执行相同的push问题" class="headerlink" title="多次执行相同的push问题"></a>多次执行相同的push问题</h2><p>多次执行相同的push问题，控制台会出现警告<br>例如：使用this.$router.push({name:‘Search’,params:{keyword:”…”||undefined}})时，如果多次执行相同的push，控制台会出现警告。</p>
<pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">let result = this.$router.push({name:"Search",query:{keyword:this.keyword}})
console.log(result)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><strong>执行一次上面代码：</strong><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84push%E9%97%AE%E9%A2%981.png"><br><strong>多次执行出现警告：</strong><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84push%E9%97%AE%E9%A2%982.png"></p>
<p><strong>原因：</strong> push是一个promise，promise需要传递成功和失败两个参数，我们的push中没有传递。<br>方法：this.$router.push({name:‘Search’,params:{keyword:”…”||undefined}},()=&gt;{},()=&gt;{})后面两项分别代表执行成功和失败的回调函数。<br><strong>这种写法治标不治本，将来在别的组件中push|replace,编程式导航还是会有类似错误</strong><br>push是VueRouter.prototype的一个方法，在router中的index重写该方法即可(看不懂也没关系，这是前端面试题)</p>
<pre class="line-numbers language-index.js" data-language="index.js"><code class="language-index.js">//1、先把VueRouter原型对象的push，保存一份
let originPush = VueRouter.prototype.push;
//2、重写push|replace
//第一个参数：告诉原来的push，跳转的目标位置和传递了哪些参数
VueRouter.prototype.push = function (location,resolve,reject){
  if(resolve &amp;&amp; reject){
    originPush.call(this,location,resolve,reject)
  }else{
    originPush.call(this,location,() =&gt; {},() =&gt; {})
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="定义全局组件"><a href="#定义全局组件" class="headerlink" title="定义全局组件"></a>定义全局组件</h2><p>我们的三级联动组件是全局组件，全局的配置都需要在main.js中配置</p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">//将三级联动组件注册为全局组件
import TypeNav from '@/pages/Home/TypeNav';
//第一个参数：全局组件名字，第二个参数：全局组件
Vue.component(TypeNav.name,TypeNav);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在Home组件中使用该全局组件，全局组件可以在任一页面中直接使用，不需要导入声明</p>
<pre class="line-numbers language-index.vue" data-language="index.vue"><code class="language-index.vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!--  三级联动全局组件已经注册为全局组件，因此不需要引入--&gt;
    &lt;TypeNav/&gt;
  &lt;/div&gt;
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="封装axios"><a href="#封装axios" class="headerlink" title="封装axios"></a>封装axios</h2><p><strong>axios中文文档，包含详细信息：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/yunye/axios/234845">https://www.kancloud.cn/yunye/axios/234845</a></strong><br>在根目录下创建api文件夹，创建request.js文件</p>
<pre class="line-numbers language-request.js" data-language="request.js"><code class="language-request.js">import axios from "axios";
//1、对axios二次封装
const requests = axios.create({
    //基础路径，requests发出的请求在端口号后面会跟改baseURl
    baseURL:'/api',
    timeout: 5000,
})
//2、配置请求拦截器
requests.interceptors.request.use(config =&gt; {
    //config内主要是对请求头Header配置
    //比如添加token
    return config;
})
//3、配置相应拦截器
requests.interceptors.response.use((res) =&gt; {
    //成功的回调函数
    return  res.data;
},(error) =&gt; {
    //失败的回调函数
    console.log("响应失败"+error)
    return Promise.reject(new Error('fail'))
})
//4、对外暴露
export default requests;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="前端通过代理解决跨域问题"><a href="#前端通过代理解决跨域问题" class="headerlink" title="前端通过代理解决跨域问题"></a>前端通过代理解决跨域问题</h2><p>在根目录下的vue.config.js中配置,proxy为通过代理解决跨域问题。<br>我们在封装axios的时候已经设置了baseURL为api,所以所有的请求都会携带/api，这里我们就将/api进行了转换。如果你的项目没有封装axios，或者没有配置baseURL，建议进行配置。要保证baseURL和这里的代理映射相同，此处都为’/api’</p>
<pre class="line-numbers language-vue.config.js" data-language="vue.config.js"><code class="language-vue.config.js">module.exports = {
    // 关闭ESLINT校验工具
    lintOnSave: false,
    devServer: {
        //代理服务器解决跨域
        proxy: {
            //会把请求路径中的/api换为后面的代理服务器
            '/api': {
                //提供数据的服务器地址
                target: 'http://39.98.123.211',
            }
        },
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://webpack.docschina.org/configuration/dev-server/#devserverproxy">webpack官网相关知识解读</a><br>网站中的webpack.config.js就是vue.config.js文件</p>
<h2 id="请求接口统一封装"><a href="#请求接口统一封装" class="headerlink" title="请求接口统一封装"></a>请求接口统一封装</h2><p>在文件夹api中创建index.js文件，用于封装所有请求<br><strong>将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可。</strong><br><strong>如下所示：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">//当前模块，API进行统一管理，即对请求接口统一管理
import requests from "@/api/request";
//首页三级分类接口
export const reqCateGoryList = () =&gt; {
    return  requests({
        url: '/product/getBaseCategoryList',
        method: 'GET'
    })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当组件想要使用相关请求时，只需要导入相关函数即可，以上图的reqCateGoryList 为例:</p>
<pre class="line-numbers language-none"><code class="language-none">import {reqCateGoryList} from './api'
//发起请求
reqCateGoryList();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h2 id="nprogress进度条插件"><a href="#nprogress进度条插件" class="headerlink" title="nprogress进度条插件"></a>nprogress进度条插件</h2><p>打开一个页面时，往往会伴随一些请求，并且会在页面上方出现进度条。它的原理时，在我们发起请求的时候开启进度条，在请求成功后关闭进度条，所以只需要在request.js中进行配置。</p>
<p><strong>对应的request.js设置</strong></p>
<pre class="line-numbers language-request.js" data-language="request.js"><code class="language-request.js">import axios from "axios";
//引入进度条
import nprogress from 'nprogress';
//引入进度条样式
import "nprogress/nprogress.css";
//1、对axios二次封装
const requests = axios.create({
    //基础路径，requests发出的请求在端口号后面会跟改baseURl
    baseURL:'/api',
    timeout: 5000,
})
//2、配置请求拦截器
requests.interceptors.request.use(config =&gt; {
    //config内主要是对请求头Header配置
    //比如添加token

    //开启进度条
    nprogress.start()
    return config
})
//3、配置相应拦截器
requests.interceptors.response.use((res) =&gt; {
    //成功的回调函数

    //响应成功，关闭进度条
    nprogress.done()
    return  res.data
},(error) =&gt; {
    //失败的回调函数
    console.log("响应失败"+error)
    return Promise.reject(new Error('fail'))
})
//4、对外暴露
export default requests<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以通过修改nprogress.css文件的background来修改进度条颜色</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/nprogress%E8%BF%9B%E5%BA%A6%E6%9D%A1.png"></p>
<h2 id="手动引入vuex"><a href="#手动引入vuex" class="headerlink" title="手动引入vuex"></a>手动引入vuex</h2><p>首先确保安装了vuex,根目录创建store文件夹，文件夹下创建index.js，内容如下：</p>
<pre class="line-numbers language-index.js" data-language="index.js"><code class="language-index.js">import Vue from 'vue'
import Vuex from 'vuex'
Vue.use(Vuex)
//对外暴露store的一个实例
export default new Vuex.Store({
    state:{},
    mutations:{},
    actions:{},
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果想要使用vuex，还要再main.js中引入<br>main.js:<br>(1) 引入文件<br>(2) 注册store<br><strong>但凡是在main.js中的Vue实例中注册的实体，在所有的组件中都会有（this.$.实体名）属性</strong></p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">import store from './store'
new Vue({
  render: h =&gt; h(App),
  //注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="async-await使用"><a href="#async-await使用" class="headerlink" title="async await使用"></a>async await使用</h2><p>如果我们没有封装请求api，而是直接调用axios，就不需要使用async await<br>案例：我们将一个axios请求封装为了函数，我们在下面代码中调用了该函数：</p>
<pre class="line-numbers language-none"><code class="language-none">import {reqCateGoryList} from '@/api'
export default {
    actions:{
        categoryList(){
            let result =  reqCateGoryList()
            console.log(result)
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>浏览器结果</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A81.png"></p>
<p>返回了一个promise,证明这是一个promise请求，但是我们想要的是图片中的data数据。<br>没有将函数封装前我们都会通过then()回调函数拿到服务器返回的数据，现在我们将其封装了，依然可以使用then获取数据，代码如下</p>
<pre class="line-numbers language-none"><code class="language-none">actions:{
    categoryList(){
        let result =  reqCateGoryList().then(
            res=&gt;{
              console.log("res")
              console.log(res)
              return res
            }
        )
        console.log("result")
        console.log(result)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A82.png"></p>
<p>由于我们的promis是异步请求，我们发现请求需要花费时间，但是它是异步的，所有后面的console.log(“result”)；console.log(result)会先执行，等我们的请求得到响应后，才执行console.log(“res”)；console.log(res)，这也符合异步的原则，但是我们如果在请求下面啊执行的是将那个请求的结果赋值给某个变量，这样就会导致被赋值的变量先执行，并且赋值为undefine，因为此时promise还没有完成</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A83.png"></p>
<p>所以我们引入了async await,async写在函数名前，await写在api函数前面。await含义是<strong>async标识的函数体内的并且在await标识代码后面的代码</strong>先等待await标识的异步请求执行完，再执行。这也使得只有reqCateGoryList执行完，result 得到返回值后，才会执行后面的输出操作</p>
<pre class="line-numbers language-none"><code class="language-none">async categoryList(){
    let result = await reqCateGoryList()
    console.log("result")
    console.log(result)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>结果</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/asyncawait%E4%BD%BF%E7%94%A84.png"></p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>state、actions、mutations、getters的辅助函数使用，当多次访问store中的上述属性时，要使用4个属性的辅助函数，可以减少代码量<br><strong>在使用上面的函数时，如果需要传递多个参数，需要把多个参数组合为一个对象传入(vuex是不允许多个参数分开传递的)</strong></p>
<pre class="line-numbers language-none"><code class="language-none">async addOrUpdateShopCart({commit},{skuId,skuNum}){
  let result = await reqAddOrUpdateShopCart(skuId,skuNum)
  console.log(result)
  if(result.data === 200){
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/state.html#mapstate-%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0">辅助函数官网链接</a></p>
<p><strong>注意：使用action时，函数的第一个参数，必须是{commit}，即使不涉及到mutations操作，也必须加上该参数，否则会报错</strong></p>
<h2 id="loadsh插件防抖和节流"><a href="#loadsh插件防抖和节流" class="headerlink" title="loadsh插件防抖和节流"></a>loadsh插件防抖和节流</h2><p>在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。<br>安装lodash插件，该插件提供了防抖和节流的函数，我们可以引入js文件，直接调用。当然也可以自己写防抖和节流的函数<br><a target="_blank" rel="noopener" href="https://www.lodashjs.com/">lodash官网</a><br><a target="_blank" rel="noopener" href="https://www.lodashjs.com/docs/lodash.debounce">防抖函数</a><br><a target="_blank" rel="noopener" href="https://www.lodashjs.com/docs/lodash.throttle">节流函数</a><br><strong>防抖：用户操作很频繁，但是只执行一次，减少业务负担。</strong><br><strong>节流：用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码</strong><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c8b86b09daf0">防抖和节流简述</a></p>
<p>例如：下面代码就是将changeIndex设置了节流，如果操作很频繁，限制50ms执行一次。这里函数定义采用的键值对形式。throttle的返回值就是一个函数，所以直接键值对赋值就可以，函数的参数在function中传入即可。</p>
<pre class="line-numbers language-none"><code class="language-none">import {throttle} from 'lodash'
methods: {
  //鼠标进入修改响应元素的背景颜色
  //采用键值对形式创建函数，将changeIndex定义为节流函数，该函数触发很频繁时，设置50ms才会执行一次
  changeIndex: throttle(function (index){
    this.currentIndex = index
  },50),
  //鼠标移除触发时间
  leaveIndex(){
    this.currentIndex = -1
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="编程式导航-事件委托实现路由跳转"><a href="#编程式导航-事件委托实现路由跳转" class="headerlink" title="编程式导航+事件委托实现路由跳转"></a>编程式导航+事件委托实现路由跳转</h2><p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA1.png"></p>
<p>如上图所示，三级标签列表有很多，每一个标签都是一个页面链接，我们要实现通过点击表现进行路由跳转。<br>路由跳转的两种方法：导航式路由，编程式路由</p>
<blockquote>
<p>对于导航式路由，我们有多少个a标签就会生成多少个router-link标签，这样当我们频繁操作时会出现卡顿现象。<br>对于编程式路由，我们是通过触发点击事件实现路由跳转。同理有多少个a标签就会有多少个触发函数。虽然不会出现卡顿，但是也会影响性能。</p>
</blockquote>
<p>上面两种方法无论采用哪一种，都会影响性能。我们提出一种：编程时导航+事件委派 的方式实现路由跳转。事件委派即把子节点的触发事件都委托给父节点。这样只需要一个回调函数goSearch就可以解决。</p>
<p><strong>事件委派问题：</strong></p>
<ol>
<li>如何确定我们点击的一定是a标签呢？如何保证我们只能通过点击a标签才跳转呢？</li>
<li>如何获取子节点标签的商品名称和商品id <strong>(我们是通过商品名称和商品id进行页面跳转的)</strong></li>
</ol>
<p><strong>解决方法：</strong><br>对于问题1：为三个等级的a标签添加自定义属性date-categoryName绑定商品标签名称来标识a标签（其余的标签是没有该属性的）</p>
<p>对于问题2：为三个等级的a标签再添加自定义属性data-category1Id、data-category2Id、data-category3Id来获取三个等级a标签的商品id，用于路由跳转</p>
<p><strong>我们可以通过在函数中传入event参数，获取当前的点击事件，通过event.target属性获取当前点击节点，再通过dataset属性获取节点的属性信息。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex"&gt;
  &lt;div class="item"  v-for="(c1,index) in categoryList" v-show="index!==16" :key="c1.categoryId" :class="{cur:currentIndex===index}"&gt;
    &lt;h3 @mouseenter="changeIndex(index)"&gt;
      &lt;a :data-categoryName="c1.categoryName" :data-category1Id="c1.categoryId" &gt;{{c1.categoryName}}&lt;/a&gt;
    &lt;/h3&gt;
    &lt;div class="item-list clearfix" :style="{display:currentIndex===index?'block':'none'}"&gt;
      &lt;div class="subitem" v-for="(c2,index) in c1.categoryChild" :key="c2.categoryId"&gt;
        &lt;dl class="fore"&gt;
          &lt;dt&gt;
            &lt;a :data-categoryName="c2.categoryName" :data-category2Id="c2.categoryId"&gt;{{c2.categoryName}}&lt;/a&gt;
          &lt;/dt&gt;
          &lt;dd&gt;
            &lt;em v-for="(c3,index) in c2.categoryChild"  :key="c3.categoryId"&gt;
              &lt;a :data-categoryName="c2.categoryName" :data-category3Id="c3.categoryId"&gt;{{c3.categoryName}}&lt;/a&gt;
            &lt;/em&gt;
          &lt;/dd&gt;
        &lt;/dl&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>注意：event是系统属性，所以我们只需要在函数定义的时候作为参数传入，在函数使用的时候不需要传入该参数。</strong></p>
<pre class="line-numbers language-none"><code class="language-none">//函数使用
&lt;div class="all-sort-list2" @click="goSearch" @mouseleave="leaveIndex"&gt;
//函数定义
goSearch(event){
  console.log(event.target)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA2.png"></p>
<p>对应的goSearrch函数</p>
<pre class="line-numbers language-none"><code class="language-none">goSearch(event){
    let element = event.target
    //html中会把大写转为小写
    //获取目前鼠标点击标签的categoryname,category1id,category2id,category3id，
    // 通过四个属性是否存在来判断是否为a标签，以及属于哪一个等级的a标签
    let {categoryname,category1id,category2id,category3id} = element.dataset

    //categoryname存在，表示为a标签
    if(categoryname){
        //category1id一级a标签
        //整理路由跳转的参数
        let location = {name:'Search'}//跳转路由name
        let query = {categoryName:categoryname}//路由参数
        if(category1id){
          query.category1Id = category1id
        }else if(category2id){
        //category2id二级a标签
          query.category2Id = category2id
        }else if(category3id){
        //category3id三级a标签
          query.category3Id = category3id
        }
        //整理完参数
        location.query = query
        //路由跳转
        this.$router.push(location)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Vue路由销毁问题"><a href="#Vue路由销毁问题" class="headerlink" title="Vue路由销毁问题"></a>Vue路由销毁问题</h2><p><strong>Vue在路由切换的时候会销毁旧路由</strong><br>我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据<br>由于<strong>Vue在路由切换的时候会销毁旧路由</strong>，当我们再次使用三级列表全局组件时还会发一次请求。<br>如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/Vue%E8%B7%AF%E7%94%B1%E9%94%80%E6%AF%81%E9%97%AE%E9%A2%98.png"></p>
<p>由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次）<br><strong>注意：</strong>虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性。</p>
<h2 id="mock插件使用"><a href="#mock插件使用" class="headerlink" title="mock插件使用"></a>mock插件使用</h2><p>mock用来拦截前端ajax请求，返回我们自定义的数据用于测试前端接口。<br>将不同的数据类型封装为不同的json文件，创建mockServer.js文件<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/mock%E6%8F%92%E4%BB%B6.png"></p>
<p>banner、floor分别为轮播图和页面底部的假数据。</p>
<pre class="line-numbers language-mockServer.js" data-language="mockServer.js"><code class="language-mockServer.js">import Mock  from 'mockjs'
//webpack默认对外暴露：json、图片
import banner from './banner.json'
import floor from './floor.json'

//mock数据：第一个参数请求地址、第二个参：请求数据
Mock.mock("/mock/banner",{code:200,data:banner})
Mock.mock("/mock/floor",{code:200,data:floor})
//记得要在main.js中引入一下
import ''@/mock/mockServer<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="vuex数据存储与使用"><a href="#vuex数据存储与使用" class="headerlink" title="vuex数据存储与使用"></a>vuex数据存储与使用</h2><p>我们会把公共的数据放在store中，然后使用时再去store中取。<br>以我们的首页轮播图数据为例。</p>
<ol>
<li>在轮播图组件ListContainer.vue组件加载完毕后发起轮播图数据请求。<pre class="line-numbers language-none"><code class="language-none">mounted() {
  this.$store.dispatch("getBannerList")
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li>请求实际是在store中的actions中完成的<pre class="line-numbers language-none"><code class="language-none">actions:{
    //获取首页轮播图数据
    async getBannerList({commit}){
        let result = await reqGetBannerList()
        if(result.code ===  200){
            commit("BANNERLIST",result.data)
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>获取到数据后存入store仓库，在mutations完成<pre class="line-numbers language-none"><code class="language-none">//唯一修改state的部分
mutations:{
    BANNERLIST(state,bannerList){
        state.bannerList = bannerList
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li>轮播图组件ListContainer.vue组件在store中获取轮播图数据。由于在这个数据是通过异步请求获得的，所以我们要通过计算属性computed获取轮播图数据<pre class="line-numbers language-ListContainer.vue" data-language="ListContainer.vue"><code class="language-ListContainer.vue">&lt;script&gt;
  import {mapState} from "vuex";
  export default {
    name: "index",
    //主键挂载完毕，请求轮播图图片
    mounted() {
      this.$store.dispatch("getBannerList")
    },
    computed:{
      ...mapState({
        bannerList: (state =&gt; state.home.bannerList)
      })
    }
  }
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<p><strong>总结：</strong> 只要是公共数据都会放在store中，之后的实现步骤就是上面的固定步骤。</p>
<h2 id="swiper插件实现轮播图"><a href="#swiper插件实现轮播图" class="headerlink" title="swiper插件实现轮播图"></a>swiper插件实现轮播图</h2><p><a target="_blank" rel="noopener" href="https://www.swiper.com.cn/usage/index.html">swiper官网</a></p>
<p>官网中给出了代码实例：做一个简要总结</p>
<blockquote>
<ol>
<li>安装swiper</li>
<li>在需要使用轮播图的组件内导入swpier和它的css样式</li>
<li>在组件中创建swiper需要的dom标签（html代码，参考官网代码）</li>
<li>创建swiper实例</li>
</ol>
</blockquote>
<p><strong>注意：</strong> 在创建swiper对象时，我们会传递一个参数用于获取展示轮播图的DOM元素，官网直接通过class <strong>（而且这个class不能修改，是swiper的css文件自带的）</strong> 获取。但是这样有缺点：当页面中有多个轮播图时，因为它们使用了相同的class修饰的DOM，就会出现所有的swiper使用同样的数据，这肯定不是我们希望看到的。</p>
<p>解决方法：在轮播图最外层DOM中添加ref属性<br><code>&lt;div class="swiper-container" id="mySwiper" ref="cur"&gt;</code></p>
<p>通过ref属性值获取DOM</p>
<p><code>let mySwiper = new Swiper(this.$refs.cur,{...})</code></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;!--banner轮播--&gt;
  &lt;div class="swiper-container" id="mySwiper" ref="cur"&gt;
    &lt;div class="swiper-wrapper"&gt;
      &lt;div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id"&gt;
        &lt;img :src="carouse.imgUrl" /&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 如果需要分页器 --&gt;
    &lt;div class="swiper-pagination"&gt;&lt;/div&gt;
    &lt;!-- 如果需要导航按钮 --&gt;
    &lt;div class="swiper-button-prev" &gt;&lt;/div&gt;
    &lt;div class="swiper-button-next"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;script&gt;
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>接下来要考虑的是什么时候去加载这个swiper，我们第一时间想到的是在mounted中创建这个实例，但是会出现无法加载轮播图片的问题。</p>
<p><strong>原因：</strong></p>
<blockquote>
<p>我们在mounted中先去异步请求了轮播图数据，然后又创建的swiper实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">mounted() {
//请求数据
    this.$store.dispatch("getBannerList")
    //创建swiper实例
    let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
    })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方法一：等我们的数据请求完毕后再创建swiper实例。只需要加一个1000ms时间延迟再创建swiper实例.。将上面代码改为：</p>
<pre class="line-numbers language-none"><code class="language-none">mounted() {
    this.$store.dispatch("getBannerList")
    setTimeout(()=&gt;{
      let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
        pagination:{
          el: '.swiper-pagination',
          clickable: true,
        },
        // 如果需要前进后退按钮
        navigation: {
          nextEl: '.swiper-button-next',
          prevEl: '.swiper-button-prev',
        },
        // 如果需要滚动条
        scrollbar: {
          el: '.swiper-scrollbar',
        },
      })
    },1000)
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方法一肯定不是最好的，但是我们开发的第一要义就是实现功能，之后再完善。</p>
<p>解决方法二：我们可以使用watch监听bannerList轮播图列表属性，因为bannerList初始值为空，当它有数据时，我们就可以创建swiper对象</p>
<pre class="line-numbers language-none"><code class="language-none">watch:{
    bannerList(newValue,oldValue){
        let mySwiper = new Swiper(this.$refs.cur,{
          pagination:{
            el: '.swiper-pagination',
            clickable: true,
          },
          // 如果需要前进后退按钮
          navigation: {
            nextEl: '.swiper-button-next',
            prevEl: '.swiper-button-prev',
          },
          // 如果需要滚动条
          scrollbar: {
            el: '.swiper-scrollbar',
          },
        })
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即使这样也还是无法实现轮播图，原因是，我们轮播图的html中有v-for的循环，我们是通过v-for遍历bannerList中的图片数据，然后展示。我们的watch只能保证在bannerList变化时创建swiper对象，但是并不能保证此时v-for已经执行完了。假如watch先监听到bannerList数据变化，执行回调函数创建了swiper对象，之后v-for才执行，这样也是无法渲染轮播图图片 <strong>（因为swiper对象生效的前提是html即dom结构已经渲染好了）</strong></p>
<p><strong>完美解决方案：</strong> 使用watch+<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#vm-nextTick">this.$nextTick()</a><br>官方介绍：this. $nextTick它会将回调延迟到下次 DOM <strong>更新循环之后执行</strong>（循环就是这里的v-for）<br><strong>个人理解：</strong> 无非是等我们页面中的结构都有了再去执行回调函数</p>
<p>完整代码</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;
  &lt;!--列表--&gt;
  &lt;div class="list-container"&gt;
    &lt;div class="sortList clearfix"&gt;
      &lt;div class="center"&gt;
        &lt;!--banner轮播--&gt;
        &lt;div class="swiper-container" id="mySwiper"&gt;

          &lt;div class="swiper-wrapper"&gt;
            &lt;div class="swiper-slide" v-for="(carouse,index) in bannerList" :key="carouse.id"&gt;
              &lt;img :src="carouse.imgUrl" /&gt;
            &lt;/div&gt;
          &lt;/div&gt;

          &lt;!-- 如果需要分页器 --&gt;
          &lt;div class="swiper-pagination"&gt;&lt;/div&gt;

          &lt;!-- 如果需要导航按钮 --&gt;
          &lt;div class="swiper-button-prev" &gt;&lt;/div&gt;
          &lt;div class="swiper-button-next"&gt;&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
//引入Swiper
import Swiper from 'swiper'
//引入Swiper样式
import 'swiper/css/swiper.css'
import {mapState} from "vuex";
export default {
  name: "index",
  //主键挂载完毕，ajax请求轮播图图片
  mounted() {
    this.$store.dispatch("getBannerList")
  },
  computed:{
    ...mapState({
    //从仓库中获取轮播图数据
      bannerList: (state) =&gt; {return state.home.bannerList}
    })
  },
  watch:{
    bannerList(newValue,oldValue){
        //this.$nextTick()使用
        this.$nextTick(()=&gt;{
          let mySwiper = new Swiper(document.getElementsByClassName("swiper-container"),{
            pagination:{
              el: '.swiper-pagination',
              clickable: true,
            },
            // 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },
            // 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })
        })
    }
  }
}
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意：</strong> 之前我们在学习watch时，一般都是监听的定义在data中的属性，但是我们这里是监听的computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。</p>
<h2 id="将轮播图模块提取为全局组件"><a href="#将轮播图模块提取为全局组件" class="headerlink" title="将轮播图模块提取为全局组件"></a>将轮播图模块提取为全局组件</h2><p>需要注意的是我们要把定义swiper对象放在watch中执行，并且还要设置immediate：true属性，这样可以实现，无论数据有没有变化，上来立即监听一次。</p>
<p>全局组件Carousel代码</p>
<pre class="line-numbers language-Carousel.vue" data-language="Carousel.vue"><code class="language-Carousel.vue">&lt;template&gt;
  &lt;div class="swiper-container" ref="cur" id="floor1Swiper"&gt;
    &lt;div class="swiper-wrapper"&gt;
      &lt;div class="swiper-slide" v-for="(carouse,index) in carouselList" :key="carouse.id"&gt;
        &lt;img :src="carouse.imgUrl"&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;!-- 如果需要分页器 --&gt;
    &lt;div class="swiper-pagination"&gt;&lt;/div&gt;

    &lt;!-- 如果需要导航按钮 --&gt;
    &lt;div class="swiper-button-prev"&gt;&lt;/div&gt;
    &lt;div class="swiper-button-next"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Swiper from "swiper";
export default {
  name: "Carousel",
  props:["carouselList"],
  watch: {
    carouselList: {
      //这里监听，无论数据有没有变化，上来立即监听一次
      immediate: true,
      //监听后执行的函数
      handler(){
        //第一次ListContainer中的轮播图Swiper定义是采用watch+ this.$nextTick()实现

        this.$nextTick(() =&gt; {
          let mySwiper = new Swiper(this.$refs.cur,{
            loop: true, // 循环模式选项

            // 如果需要分页器
            pagination: {
              el: '.swiper-pagination',
              // clickable: true
            },

            // 如果需要前进后退按钮
            navigation: {
              nextEl: '.swiper-button-next',
              prevEl: '.swiper-button-prev',
            },

            // 如果需要滚动条
            scrollbar: {
              el: '.swiper-scrollbar',
            },
          })
        })
      }
    }
  }
}
&lt;/script&gt;

&lt;style scoped&gt;

&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在main.js中注册全局组件并引入swiper的css样式文件</p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">// 注册轮播图组件
import Carousel from '@/components/Carousel'
Vue.component(Carousel.name,Carousel)
// 引入swiper样式
import 'swiper/css/swiper.css'<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在其它组件中使用轮播图模块：<code>&lt;Carousel :carouselList="list.carouselList"/&gt;</code></p>
<h2 id="getters使用"><a href="#getters使用" class="headerlink" title="getters使用"></a>getters使用</h2><p><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/getters.html#%E9%80%9A%E8%BF%87%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE">getters使用</a><br>如果不使用getters属性，我们在组件获取state中的数据表达式为：<strong>this.$store.state.子模块.属性</strong><br>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><strong>注意：</strong> 仓库中的getters是全局属性，是不分模块的。即store中所有模块的getter内的函数都可以通过 <strong>$store.getters.函数名</strong> 获取</p>
<p>下图为store内容<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/getters%E4%BD%BF%E7%94%A8.png"></p>
<p>我们在Search模块中获取商品列表数据就是通过getters实现，<strong>需要注意的是当网络出现故障时应该将返回值设置为空，如果不设置返回值就变成了undefined</strong></p>
<p>store中search模块代码</p>
<pre class="line-numbers language-none"><code class="language-none">import {reqGetSearchInfo} from '@/api';
const state = {
    searchList:{},
}
const mutations = {
    SEARCHLIST(state,searchList){
        state.searchList = searchList
    }
}
const actions = {
    //第二个参数data默认是一个空对象
    async getSearchListr({commit},data={}){
        let result = await reqGetSearchInfo(data)

        if(result.code === 200){
            commit("SEARCHLIST",result.data)
        }
    }
}
const getters = {
    goodsList(state){
        //网络出现故障时应该将返回值设置为空
        return state.searchList.goodsList||[]
    }
}
export default {
    state,
    mutations,
    actions,
    getters,
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>在Search组件中使用getters获取仓库数据</p>
<pre class="line-numbers language-none"><code class="language-none">//只展示了使用getters的代码
&lt;script&gt;
  //引入mapGetters
  import {mapGetters} from 'vuex'
  export default {
    name: 'Search',
    computed:{
      //使用mapGetters，参数是一个数组，数组的元素对应getters中的函数名
      ...mapGetters(['goodsList'])
    }
  }
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="Object-asign实现对象拷贝"><a href="#Object-asign实现对象拷贝" class="headerlink" title="Object.asign实现对象拷贝"></a>Object.asign实现对象拷贝</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/f9ec860ecd81">参考链接</a></p>
<pre class="line-numbers language-none"><code class="language-none">Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
Object.assign(target, ...sources)    【target：目标对象】，【souce：源对象（可多个）】
举个栗子：
const object1 = {
  a: 1,
  b: 2,
  c: 3
};

const object2 = Object.assign({c: 4, d: 5}, object1);

console.log(object2.c, object2.d);
console.log(object1)  // { a: 1, b: 2, c: 3 }
console.log(object2)  // { c: 3, d: 5, a: 1, b: 2 }

注意：
1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性
2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标
对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如
果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到
原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="对象深拷贝"><a href="#对象深拷贝" class="headerlink" title="对象深拷贝"></a>对象深拷贝</h2><pre class="line-numbers language-none"><code class="language-none">针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。
let obj1 = { a: 0 , b: { c: 0}}; 
let obj2 = Object.assign({}, obj1); 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj1.a = 1; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} 

obj2.a = 2; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}}
 
obj2.b.c = 3; 
console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}} 
console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}} 
最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响

// Deep Clone （深拷贝）
obj1 = { a: 0 , b: { c: 0}}; 
let obj3 = JSON.parse(JSON.stringify(obj1)); 
obj1.a = 4; 
obj1.b.c = 4; 
console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="利用路由信息变化实现动态搜索"><a href="#利用路由信息变化实现动态搜索" class="headerlink" title="利用路由信息变化实现动态搜索"></a>利用路由信息变化实现动态搜索</h2><p><strong>最佳方法：</strong> 我们每次进行新的搜索时，我们的query和params参数中的部分内容肯定会改变，而且这两个参数是路由的属性。我们可以通过监听路由信息的变化来动态发起搜索请求</p>
<p>如下图所示，$route是组件的属性，所以watch是可以监听的（watch可以监听组件data中所有的属性）<br><strong>注意：</strong> 组件中data的属性包括：自己定义的、系统自带的（如 $route）、父组件向子组件传递的等等</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%88%A9%E7%94%A8%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8F%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%90%9C%E7%B4%A21.png"></p>
<pre class="line-numbers language-search.vue" data-language="search.vue"><code class="language-search.vue">watch: {
    //监听路由的信息是否发生变化，如果发生变化，再次发起请求
    $route(newValue, oldValue) {
      //每一次请求完毕，应该把相应的1、2、3级分类的id置空的，让他接受下一次的相应1、2、3
      //分类名字与关键字不用清理：因为每一次路由发生变化的时候，都会给他赋予新的数据
      this.searchParams.category1Id = undefined;
      this.searchParams.category2Id = undefined;
      this.searchParams.category3Id = undefined;
      //再次发请求之前整理带给服务器参数
      Object.assign(this.searchParams, this.$route.query, this.$route.params);
      //再次发起ajax请求
      this.getData();
    },
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="面包屑相关操作"><a href="#面包屑相关操作" class="headerlink" title="面包屑相关操作"></a>面包屑相关操作</h2><p>本次项目的面包屑操作主要就是两个删除逻辑。</p>
<ul>
<li>当分类属性（query）删除时删除面包屑同时修改路由信息。</li>
<li>当搜索关键字（params）删除时删除面包屑、修改路由信息、同时删除输入框内的关键字。</li>
</ul>
<ol>
<li><p>query删除时<br>因为此部分在面包屑中是通过categoryName展示的，所以删除时应将该属性值制空或undefined。<br>可以通过路由再次跳转修改路由信息和url链接</p>
<pre class="line-numbers language-none"><code class="language-none">//删除分类
removeBread(){
  this.searchParams.categoryName = undefined
  this.$router.push({name:'Search',params:this.$route.params})
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>params删除时<br>和query删除的唯一不同点是此部分会多一步操作：删除输入框内的关键字（因为params参数是从输入框内获取的）<br>输入框是在Header组件中的<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E9%9D%A2%E5%8C%85%E5%B1%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C1.png"></p>
</li>
</ol>
<p>header和search组件是兄弟组件，要实现该操作就要通过兄弟组件之间进行通信完成。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E9%9D%A2%E5%8C%85%E5%B1%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C2.png"></p>
<p>这里通过$bus实现header和search组件的通信</p>
<ol>
<li><p>在main.js中注册</p>
<pre class="line-numbers language-none"><code class="language-none">new Vue({
  //全局事件总线$bus配置
  beforeCreate() {
    //此处的this就是这个new Vue()对象
    //网络有很多bus通信总结，原理相同，换汤不换药
    Vue.prototype.$bus = this
  },
  render: h =&gt; h(App),
  //router2、注册路由，此时组件中都会拥有$router $route属性
  router,
  //注册store,此时组件中都会拥有$store
  store
}).$mount('#app')<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>search组件使用$bus通信，第一个参数可以理解为为通信的暗号，还可以有第二个参数（用于传递数据），我们这里只是用于通知header组件进行相应操作，所以没有设置第二个参数</p>
<pre class="line-numbers language-none"><code class="language-none">//删除搜索关键字
removeBreadParams(){
    this.searchParams.keyword = undefined
    //通知兄弟组件header删除输入框的keyword关键字
    this.$bus.$emit("clear")
    this.$router.push({name:'Search',query:this.$route.query})
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>header组件接受$bus通信，注意：组件挂载时就监听clear事件</p>
<pre class="line-numbers language-none"><code class="language-none">mounted() {
  //  组件挂载时就监听clear事件，clear事件在search模块中定义
  //  当删除关键字面包屑时，触发该事件，同时header的输入框绑定的keyword要删除
    this.$bus.$on("clear",()=&gt;{
      this.keyword = ''
    })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</li>
</ol>
<h2 id="SearchSelector子组件传参及面包屑操作"><a href="#SearchSelector子组件传参及面包屑操作" class="headerlink" title="SearchSelector子组件传参及面包屑操作"></a>SearchSelector子组件传参及面包屑操作</h2><p>SearchSelector组件有两个属性也会生成面包屑，分别为品牌名、手机属性。<br>如下图所示<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/SearchSelector%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E5%8F%8A%E9%9D%A2%E5%8C%85%E5%B1%91%E6%93%8D%E4%BD%9C.png"></p>
<p>此处生成面包屑时会涉及到子组件向父组件传递信息操作，之后的操作面包屑操作原理相同。唯一的区别是，这里删除面包屑时不需要修改地址栏url，因为url是由路由地址确定的，并且只有query、params两个参数变化回影响路由地址变化。</p>
<p>总结：面包屑由四个属性影响：parads、query、品牌、手机属性<br>面包屑生成逻辑<br>判断searchParams相关属性是否存在，存在即显示<br>面包屑删除逻辑</p>
<pre class="line-numbers language-Search.vue" data-language="Search.vue"><code class="language-Search.vue">&lt;script&gt;
  import SearchSelector from './SearchSelector/SearchSelector'
  import {mapGetters} from 'vuex'
  export default {
    name: 'Search',
    components: {
      SearchSelector
    },
    data(){
      return{
        //动态获取searchParams
        searchParams:{
          category1Id: "",//一级分类id
          category2Id: "",//二级分类id
          category3Id: "",//三级分类id
          categoryName: "",
          keyword: "",
          order: "1:desc",
          pageNo: 1,
          pageSize: 10,
          props: [],//平台售卖属性
          trademark: ""//品牌
        },
      }
    },
    //在组件挂在之前动态编辑searchParams的值，因为组件挂在之后会使用到searchParams
    beforeMount() {
      //Object.assign方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
      //Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象
      Object.assign(this.searchParams,this.$route.query,this.$route.params)
    },
    methods:{
      //搜索
      searchInfo(){
        this.$store.dispatch("getSearchListr",this.searchParams)
      },
      //删除分类(query)面包屑
      removeBread(){
        this.searchParams.categoryName = undefined
        this.$router.push({name:'Search',params:this.$route.params})
      },
      //删除搜索关键字(params)面包屑
      removeBreadParams(){
        this.searchParams.keyword = undefined
        //通知兄弟组件header删除输入框的keyword关键字
        this.$bus.$emit("clear")
        this.$router.push({name:'Search',query:this.$route.query})
      },
      //获取子组件传递的品牌信息（自定义事件）
      tradeMarkInfo(tradeMark){
        //接口文档中trademark的信息是"ID:品牌名称"形式
        this.searchParams.trademark = `${tradeMark.tmId}:${tradeMark.tmName}`
        this.searchInfo()
      },
      //删除品牌面包屑
      removeTradeMark(){
        this.searchParams.trademark = undefined
        this.searchInfo()
      },
      //获取子组件传递的属性信息（自定义事件）
      attrInfo(attr,attrValue){
        //searchParams.props元素为字符串形式，api文档有介绍
        let props = `${attr.attrId}:${attrValue}:${attr.attrName}`
        //数组去重
        if(this.searchParams.props.indexOf(props)===-1){
          this.searchParams.props.push(props)
          this.searchInfo()
        }
      },
      //删除属性面包屑
      removeAttr(index){
        this.searchParams.props.splice(index,1)
      }
    },
    mounted() {
      this.searchInfo()
    },
    computed:{
      ...mapGetters(['goodsList'])
    },
    //watch可以监听组件上的属性
    watch:{
      $route:{
        handler(newValue,oldValue){
          console.log(this.$route)
          Object.assign(this.searchParams,this.$route.query,this.$route.params)
          this.searchInfo()
          //如果下一次搜索时只有params参数，拷贝后会发现searchParams会保留上一次的query参数
          //所以每次请求结束后将相应参数制空
          this.searchParams.category1Id = undefind;
          this.searchParams.category2Id = undefind;
          this.searchParams.category3Id = undefind;
        },
      }
    },
  }
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="商品排序"><a href="#商品排序" class="headerlink" title="商品排序"></a>商品排序</h2><p>排序的逻辑比较简单，只是改变一下请求参数中的order字段，后端会根据order值返回不同的数据来实现升降序<br>order属性值为字符串，例如‘1：asc’、‘2：desc’。1代表综合，2代表价格，asc代表升序，desc代表降序<br>我们的升降序是通过箭头图标来辨别的，如图所示：<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F1.png"></p>
<p>图标是iconfont网站的图标，通过引入在线css的方式引入图标<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F2.png"></p>
<p>在public文件index引入该css<br><code>&lt;link rel="stylesheet" href="https://at.alicdn.com/t/font_2994457_qqwrvmss9l9.css"&gt;</code></p>
<p>在search模块使用该图标</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;div class="sui-navbar"&gt;
    &lt;div class="navbar-inner filter"&gt;
      &lt;ul class="sui-nav"&gt;
        &lt;!-- 这里isOne、isTwo、isAsc、isDesc是计算属性，如果不使用计算属性要在页面中写很长的代码--&gt;
        &lt;li :class="{active:isOne}" @click="changeOrder('1')"&gt;
          &lt;!--阿里图标前置类iconfont--&gt;
          &lt;a &gt;综合&lt;span v-show="isOne" class="iconfont" :class="{'icon-up':isAsc,'icon-down':isDesc}"&gt;&lt;/span&gt;&lt;/a&gt;
        &lt;/li&gt;
        &lt;li :class={active:isTwo} @click="changeOrder('2')"&gt;
          &lt;a &gt;价格&lt;span v-show="isTwo" class="iconfont" :class="{'icon-up':isAsc,'icon-down':isDesc}"&gt;&lt;/span&gt;&lt;/a&gt;
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>isOne、isTwo、isAsc、isDesc计算属性代码</p>
<pre class="line-numbers language-none"><code class="language-none">computed:{
    ...mapGetters(['goodsList']),
    isOne(){
      return this.searchParams.order.indexOf('1')!==-1
    },
    isTwo(){
      return this.searchParams.order.indexOf('2')!==-1
    },
    isDesc(){
      return this.searchParams.order.indexOf('desc')!==-1
    },
    isAsc(){
      return this.searchParams.order.indexOf('asc')!==-1
    },
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>点击‘综合’或‘价格’的触发函数changeOrder</p>
<pre class="line-numbers language-none"><code class="language-none">//flag用于区分综合、价格，1：综合，2：价格
changeOrder(flag){
    let newSearchOrder = this.searchParams.order
    //将order拆为两个字段orderFlag(1:2)、order(asc:desc)
    let orderFlag = this.searchParams.order.split(':')[0]
    let order = this.searchParams.order.split(':')[1]
    //由综合到价格、由价格到综合
    if(orderFlag!==flag){
      //点击的不是同一个按钮
      newSearchOrder = `${flag}:desc`
      this.searchInfo()
    }else{
      //多次点击的是不是同一个按钮
      newSearchOrder = `${flag}:${order==='desc'?'asc':'desc'}`
    }
    //需要给order重新赋值
    this.searchParams.order = newSearchOrder;
    //再次发请求
    this.searchInfo();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="手写分页器"><a href="#手写分页器" class="headerlink" title="手写分页器"></a>手写分页器</h2><p>实际开发中是不会手写的，一般都会用一些开源库封装好的分页，比如element ui。但是这个知识还是值得学习一下的。<br>核心属性：<br>pageNo（当前页码）、pageSize（每一页展示条数）、total（一共多少条数据）、continues（连续展示的页码）<br>核心逻辑是获取连续页码的起始页码和末尾页码，通过计算属性获得。（计算属性如果想返回多个数值，可以通过对象形式返回）</p>
<pre class="line-numbers language-none"><code class="language-none">//连续页码的起始页码、末尾页码
startNumAndEnd(){
    let start = 0 , end = 0;
    //规定连续页码数字5（totalPage至少5页）
    //不正常现象
    if(this.continues &gt; this.totalPage){
      start = 1
      end = this.totalPage
    }else{
      //正常现象      Math.floor:想下取整
      start = this.pageNo - Math.floor(this.continues/2)
      end = this.pageNo + Math.floor(this.continues/2)
      //start出现不正常现象纠正
      if(start &lt; 1){
          start = 1
          end = this.continues
      }
      //end出现不正常现象纠正
      if(end &gt; this.totalPage){
          end = this.totalPage
          start = this.totalPage - this.continues + 1
      }
    }
    return {start,end}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当点击页码会将pageNo传递给父组件，然后父组件发起请求，最后渲染。这里还是应用通过自定义事件实现子组件向父组件传递信息</p>
<h2 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h2><p><code>&lt;router-link :to="`/detail/${goods.id}`"&gt;&lt;/router-link&gt;</code></p>
<h2 id="滚动条"><a href="#滚动条" class="headerlink" title="滚动条"></a>滚动条</h2><p>使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动<br><a target="_blank" rel="noopener" href="https://router.vuejs.org/zh/guide/advanced/scroll-behavior.html">router滚动行为</a></p>
<h2 id="undefined细节"><a href="#undefined细节" class="headerlink" title="undefined细节"></a>undefined细节</h2><p>访问undefined的属性值会引起红色警告，可以不处理，但是要明白警告的原因。<br>以获取商品categoryView信息为例，categoryView是一个对象。<br>对应的getters代码</p>
<pre class="line-numbers language-none"><code class="language-none">const getters =  {
    categoryView(state){
        return state.goodInfo.categoryView
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的computed代码</p>
<pre class="line-numbers language-none"><code class="language-none"> computed:{
    ...mapGetters(['categoryView'])
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>html代码</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;div class="conPoin"&gt;
    &lt;span v-show="categoryView.category1Name" &gt;{{categoryView.category1Name}}&lt;/span&gt;
    &lt;span v-show="categoryView.category2Name" &gt;{{categoryView.category2Name}}&lt;/span&gt;
    &lt;span v-show="categoryView.category3Name" &gt;{{categoryView.category3Name}}&lt;/span&gt;
&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>细节在于getters的返回值。如果getters按上面代码写为return state.goodInfo.categoryView，页面可以正常运行，但是会出现红色警告。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/undefined%E7%BB%86%E8%8A%82.png"></p>
<p><strong>原因：</strong> 假设我们网络故障，导致goodInfo的数据没有请求到，即goodInfo是一个空的对象，当我们去调用getters中的<strong>return state.goodInfo.categoryView</strong>时，因为goodInfo为空，所以也不存在categoryView，即我们getters得到的categoryView为undefined。所以我们在html使用该变量时就会出现没有该属性的报错。<br>即：网络正常时不会出错，一旦无网络或者网络问题就会报错。<br><strong>总结：</strong> 所以我们在写getters的时候要养成一个习惯在返回值后面加一个||条件。即当属性值undefined时，会返回||后面的数据，这样就不会报错。<br>如果返回值为对象加|| {}，数组：|| []。<br>此处categoryView为对象，所以将getters代码改为<strong>return state.goodInfo.categoryView || {}</strong></p>
<h2 id="商品详情"><a href="#商品详情" class="headerlink" title="商品详情"></a>商品详情</h2><p>商品详情唯一难点就是点击轮播图图片时，改变放大镜组件展示的图片。</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85.png"><br>老师的方法很巧妙：在轮播图组件中设置一个currendIndex，用来记录所点击图片的下标，并用currendIndex实现点击图片高亮设置。当符合图片的下标满足currentIndex===index时，该图片就会被标记为选中。</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;div class="swiper-container" ref="cur"&gt;
  &lt;div class="swiper-wrapper"&gt;
    &lt;div class="swiper-slide" v-for="(skuImage,index) in skuImageList" :key="skuImage.id"&gt;
      &lt;img :src="skuImage.imgUrl" :class="{active:currentIndex===index}" @click="changeImg(index)"&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="swiper-button-next"&gt;&lt;/div&gt;
  &lt;div class="swiper-button-prev"&gt;&lt;/div&gt;
&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>轮播图组件和放大镜组件是兄弟组件，所以要通过全局总线通信。<br>在轮播图组件中，点击图片触发全局事件changeImg，参数为图片所在数组的下标。</p>
<pre class="line-numbers language-none"><code class="language-none"> changeImg(index){
    //将点击的图片标识位高亮
    this.currentIndex = index
    //通知兄弟组件修改大图图片
    this.$bus.$emit("changeImg",index)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对应的放大镜组件，首先在mounted监听该全局事件</p>
<pre class="line-numbers language-none"><code class="language-none">mounted() {
    this.$bus.$on("changeImg",(index)=&gt;{
      //修改当前响应式图片
      this.currentIndex = index;
    })
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>放大镜组件中也会有一个currentIndex，他用表示大图中显示的图片的下标（因为放大镜组件只能显示一张图片），全局事件传递的index赋值给currentIndex ，通过computed计算属性改变放大镜组件展示的图片下标</p>
<pre class="line-numbers language-none"><code class="language-none">computed:{
    imgObj(){
        return this.skuImageList[this.currentIndex] || {}
    }
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="放大镜相关知识"><a href="#放大镜相关知识" class="headerlink" title="放大镜相关知识"></a>放大镜相关知识</h3><pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;
  &lt;div class="spec-preview"&gt;
    &lt;img :src="imgObj.imgUrl" /&gt;
    &lt;div class="event" @mousemove="handler"&gt;&lt;/div&gt;
    &lt;div class="big"&gt;
      &lt;img :src="imgObj.imgUrl" ref="big"/&gt;
    &lt;/div&gt;
    &lt;!-- 遮罩层 --&gt;
    &lt;div class="mask" ref="mask"&gt;&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: "Zoom",
  props: ["skuImageList"],
  data() {
    return {
      currentIndex:0
    }
  },
  computed:{
    imgObj(){
      return this.skuImageList[this.currentIndex]||{}
    }
  },
  mounted(){
    //全局事件总线：获取兄弟组件传递过来的索引值
    this.$bus.$on('getIndex',(index)=&gt;{
        //修改当前响应式数据
        this.currentIndex = index;
    })
  },
  methods: {
    handler(event) {
      let mask = this.$refs.mask;
      let big = this.$refs.big;
      let left = event.offsetX - mask.offsetWidth/2;
      let top = event.offsetY - mask.offsetHeight/2;
      //约束范围
      if(left &lt;=0) left = 0;
      if(left &gt;=mask.offsetWidth) left = mask.offsetWidth;
      if(top&lt;=0)top = 0;
      if(top&gt;=mask.offsetHeight) top = mask.offsetHeight;
      //修改元素的left|top属性值
      mask.style.left = left+'px';
      mask.style.top = top +'px';
      big.style.left = - 2 * left+'px';
      big.style.top = -2 * top +'px';
    },
  },

};
&lt;/script&gt;

&lt;style lang="less"&gt;
.spec-preview {
  position: relative;
  width: 400px;
  height: 400px;
  border: 1px solid #ccc;
  img {
    width: 100%;
    height: 100%;
  }
  .event {
    width: 100%;
    height: 100%;
    position: absolute;
    top: 0;
    left: 0;
    z-index: 998;
  }
  .mask {
    width: 50%;
    height: 50%;
    background-color: rgba(0, 255, 0, 0.3);
    position: absolute;
    left: 0;
    top: 0;
    display: none;
  }
  .big {
    width: 100%;
    height: 100%;
    position: absolute;
    top: -1px;
    left: 100%;
    border: 1px solid #aaa;
    overflow: hidden;
    z-index: 998;
    display: none;
    background: white;
    img {
      width: 200%;
      max-width: 200%;
      height: 200%;
      position: absolute;
      left: 0;
      top: 0;
    }
  }
  .event:hover ~ .mask,
  .event:hover ~ .big {
    display: block;
  }
}
&lt;/style&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="失焦事件"><a href="#失焦事件" class="headerlink" title="失焦事件"></a>失焦事件</h2><p>blur与change事件在绝大部分情况下表现都非常相似，输入结束后，离开输入框，会先后触发change与blur，唯有两点例外。</p>
<p><strong>1. 没有进行任何输入时，不会触发change。</strong><br>在这种情况下，输入框并不会触发change事件，但一定会触发blur事件。在判断表单修改状态时，这种差异会非常有用，通过change事件能轻易地找到哪些字段发生了变更以及其值的变更轨迹。</p>
<p><strong>2. 输入后值并没有发生变更。</strong><br>这种情况是指，在没有失焦的情况下，在输入框内进行返回的删除与输入操作，但最终的值与原值一样，这种情况下，keydown、input、keyup、blur都会触发，但change依旧不会触发。</p>
<h2 id="加入购物车成功路由"><a href="#加入购物车成功路由" class="headerlink" title="加入购物车成功路由"></a>加入购物车成功路由</h2><p>点击加入购物车时，会向后端发送API请求，但是该请求的返回值中data为null，所以我们只需要根据状态码code判断是否跳转到‘加入购物车成功页面’。</p>
<p>detail组件‘加入购物车’请求函数：</p>
<pre class="line-numbers language-none"><code class="language-none">async addShopCar() {
    try{
      await this.$store.dispatch("addOrUpdateShopCart", {
        skuId: this.$route.params.skuId,
        skuNum: this.skuNum
      });
      //一些简单的数据，比如skuNum通过query传过去
      //复杂的数据通过session存储，
      //sessionStorage、localStorage只能存储字符串        sessionStorage.setItem("SKUINFO",JSON.stringify(this.skuInfo))
      this.$router.push({name:'AddCartSuccess',query:{'skuNum':this.skuNum}})
    }catch (error){
      alert(error.message)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>detail store对应代码</p>
<pre class="line-numbers language-none"><code class="language-none">//将产品添加到购物车中
async addOrUpdateShopCart({commit},{skuId,skuNum}){
    let result = await reqAddOrUpdateShopCart(skuId,skuNum)
    if(result.code === 200){
        return 'ok'
    }else{
        return Promise.reject(new Error('faile'))
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<blockquote>
<p>跳转‘加入购物车成功页面’的同时要携带商品的信息。本项目只是传递的商品的一些标签属性，并没有传递商品的型号类别的信息，比如颜色、内存等信息，自己可以手动实现，比较简单。</p>
</blockquote>
<p>当我们想要实现<strong>两个毫无关系</strong>的组件传递数据时，首相想到的就是路由的query传递参数，但是query适合传递单个数值的简单参数，所以如果想要<strong>传递对象</strong>之类的复杂信息，就可以通过<strong>Web Storage</strong>实现。</p>
<p><strong>sessionStorage、localStorage概念：</strong><br><strong>sessionStorage：</strong> 为每一个给定的源维持一个独立的存储区域，该区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。<br><strong>localStorage：</strong> 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。<br><strong>注意：</strong> 无论是session还是local存储的值都是字符串形式。如果我们想要存储对象，需要在存储前JSON.stringify()将对象转为字符串，在取数据后通过JSON.parse()将字符串转为对象。</p>
<h2 id="购物车组件开发"><a href="#购物车组件开发" class="headerlink" title="购物车组件开发"></a>购物车组件开发</h2><p>根据api接口文档封装请求函数</p>
<pre class="line-numbers language-none"><code class="language-none">export const reqGetCartList = () =&gt; {
return requests({
	url:'/cart/cartList',
	method:'GET'
})}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>但是如果想要获取详细信息，还需要一个用户的uuidToken，用来验证用户身份。但是该请求函数没有参数，所以我们只能把uuidToken加在请求头中</p>
<p>创建utils工具包文件夹，创建生成uuid的js文件，对外暴露为函数（记得导入uuid =&gt; npm install uuid）<br><strong>生成临时游客的uuid（随机字符串）,每个用户的uuid不能发生变化，还要持久存储</strong></p>
<pre class="line-numbers language-none"><code class="language-none">import {v4 as uuidv4} from 'uuid'
//生成临时游客的uuid（随机字符串）,每个用户的uuid不能发生变化，还要持久存储
export const getUUID = () =&gt; {
    //1、判断本地存储是否由uuid
    let uuid_token = localStorage.getItem('UUIDTOKEN')
    //2、本地存储没有uuid
    if(!uuid_token){
        //2.1生成uuid
        uuid_token = uuidv4()
        //2.2存储本地
        localStorage.setItem("UUIDTOKEN",uuid_token)
    }
    //当用户有uuid时就不会再生成
    return uuid_token
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用户的uuid_token定义在store中的detail模块</p>
<pre class="line-numbers language-none"><code class="language-none">const state =  {
    goodInfo:{},
    //游客身份
    uuid_token: getUUID()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在request.js中设置请求头</p>
<pre class="line-numbers language-none"><code class="language-none">import store from '@/store';
requests.interceptors.request.use(config =&gt; {
    //config内主要是对请求头Header配置
    //比如添加token
    //1、先判断uuid_token是否为空
    if(store.state.detail.uuid_token){
        //2、userTempId字段和后端统一
        config.headers['userTempId'] = store.state.detail.uuid_token
    }
    //开启进度条
    nprogress.start();
    return config;
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意：</strong> this.$store只能在组件中使用，不能在js文件中使用。如果要在js中使用，需要引入import store from ‘@/store’;</p>
<h2 id="购物车商品数量"><a href="#购物车商品数量" class="headerlink" title="购物车商品数量"></a>购物车商品数量</h2><p><strong>1. 购物车商品信息展示比较简单，就不多做赘述。</strong><br><strong>2. every函数使用</strong></p>
<blockquote>
<p>every遍历某个数组，判断数组中的元素是否满足表达式，全部为满足返回true，否则返回false</p>
</blockquote>
<p>例如判断底部勾选框是否全部勾选代码部分</p>
<pre class="line-numbers language-none"><code class="language-none">//判断底部勾选框是否全部勾选
isAllCheck() {
  //every遍历某个数组，判断数组中的元素是否满足表达式，全部为满足返回true，否则返回false
  return this.cartInfoList.every(item =&gt; item.isChecked === 1)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>3. 修改商品数量前端代码部分：</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;li class="cart-list-con5"&gt;
    &lt;a href="javascript:void(0)" class="mins" @click="handler('minus',-1,cartInfo)"&gt;-&lt;/a&gt;
    &lt;input autocomplete="off" type="text" :value="cartInfo.skuNum" @change="handler('change',$event.target.value,cartInfo)" minnum="1" class="itxt"&gt;
    &lt;a href="javascript:void(0)" class="plus" @click="handler('add',1,cartInfo)"&gt;+&lt;/a&gt;
&lt;/li&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>handler函数，修改商品数量时，加入<strong>节流</strong>操作</p>
<blockquote>
<p>添加到购物车和对已有物品进行数量改动使用的同一个api，可以查看api文档。<br>handler函数有三个参数，type区分操作，disNum用于表示数量变化（正负）,cart商品的信息</p>
</blockquote>
<pre class="line-numbers language-none"><code class="language-none">//加入节流操作
handler: throttle(async  function(type,disNum,cart){
  //减按钮判断当前数量是否为1
  if(type === 'minus') {
      //当商品数量为1是，不可以再减少
      if(cart.skuNum === 1){
          return;
      }
  }
  //输入框修改,难点：要判断输入的内容是否合法
  if(type === 'change'){
      //输入内容不合法时
      if(isNaN(disNum * 1)  || disNum &lt;= 0){
        disNum = 0;
      }else{
        disNum = parseInt(disNum) - cart.skuNum
      }
  }
  //加按钮disNum不需要改变
  try{
      await this.$store.dispatch('addOrUpdateShopCart',{skuId:cart.skuId,skuNum:disNum})
  //商品数量修改成功后再次获取服务器数据
      await this.$store.dispatch("getCartList")
  }catch (error){
      alert(error)
  }
},100),<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="购物车状态修改和商品删除"><a href="#购物车状态修改和商品删除" class="headerlink" title="购物车状态修改和商品删除"></a>购物车状态修改和商品删除</h2><p>action部分：以删除购物车某个商品数据为例</p>
<pre class="line-numbers language-none"><code class="language-none">//修改购物车某一个产品的选中状态
async reqUpdateCheckedById({commit},{skuId,isChecked}){
    let result = await reqUpdateCheckedById(skuId,isChecked)
    if(result.code === 200){
        return 'ok'
    }else{
        return Promise.reject(new Error('fail'))
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>method部分：（重点是try、catch）</p>
<pre class="line-numbers language-none"><code class="language-none">// 修改某一个商品的勾选状态
async updateChecked(cartInfo, event) {
  try {
    let isChecked = event.target.checked ? 1 : 0;
    await this.$store.dispatch("shopcart/UpdateCheckedById", {skuId: cartInfo.skuId,isChecked });
    /修改成功，刷新数据
    this.getDate();
  } catch (error) {
    alert(error.message);
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="删除多个商品（actions扩展）"><a href="#删除多个商品（actions扩展）" class="headerlink" title="删除多个商品（actions扩展）"></a>删除多个商品（actions扩展）</h2><p>由于后台只提供了删除单个商品的接口，所以要删除多个商品时，只能多次调用actions中的函数。<br>我们可能最简单的方法是在method的方法中多次执行dispatch删除函数，当然这种做法也可行，但是为了深入了解actions，我们还是要将批量删除封装为actions函数。<br><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/guide/actions.html">actions扩展</a><br>官网的教程，一个标准的actions函数如下所示：</p>
<pre class="line-numbers language-none"><code class="language-none">deleteAllCheckedById(context) {
    console.log(context)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们可以看一下context到底是什么<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%95%86%E5%93%81.png"></p>
<p>context中是包含dispatch、getters、state的，即我们可以在actions函数中通过dispatch调用其他的actions函数，可以通过getters获取仓库的数据。<br>这样我们的批量删除就简单了，对应的actions函数代码让如下</p>
<pre class="line-numbers language-none"><code class="language-none">// 删除全部勾选产品
deleteAllCheckedCart({dispatch,getters}){
    // context:小仓库，commit【提交mutation修改state】 getters【计算属性】 dispatch 【派系action】 state【当前仓库数据】
    // 获取购物车中的全部产品(是一个数组)
    let PromiseAll = []
    getters.cartInfoList.forEach(item =&gt; {
        let promise = item.isChecked == 1 ? dispatch('DeleteCartById',item.skuId) : ''
        PromiseAll.push(promise)
    });
    // 只要全部promise都成功,返回结果即为成功
    // 如果有一个失败,返回即为失败结果
    return Promise.all(PromiseAll)
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面代码使用到了Promise.all</p>
<blockquote>
<p>Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。</p>
</blockquote>
<p>购物车组件method批量删除函数</p>
<pre class="line-numbers language-none"><code class="language-none">//删除选中的所有商品
async deleteAllCheckedById(){
  try{
    await this.$store.dispatch('deleteAllCheckedById')
    //删除成功，刷新数据
    this.$store.dispatch("getCartList")
  }catch (error){
    alert(error)
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改商品的全部状态和批量删除的原理相同，直接贴代码。<br>actions</p>
<pre class="line-numbers language-none"><code class="language-none">// 修改全部商品状态
updateAllCartIsChecked({getters,dispatch},isChecked){
    let PromiseAll = []
    getters.cartInfoList.forEach(item =&gt; {
        let promise = dispatch('UpdateCheckedById',{skuId:item.skuId,isChecked})
        PromiseAll.push(promise)
    })
    return Promise.all(PromiseAll)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>method</p>
<pre class="line-numbers language-none"><code class="language-none"> //修改全部商品的状态
async allChecked(event){
    let flag =  event.target.checked ? 1 : 0
    try{
      await this.$store.dispatch('updateAllChecked',flag)
      //修改成功，刷新数据
      this.$store.dispatch("getCartList")
    }catch (error){
      alert(error)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="注册登录业务"><a href="#注册登录业务" class="headerlink" title="注册登录业务"></a>注册登录业务</h2><h3 id="用户注册模块"><a href="#用户注册模块" class="headerlink" title="用户注册模块"></a>用户注册模块</h3><p>actions</p>
<pre class="line-numbers language-none"><code class="language-none">//用户注册
async userRegister({ commit }, user) {
  let result = await reqUserRegister(user);
  if (result.code == 200) {
    return "ok";
  } else {
    return Promise.reject(new Error("failed"));
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>methods注册功能<br>这里用到了表单验证插件 <strong><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yx1102/p/12741466.html">vee-validate</a></strong><br>首先在src目录下的plugins文件夹中创建validate.js文件</p>
<pre class="line-numbers language-validate.js" data-language="validate.js"><code class="language-validate.js">// vee-validate插件：表单验证区域
import Vue from 'vue'
import VeeValidate from 'vee-validate'
// 中文提示信息
import zh_CN from "vee-validate/dist/locale/zh_CN";
Vue.use(VeeValidate)

// 表单验证
VeeValidate.Validator.localize("zh_CN", {
    messages: {
        ...zh_CN.messages,
        is: (field) =&gt; `${field}必须与密码相同`, // 修改内置规则的 message，让确认密码和密码相同
    },
    attributes: {
        phone: "手机号",
        code: "验证码",
        password: "密码",
        passwordRepe: "确认密码",
        agree: '协议'
    },
});

// 自定义校验规则
//定义协议必须打勾同意
VeeValidate.Validator.extend('agree', {
    validate: value =&gt; {
        return value
    },
    getMessage: field =&gt; field + '必须同意'
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在main.js组件注册</p>
<pre class="line-numbers language-none"><code class="language-none">//引入表单校验插件
import "@/plugins/validate";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>html</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;div class="content"&gt;
  &lt;label&gt;手机号:&lt;/label&gt;
  &lt;input placeholder="请输入你的手机号" v-model="phone" name="phone" v-validate="{ required: true, regex: /^1\d{10}$/ }" :class="{ invalid: errors.has('phone') }" /&gt;
  &lt;span class="error-msg"&gt;{{ errors.first("phone") }}&lt;/span&gt;
&lt;/div&gt;
&lt;div class="content"&gt;
  &lt;label&gt;验证码:&lt;/label&gt;
  &lt;input placeholder="请输入你的验证码" v-model="code" name="code" v-validate="{ required: true, regex: /^\d{6}$/ }" :class="{ invalid: errors.has('code') }" /&gt;
  &lt;button style="width:100px;height:38px" @click="getCode"&gt;
    获取验证码
  &lt;/button&gt;
  &lt;span class="error-msg"&gt;{{ errors.first("code") }}&lt;/span&gt;
&lt;/div&gt;
&lt;div class="content"&gt;
  &lt;label&gt;登录密码:&lt;/label&gt;
  &lt;input placeholder="请输入你的密码" v-model="password" name="password" v-validate="{ required: true, regex: /^[0-9A-Za-z]{8,20}$/ }" :class="{ invalid: errors.has('password') }" /&gt;
  &lt;span class="error-msg"&gt;{{ errors.first("password") }}&lt;/span&gt;
&lt;/div&gt;
&lt;div class="content"&gt;
  &lt;label&gt;确认密码:&lt;/label&gt;
  &lt;input placeholder="请输入确认密码" v-model="password1" name="password1" v-validate="{ required: true, is: password }" :class="{ invalid: errors.has('password1') }" /&gt;
  &lt;span class="error-msg"&gt;{{ errors.first("password1") }}&lt;/span&gt;
&lt;/div&gt;
&lt;div class="controls"&gt;
  &lt;input type="checkbox" v-model="agree" name="agree" v-validate="{ required: true, tongyi: true }" :class="{ invalid: errors.has('agree') }" /&gt;
  &lt;span&gt;同意协议并注册《尚品汇用户协议》&lt;/span&gt;
  &lt;span class="error-msg"&gt;{{ errors.first("agree") }}&lt;/span&gt;
&lt;/div&gt;
&lt;div class="btn"&gt;
  &lt;button @click="userRegister"&gt;完成注册&lt;/button&gt;
&lt;/div&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>methods</p>
<pre class="line-numbers language-none"><code class="language-none">//用户注册
async userRegister() {
  const success = await this.$validator.validateAll();
  //全部表单验证成功，在向服务器发请求，进行祖册
  //只要有一个表单没有成功，不会发请求
  if (success) {
    try {
      const { phone, code, password, password1 } = this;
      await this.$store.dispatch("userRegister", {
        phone,
        code,
        password,
      });
      //注册成功进行路由的跳转
      this.$router.push("/login");
    } catch (error) {
      alert(error.message);
    }
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="登录模块"><a href="#登录模块" class="headerlink" title="登录模块"></a>登录模块</h3><p>html</p>
<pre class="line-numbers language-none"><code class="language-none">&lt;form &gt;
    &lt;div class="input-text clearFix"&gt;
      &lt;span&gt;&lt;/span&gt;
      &lt;input type="text" placeholder="邮箱/用户名/手机号" v-model="phone"&gt;
    &lt;/div&gt;
    &lt;div class="input-text clearFix"&gt;
      &lt;span class="pwd"&gt;&lt;/span&gt;
      &lt;input type="password" placeholder="请输入密码" v-model="password"&gt;
    &lt;/div&gt;
    &lt;div class="setting clearFix"&gt;
      &lt;label class="checkbox inline"&gt;
        &lt;input name="m1" type="checkbox" value="2" checked=""&gt;
        自动登录
      &lt;/label&gt;
      &lt;span class="forget"&gt;忘记密码？&lt;/span&gt;
    &lt;/div&gt;
    &lt;button class="btn" @click.prevent="goLogin"&gt;登&amp;nbsp;&amp;nbsp;录&lt;/button&gt;
&lt;/form&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于登录按钮的父节点是一个form表单，如果使用@click触发登录事件，form表单会执行默认事件action实现页面跳转。这里我们使用 <strong>@click.prevent</strong>，它可以阻止自身默认事件的执行。</p>
<p>actions</p>
<pre class="line-numbers language-none"><code class="language-none">//登录业务
async userLogin({ commit }, data) {
  let result = await reqUserLogin(data);
  //服务器下发token，用户唯一标识符(uuid)
  //将来经常通过带token找服务器要用户信息进行展示
  if (result.code == 200) {
    //用户已经登录成功且获取到token
    commit("USERLOGIN", result.data.token);
    //持久化存储token
    setToken(result.data.token);
    return "ok";
  } else {
    return Promise.reject(new Error("faile"));
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>mutations设置用户token</p>
<pre class="line-numbers language-none"><code class="language-none">//设置用户token
SETUSERTOKEN(state,token){
    state.token = token
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>登录组件methods</p>
<pre class="line-numbers language-none"><code class="language-none">//登录的回调函数
async userLogin() {
  try {
    //登录成功
    const { phone, password } = this;
    phone&amp;&amp;password&amp;&amp;(await this.$store.dispatch("userLogin", { phone, password }));
    //登录的路由组件：看路由当中是否包含query参数，有：调到query参数指定路由，没有：调到home
      let toPath = this.$route.query.redirect||"/home";
      this.$router.push(toPath);
  } catch (error) {
    alert(error.message);
  }
},<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>actions登录成功后获取用户信息</p>
<pre class="line-numbers language-none"><code class="language-none">//获取用户信息
async getUserInfo({ commit }) {
  let result = await reqUserInfo();
  if (result.code == 200) {
    //提交用户信息
    commit("GETUSERINFO", result.data);
    return 'ok';
  }else{
    return Promise.reject(new Error('faile'));
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>mutations存储用户信息</p>
<pre class="line-numbers language-none"><code class="language-none">//存储用户信息
SETUSERINFO(state,data){
    state.userInfo = data
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>思路：直接看流程图<br>为什么要判断name？</p>
<blockquote>
<p>因为store中的token是通过localStorage获取的，token有存放在本地。当页面刷新时，本地token不会消失，所以store中的token也不会消失。但是，store中的其他数据（用户信息等）会清空，此时会出现用户信息不存在，但是有token，这种情况是不可以访问其他页面的，必须先去获取用户信息。由于用户信息是一个对象，所以我们通过它的一个属性name判断用户信息是否存在。<br>所以不仅要判断token,还要判断用户信息</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB.png"></p>
<pre class="line-numbers language-none"><code class="language-none">//全局守卫：前置守卫（在路由跳转之间进行判断）
router.beforeEach(async (to, from, next) =&gt; {
   //to:获取到要跳转到的路由信息
   //from：获取到从哪个路由跳转过来来的信息
   //next: next() 放行  next(path) 放行  
   //方便测试 统一放行
  //  next();
  //获取仓库中的token-----可以确定用户是登录了
   let token  = store.state.user.token;
   let name = store.state.user.userInfo.name;
   //用户登录了
   if(token){
     //已经登录而且还想去登录------不行
     if(to.path=="/login"||to.path=='/register'){
        next('/');
     }else{
       //已经登陆了,访问的是非登录与注册
       //登录了且拥有用户信息放行
       if(name){
         next();
       }else{
         //登陆了且没有用户信息
         //在路由跳转之前获取用户信息且放行
         try {
          await store.dispatch('getUserInfo');
          next();
         } catch (error) {
           //token失效从新登录
           await store.dispatch('userLogout');
           next('/login')
         }
       }
     }
   }else{
      //未登录：不能去交易相关、不能去支付相关【pay|paysuccess】、不能去个人中心
      //未登录去上面这些路由-----登录
      let toPath = to.path;
      if(toPath.indexOf('/trade')!=-1 || toPath.indexOf('/pay')!=-1||toPath.indexOf('/center')!=-1){
        //把未登录的时候向去而没有去成的信息，存储于地址栏中【路由】
        next('/login?redirect='+toPath);
      }else{
         //去的不是上面这些路由（home|search|shopCart）---放行
         next();
      }
    
   }
});<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="交易模块"><a href="#交易模块" class="headerlink" title="交易模块"></a>交易模块</h2><p>支付弹窗（这里使用了element-UI）<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E5%BC%B9%E7%AA%97%E6%94%AF%E4%BB%98.png"></p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">import {Button,MessageBox} from 'element-ui';
//ElementUI注册组件
//ElementUI注册组件的时候，还有一种写法，挂在原型上Vue.component(Button.name,Button);
Vue.prototype.$msgbox = MessageBox;
Vue.prototype.$alert = MessageBox.alert;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-pay.vue" data-language="pay.vue"><code class="language-pay.vue">&lt;div class="submit"&gt;
  &lt;a class="btn" @click="open"&gt;立即支付&lt;/a&gt;
&lt;/div&gt;

&lt;script&gt;
//生成二维码插件
import QRCode from "qrcode";
// 支付弹窗
async open() {
  // 生成二维码（地址）
  let qrCode = await QRCode.toDataURL(this.payInfo.codeUrl)
  this.$alert(`&lt;img src=${qrCode} /&gt;`, "请你微信支付", {
    dangerouslyUseHTMLString: true, //是否将 message 属性作为 HTML 片段处理
    center:true, //是否居中布局
    showClose:false, //MessageBox 是否显示右上角关闭按钮
    showCancelButton:true, //是否显示取消按钮
    showConfirmButton:true, //是否显示确定按钮
    cancelButtonText: '支付遇见问题', //取消按钮的文本内容
    confirmButtonText: '已支付成功', //确定按钮的文本内容	
    // 关闭弹出框的配置值
    beforeClose:(type,instance,done)=&gt;{  //此处必须用箭头函数
      // type：区分取消|确定按钮
      // instance：当前组件实例
      // done：关闭弹出框的方法
      if(type=='cancel'){
        alert('请联系管理员');
        console.log('请联系管理员');
        clearInterval(this.timer);
        this.timer = null;
        // 关闭弹出框
        done()
      }else{
         if(this.code == 200){
          clearInterval(this.timer)
          this.timer = null
          done()
          this.$router.push('/paysuccess')
         }
      }
    }
  }).catch(e =&gt; e);
  // 支付成功，需要路由跳转，支付失败，提示信息
  if(!this.timer){
    //定时器间歇发送请求获取订单支付状态
    this.timer = setInterval(async () =&gt; {
      let result = await this.$API.reqPayStatus(this.orderId)
      console.log(result);
      if(result.code == 200){
         //1、清除定时器
        clearInterval(this.timer)
        this.timer = null
        /2、保存支付成功返回的code
        this.code = result.code
        //3、关闭弹出框
        this.$msgbox.close()
        //4、跳转到下一个路由
        this.$router.push('/paysuccess')
      }
    },1000)
  }
}
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="个人中心"><a href="#个人中心" class="headerlink" title="个人中心"></a>个人中心</h2><p>虽然二级路由在后台管理系统常用，但是我们的个人中心也可以用到二级路由。<br><strong>注意：</strong> 我们的子路由最好放在父路由文件夹下，二级路由要么不写/，要么写全：’/center/myorder’。</p>
<pre class="line-numbers language-route.js" data-language="route.js"><code class="language-route.js">//个人中心
{
    name: 'Center',
    path: '/center',
    component:  () =&gt; import('@/pages/Center'),
    children: [
        {
            //二级路由要么不写/，要么写全：'/center/myorder'
            path: 'myorder',
            component: () =&gt; import('@/pages/Center/MyOrder')
        },
        {
            path: 'groupbuy',
            component: () =&gt; import('@/pages/Center/GroupOrder'),
        },
        // 表示当我们访问center路由时，center中的router-view部分默认显示myorder二级路由内容。
        {
            path:'/center',
            redirect:'/center/myorder'
        }
    ]
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="路由独享的守卫"><a href="#路由独享的守卫" class="headerlink" title="路由独享的守卫"></a>路由独享的守卫</h2><p>全局导航守卫已经帮助我们限制未登录的用户不可以访问相关页面。但是还会有一个问题<br>例如：</p>
<blockquote>
<p>用户已经登陆，用户在home页直接通过地址栏访问trade结算页面，发现可以成功进入该页面，正常情况，用户只能通过在shopcart页面点击去结算按钮才可以到达trade页面。我们可以通过路由独享守卫解决该问题</p>
</blockquote>
<p>路由独享的守卫：只针对一个路由的守卫，所以该守卫会定义在某个路由中。<br>以上面问题为例，我们可以通过路由独享的守卫解决。<br>在trade路由信息中加入路由独享守卫</p>
<pre class="line-numbers language-none"><code class="language-none">//交易组件
{
    name: 'Trade',
    path: '/trade',
    meta: {show:true},
    component:  () =&gt; import('@/pages/Trade'),
    //路由独享首位
    beforeEnter: (to, from, next) =&gt; {
      
        if(from.path ===  '/shopcart' ){
            next()
        }else{
            next(false)
        }
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><p>插件的使用直接参考官方教程<br><a target="_blank" rel="noopener" href="https://www.npmjs.com/package/vue-lazyload">懒加载vue-lazyload插件官网</a></p>
<h2 id="vue使用插件的原理"><a href="#vue使用插件的原理" class="headerlink" title="vue使用插件的原理"></a>vue使用插件的原理</h2><p>每个插件都会有一个<strong>install方法</strong>，install后就可以在我们的代码中可以使用该插件。这个install有两类参数，第一个为Vue实例，后面的参数可以自定义。</p>
<p>vue使用插件的步骤</p>
<ol>
<li>引入插件 <strong>import VueLazyload from “vue-lazyload”</strong></li>
<li>注册插件 <strong>Vue.use(VueLazyload)</strong></li>
</ol>
<p>这里的Vue.use()实际上就是调用了插件的install方法。如此之后，我们就可以使用该插件了。</p>
<h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/yx1102/p/12741466.html">vee-validate</a><br><a target="_blank" rel="noopener" href="https://element.eleme.cn/#/zh-CN/component/form">element-UI</a></p>
<h2 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h2><p>当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_43424325/article/details/121684101">路由懒加载链接</a><br>代码示例</p>
<pre class="line-numbers language-none"><code class="language-none">//详情页面组件
{
    //需要params传参（产品id）
    path: "/detail/:skuId",
    name: 'Detail',
    component: ()=&gt; import('../pages/Detail'),
    meta:{show: true},
},
//添加购物车成功
{
    path: "/addcartsuccess",
    name: 'AddCartSuccess',
    component: ()=&gt; import('../pages/AddCartSuccess'),
    meta:{show: true},
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="打包项目"><a href="#打包项目" class="headerlink" title="打包项目"></a>打包项目</h2><p>项目到此基本就完成了，接下来就是打包上线。在项目文件夹下执行npm run build。会生成dist打包文件<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE1.png"></p>
<p>dist就是我们打包好的项目文件<br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE2.png"></p>
<p>dist文件下的js文件存放我们所有的js文件，并且经过了加密，并且还会生成对应的map文件。</p>
<p><strong>map文件作用：</strong> 因为代码是经过加密的，如果运行时报错，输出的错误信息无法准确得知时那里的代码报错。有了map就可以向未加密的代码一样，准确的输出是哪一行那一列有错。</p>
<p>当然map文件也可以去除（map文件大小还是比较大的）<br>在vue.config.js配置<strong>productionSourceMap: false</strong>即可。<br>注意：vue.config.js配置改变，需要重启项目</p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE3.png"></p>
<h1 id="尚品汇后台管理系统"><a href="#尚品汇后台管理系统" class="headerlink" title="尚品汇后台管理系统"></a>尚品汇后台管理系统</h1><h2 id="后台模板介绍"><a href="#后台模板介绍" class="headerlink" title="后台模板介绍"></a>后台模板介绍</h2><p><strong>该模板基于elementUI组件库开发</strong><br><strong>简洁版:</strong> <a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-admin-template">https://github.com/PanJiaChen/vue-admin-template</a><br><strong>加强版:</strong> <a target="_blank" rel="noopener" href="https://github.com/PanJiaChen/vue-element-admin">https://github.com/PanJiaChen/vue-element-admin</a></p>
<h2 id="模板常用的文件与文件夹认知【简洁版】"><a href="#模板常用的文件与文件夹认知【简洁版】" class="headerlink" title="模板常用的文件与文件夹认知【简洁版】"></a>模板常用的文件与文件夹认知【简洁版】</h2><blockquote>
<p><strong>build</strong><br>—–index.js：webpack配置文件【很少修改这个文件】<br><strong>mock</strong><br>—–mock数据的文件夹【模拟一些假的数据mockjs实现的】，因为咱们实际开发的时候，利用的是真是接口<br><strong>node_modules</strong><br>—–项目依赖的模块<br><strong>public</strong><br>—–icon图标，静态页面，publick文件夹里面经常放置一些静态资源，而且在项目打包的时候webpack不会编译这个文件夹，原封不动的打包到dist文件夹里面<br><strong>src</strong><br>—–程序员源代码的地方<br>—–api文件夹:涉及请求相关的<br>—–assets文件夹：里面放置一些静态资源（一般共享的），放在aseets文件夹里面静态资源，在webpack打包的时候，会进行编译<br>—–components文件夹：一般放置非路由组件获取全局组件<br>—–icons这个文件夹的里面放置了一些svg矢量图<br>—–layout文件夹：他里面放置一些组件与混入<br>—–router文件夹：与路由相关的<br>—–store文件夹：一定是与vuex相关的<br>—–style文件夹：与样式相关的<br>—–utils文件夹：request.js是axios二次封装文件<br>—–views文件夹：里面放置的是路由组件<br><strong>App.vue：</strong> 根组件<br><strong>main.js：</strong> 入口文件<br><strong>permission.js：</strong> 与导航守卫相关、<br><strong>settings：</strong> 项目配置项文件<br><strong>.editorconfig：</strong> 编程风格配置文件<br><strong>webpack配置文件</strong><br>webpack可以监测到当前开发环境<br>—–.env.development 开发环境<br>—–.env.producation 上线环境<br>—–.env.staging 测试环境<br>env文件的配置均以VUE_APP开头<br>可以在main.js通过webpack提供的对象process身上的env属性获取.env文件的全部配置信息</p>
</blockquote>
<h3 id="获取当前的开发环境"><a href="#获取当前的开发环境" class="headerlink" title="获取当前的开发环境"></a>获取当前的开发环境</h3><p><strong>具体代码：console.log(process.env)</strong></p>
<p><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/process%E5%AF%B9%E8%B1%A1.png"></p>
<p><strong>相关应用</strong></p>
<pre class="line-numbers language-request.js" data-language="request.js"><code class="language-request.js">//根据开发环境决定axios实例的baseURL
const service = axios.create({
  baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url
  // withCredentials: true, // send cookies when cross-domain requests
  timeout: 5000 // request timeout
})<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="完成登录业务"><a href="#完成登录业务" class="headerlink" title="完成登录业务"></a>完成登录业务</h2><blockquote>
<p><strong>步骤：</strong></p>
<ol>
<li>静态组件完成</li>
<li>书写API（换成真实的接口）</li>
<li>axios二次封装</li>
<li>换成真实接口之后需要解决代理跨域问题(解决代理跨域问题)</li>
</ol>
</blockquote>
<h2 id="品牌管理静态组件"><a href="#品牌管理静态组件" class="headerlink" title="品牌管理静态组件"></a>品牌管理静态组件</h2><p><strong>使用<a href="ElementUI">https://element.eleme.cn/#/zh-CN/component/installation</a>搭建静态组件</strong></p>
<pre class="line-numbers language-index.vue" data-language="index.vue"><code class="language-index.vue">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 按钮 --&gt;
    &lt;el-button type="primary" icon="el-icon-plus"&gt;添加&lt;/el-button&gt;
    &lt;!-- 
        表格组件
        data：表格组件将来需要展示的数据---数据类型
        border：是给表格添加边框
        colum属性
        label：显示标题
        width：对应宽度
        aligin：标题的对齐方式
        prop：对应列内容的字段名
        注意：elementUI当中的table组件，展示的数据是以一列一列进行展示数据
     --&gt;
    &lt;el-table style="width: 100%" border &gt;
      &lt;el-table-column prop="prop" label="序号" width="80px" align="center"&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column prop="prop" label="品牌名称" width="width" align="center"&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column prop="prop" label="品牌LOGO" width="width" align="center"&gt;
      &lt;/el-table-column&gt;
      &lt;el-table-column prop="prop" label="操作" width="width" align="center"&gt;
      &lt;/el-table-column&gt;
    &lt;/el-table&gt;
    &lt;!-- 
        分页器
        当前展示第几页，数据总条数，每页展示条数，连续页码数
        @size-change="handleSizeChange" --pageSize 改变时会触发
        @current-change="handleCurrentChange" --currentPage 改变时会触发
        current-page：代表的是当前第几页
        total：代表分页器一共需要展示多少条数据
        page-size：代表每一页需要多少条数据
        layout：可以实现分页器布局
        pager-count：按钮的数量 如果设置为9，则连续页码个数为7
     --&gt;
    &lt;el-pagination
      style="margin-top:20px;text-align:center;"
      :current-page="5"
      :total="99"
      :page-size="5"
      :page-sizes="[3, 5, 7]"
      :pager-count='7'
      layout="prev, pager, next, jumper, -&gt;, sizes, total"
      &gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
&lt;/template&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="品牌列表动态展示"><a href="#品牌列表动态展示" class="headerlink" title="品牌列表动态展示"></a>品牌列表动态展示</h2><p><strong>1.书写相关的API接口</strong></p>
<pre class="line-numbers language-main.js" data-language="main.js"><code class="language-main.js">// 引入API接口
import API from '@/api'
Vue.prototype.$API = API<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p><strong>2.展示动态数据</strong></p>
<pre class="line-numbers language-none"><code class="language-none">&lt;template&gt;
  &lt;div&gt;
    &lt;!-- 按钮 --&gt;
    &lt;el-button type="primary" icon="el-icon-plus"&gt;添加&lt;/el-button&gt;

    &lt;el-table style="width: 100%" border :data="records"&gt;
        &lt;el-table-column type="index" label="序号" width="80px" align="center"&gt;
        &lt;/el-table-column&gt;
        &lt;el-table-column prop="tmName" label="品牌名称" width="width" align="center"&gt;
        &lt;/el-table-column&gt;
        &lt;el-table-column label="品牌LOGO" width="width" align="center"&gt;
          &lt;!-- 作用域插槽 --&gt;
          &lt;template slot-scope="{row,$index}"&gt;
            &lt;img :src="row.logoUrl" alt="" style="width:100px;height:100px"&gt;
          &lt;/template&gt;
        &lt;/el-table-column&gt;
        &lt;el-table-column label="操作" width="width" align="center"&gt;
          &lt;el-button type="warning" icon="el-icon-edit" size="mini"&gt;修改&lt;/el-button&gt;
          &lt;el-button type="danger" icon="el-icon-delete" size="mini"&gt;删除&lt;/el-button&gt;
        &lt;/el-table-column&gt;
    &lt;/el-table&gt;

    &lt;el-pagination
      style="margin-top:20px;text-align:center;"
      :current-page="page"
      :total="total"
      :page-size="limit"
      :page-sizes="[3, 5, 7]"
      :pager-count='7'
      @current-change="getPageList"
      @size-change="handleSizeChange"
      layout="prev, pager, next, jumper, -&gt;, sizes, total"
      &gt;
    &lt;/el-pagination&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  name: "tradeMark",
  data() {
    return {
      // 代表的分页器第几页
      page:1,
      // 当前页面展示数据条数
      limit:3,
      // 总共多少条数据
      total:0,
      // 列表展示数据
      records:[]
    }
  },
  mounted() {
    this.getPageList();
  },
  methods: {
    // 获取列表数据方法
    async getPageList(pager=1){
      this.page=pager
      const {page,limit} = this;
      // 获取品牌列表的接口
      let result = await this.$API.tradeMark.reqTradeMarkList(page,limit)
      if(result.code === 200){
        this.total = result.data.total
        this.records = result.data.records
      }
    },
    // 当分页器某一页需要需要展示数据条数发生变化的时候触发
    handleSizeChange(limit){
      this.limit = limit
      this.getPageList()
    }
  },
};
&lt;/script&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>实际效果图</strong><br><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/studyblog/study/%E5%B0%9A%E5%93%81%E6%B1%87%E9%A1%B9%E7%9B%AE/trademark.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Serein</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://serein.icu/posts/7.html">https://serein.icu/posts/7.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://serein.icu" target="_blank">Serein's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Vue/">Vue</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/zhifubao.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/zhifubao.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/8.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Vue组件通信总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/6.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/6.jpg" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Promise学习笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/3.html" title="Vue2进阶知识"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">Vue2进阶知识</div></div></a></div><div><a href="/posts/4.html" title="Vue3快速上手"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/5.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-14</div><div class="title">Vue3快速上手</div></div></a></div><div><a href="/posts/8.html" title="Vue组件通信总结"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-09</div><div class="title">Vue组件通信总结</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Valine</span><span class="switch-btn"></span><span class="second-comment">Disqus</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/headimg_dl.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Serein</div><div class="author-info__description">热爱大前端并怀揣着梦想</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">8</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div><a class="button--animated" id="card-info-btn" href="https://serein.icu/"><i class="fab fa-home"></i><span>个人主页</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/EATBFL/EATBFL.github.io" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1297711534&amp;website=www.serein.icu" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">兴趣爱好才是最大的动力，何不与我共同来攀知识高峰，一览众山小！</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AFVue%E6%A0%B8%E5%BF%83"><span class="toc-number">1.</span> <span class="toc-text">前端Vue核心</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%9A%E5%93%81%E6%B1%87%E5%89%8D%E5%8F%B0%E5%95%86%E5%93%81%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">尚品汇前台商品系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E5%88%86%E6%9E%90"><span class="toc-number">2.1.</span> <span class="toc-text">vue文件目录分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.</span> <span class="toc-text">项目配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E6%89%93%E5%BC%80"><span class="toc-number">2.2.1.</span> <span class="toc-text">项目运行，浏览器自动打开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%ADeslint%E6%A0%A1%E9%AA%8C%E5%B7%A5%E5%85%B7%EF%BC%88%E4%B8%8D%E5%85%B3%E9%97%AD%E4%BC%9A%E6%9C%89%E5%90%84%E7%A7%8D%E8%A7%84%E8%8C%83%EF%BC%8C%E4%B8%8D%E6%8C%89%E7%85%A7%E8%A7%84%E8%8C%83%E5%B0%B1%E4%BC%9A%E6%8A%A5%E9%94%99%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#src%E6%96%87%E4%BB%B6%E5%A4%B9%E9%85%8D%E7%BD%AE%E5%88%AB%E5%90%8D-%E5%88%9B%E5%BB%BAjsconfig-json"><span class="toc-number">2.2.3.</span> <span class="toc-text">src文件夹配置别名,创建jsconfig.json</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%A1%B5%E9%9D%A2%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.3.</span> <span class="toc-text">组件页面样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%85%E9%99%A4vue%E9%A1%B5%E9%9D%A2%E9%BB%98%E8%AE%A4%E7%9A%84%E6%A0%B7%E5%BC%8F"><span class="toc-number">2.4.</span> <span class="toc-text">清除vue页面默认的样式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#views-pages%E6%96%87%E4%BB%B6%E5%A4%B9"><span class="toc-number">2.5.</span> <span class="toc-text">views&#x2F;pages文件夹</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%92%8C%E9%9D%9E%E8%B7%AF%E7%94%B1%E7%BB%84%E4%BB%B6%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.1.</span> <span class="toc-text">路由组件和非路由组件区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC%E6%96%B9%E5%BC%8F"><span class="toc-number">2.5.2.</span> <span class="toc-text">路由跳转方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82"><span class="toc-number">2.6.</span> <span class="toc-text">路由传参</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#params%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.1.</span> <span class="toc-text">params传参问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.6.2.</span> <span class="toc-text">传参方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%AC%A1%E6%89%A7%E8%A1%8C%E7%9B%B8%E5%90%8C%E7%9A%84push%E9%97%AE%E9%A2%98"><span class="toc-number">2.7.</span> <span class="toc-text">多次执行相同的push问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-number">2.8.</span> <span class="toc-text">定义全局组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85axios"><span class="toc-number">2.9.</span> <span class="toc-text">封装axios</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%80%9A%E8%BF%87%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.10.</span> <span class="toc-text">前端通过代理解决跨域问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E6%8E%A5%E5%8F%A3%E7%BB%9F%E4%B8%80%E5%B0%81%E8%A3%85"><span class="toc-number">2.11.</span> <span class="toc-text">请求接口统一封装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nprogress%E8%BF%9B%E5%BA%A6%E6%9D%A1%E6%8F%92%E4%BB%B6"><span class="toc-number">2.12.</span> <span class="toc-text">nprogress进度条插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E5%BC%95%E5%85%A5vuex"><span class="toc-number">2.13.</span> <span class="toc-text">手动引入vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#async-await%E4%BD%BF%E7%94%A8"><span class="toc-number">2.14.</span> <span class="toc-text">async await使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex"><span class="toc-number">2.15.</span> <span class="toc-text">vuex</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#loadsh%E6%8F%92%E4%BB%B6%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81"><span class="toc-number">2.16.</span> <span class="toc-text">loadsh插件防抖和节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E5%BC%8F%E5%AF%BC%E8%88%AA-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E5%AE%9E%E7%8E%B0%E8%B7%AF%E7%94%B1%E8%B7%B3%E8%BD%AC"><span class="toc-number">2.17.</span> <span class="toc-text">编程式导航+事件委托实现路由跳转</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue%E8%B7%AF%E7%94%B1%E9%94%80%E6%AF%81%E9%97%AE%E9%A2%98"><span class="toc-number">2.18.</span> <span class="toc-text">Vue路由销毁问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mock%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">2.19.</span> <span class="toc-text">mock插件使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vuex%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">2.20.</span> <span class="toc-text">vuex数据存储与使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#swiper%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE"><span class="toc-number">2.21.</span> <span class="toc-text">swiper插件实现轮播图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%86%E8%BD%AE%E6%92%AD%E5%9B%BE%E6%A8%A1%E5%9D%97%E6%8F%90%E5%8F%96%E4%B8%BA%E5%85%A8%E5%B1%80%E7%BB%84%E4%BB%B6"><span class="toc-number">2.22.</span> <span class="toc-text">将轮播图模块提取为全局组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#getters%E4%BD%BF%E7%94%A8"><span class="toc-number">2.23.</span> <span class="toc-text">getters使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-asign%E5%AE%9E%E7%8E%B0%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.24.</span> <span class="toc-text">Object.asign实现对象拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%B7%B1%E6%8B%B7%E8%B4%9D"><span class="toc-number">2.25.</span> <span class="toc-text">对象深拷贝</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%B7%AF%E7%94%B1%E4%BF%A1%E6%81%AF%E5%8F%98%E5%8C%96%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E6%90%9C%E7%B4%A2"><span class="toc-number">2.26.</span> <span class="toc-text">利用路由信息变化实现动态搜索</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%8C%85%E5%B1%91%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C"><span class="toc-number">2.27.</span> <span class="toc-text">面包屑相关操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SearchSelector%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E5%8F%82%E5%8F%8A%E9%9D%A2%E5%8C%85%E5%B1%91%E6%93%8D%E4%BD%9C"><span class="toc-number">2.28.</span> <span class="toc-text">SearchSelector子组件传参及面包屑操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%93%81%E6%8E%92%E5%BA%8F"><span class="toc-number">2.29.</span> <span class="toc-text">商品排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E5%88%86%E9%A1%B5%E5%99%A8"><span class="toc-number">2.30.</span> <span class="toc-text">手写分页器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%8B%BC%E6%8E%A5"><span class="toc-number">2.31.</span> <span class="toc-text">字符串拼接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%9A%E5%8A%A8%E6%9D%A1"><span class="toc-number">2.32.</span> <span class="toc-text">滚动条</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined%E7%BB%86%E8%8A%82"><span class="toc-number">2.33.</span> <span class="toc-text">undefined细节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85"><span class="toc-number">2.34.</span> <span class="toc-text">商品详情</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BE%E5%A4%A7%E9%95%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">2.34.1.</span> <span class="toc-text">放大镜相关知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%B1%E7%84%A6%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.35.</span> <span class="toc-text">失焦事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E5%85%A5%E8%B4%AD%E7%89%A9%E8%BD%A6%E6%88%90%E5%8A%9F%E8%B7%AF%E7%94%B1"><span class="toc-number">2.36.</span> <span class="toc-text">加入购物车成功路由</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91"><span class="toc-number">2.37.</span> <span class="toc-text">购物车组件开发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E5%95%86%E5%93%81%E6%95%B0%E9%87%8F"><span class="toc-number">2.38.</span> <span class="toc-text">购物车商品数量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AD%E7%89%A9%E8%BD%A6%E7%8A%B6%E6%80%81%E4%BF%AE%E6%94%B9%E5%92%8C%E5%95%86%E5%93%81%E5%88%A0%E9%99%A4"><span class="toc-number">2.39.</span> <span class="toc-text">购物车状态修改和商品删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%A4%9A%E4%B8%AA%E5%95%86%E5%93%81%EF%BC%88actions%E6%89%A9%E5%B1%95%EF%BC%89"><span class="toc-number">2.40.</span> <span class="toc-text">删除多个商品（actions扩展）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1"><span class="toc-number">2.41.</span> <span class="toc-text">注册登录业务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%B3%A8%E5%86%8C%E6%A8%A1%E5%9D%97"><span class="toc-number">2.41.1.</span> <span class="toc-text">用户注册模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%99%BB%E5%BD%95%E6%A8%A1%E5%9D%97"><span class="toc-number">2.41.2.</span> <span class="toc-text">登录模块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB"><span class="toc-number">2.42.</span> <span class="toc-text">导航守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%98%93%E6%A8%A1%E5%9D%97"><span class="toc-number">2.43.</span> <span class="toc-text">交易模块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AA%E4%BA%BA%E4%B8%AD%E5%BF%83"><span class="toc-number">2.44.</span> <span class="toc-text">个人中心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E7%8B%AC%E4%BA%AB%E7%9A%84%E5%AE%88%E5%8D%AB"><span class="toc-number">2.45.</span> <span class="toc-text">路由独享的守卫</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.46.</span> <span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vue%E4%BD%BF%E7%94%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.47.</span> <span class="toc-text">vue使用插件的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E9%AA%8C%E8%AF%81"><span class="toc-number">2.48.</span> <span class="toc-text">表单验证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">2.49.</span> <span class="toc-text">路由懒加载</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.50.</span> <span class="toc-text">打包项目</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B0%9A%E5%93%81%E6%B1%87%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.</span> <span class="toc-text">尚品汇后台管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E6%A8%A1%E6%9D%BF%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.1.</span> <span class="toc-text">后台模板介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%87%E4%BB%B6%E4%B8%8E%E6%96%87%E4%BB%B6%E5%A4%B9%E8%AE%A4%E7%9F%A5%E3%80%90%E7%AE%80%E6%B4%81%E7%89%88%E3%80%91"><span class="toc-number">3.2.</span> <span class="toc-text">模板常用的文件与文件夹认知【简洁版】</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E7%9A%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-number">3.2.1.</span> <span class="toc-text">获取当前的开发环境</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E7%99%BB%E5%BD%95%E4%B8%9A%E5%8A%A1"><span class="toc-number">3.3.</span> <span class="toc-text">完成登录业务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%81%E7%89%8C%E7%AE%A1%E7%90%86%E9%9D%99%E6%80%81%E7%BB%84%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">品牌管理静态组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%81%E7%89%8C%E5%88%97%E8%A1%A8%E5%8A%A8%E6%80%81%E5%B1%95%E7%A4%BA"><span class="toc-number">3.5.</span> <span class="toc-text">品牌列表动态展示</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/8.html" title="Vue组件通信总结"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/8.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Vue组件通信总结"/></a><div class="content"><a class="title" href="/posts/8.html" title="Vue组件通信总结">Vue组件通信总结</a><time datetime="2022-04-09T08:20:00.000Z" title="发表于 2022-04-09 16:20:00">2022-04-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7.html" title="尚品汇Vue项目总结"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/7.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="尚品汇Vue项目总结"/></a><div class="content"><a class="title" href="/posts/7.html" title="尚品汇Vue项目总结">尚品汇Vue项目总结</a><time datetime="2022-04-08T03:30:00.000Z" title="发表于 2022-04-08 11:30:00">2022-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/6.html" title="Promise学习笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/6.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Promise学习笔记"/></a><div class="content"><a class="title" href="/posts/6.html" title="Promise学习笔记">Promise学习笔记</a><time datetime="2022-03-28T09:30:00.000Z" title="发表于 2022-03-28 17:30:00">2022-03-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/5.html" title="ES6学习笔记"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/4.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="ES6学习笔记"/></a><div class="content"><a class="title" href="/posts/5.html" title="ES6学习笔记">ES6学习笔记</a><time datetime="2022-03-18T13:00:00.000Z" title="发表于 2022-03-18 21:00:00">2022-03-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4.html" title="Vue3快速上手"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://cdn.jsdelivr.net/gh/EATBFL/serein/img/5.jpg" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/img/friend_404.gif'" alt="Vue3快速上手"/></a><div class="content"><a class="title" href="/posts/4.html" title="Vue3快速上手">Vue3快速上手</a><time datetime="2022-03-14T06:00:00.000Z" title="发表于 2022-03-14 14:00:00">2022-03-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022  <i id="heartbeat" class="fa fas fa-heartbeat"></i> Serein</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div><head><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></head></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'L4e8DCjFsSv0rSH273oEwafp-MdYXbMMI',
      appKey: 'LtRxHbGm7RB4OJge5cOJ2bdL',
      placeholder: '畅所欲言！',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: 'l4e8dcjf.api.lncldglobal.com',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://serein.icu/posts/7.html'
    this.page.identifier = 'posts/7.html'
    this.page.title = '尚品汇Vue项目总结'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://Serein.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Valine' === 'Disqus' || !true) {
  if (true) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script defer id="dsq-count-scr" src="//xianqi.disqus.com/count.js" async></script><script defer type="text/javascript" src="https://cdn.jsdelivr.net/gh/zhaoze-jpg/Xianqi@main/js/animate.js"></script><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script src="//code.tidio.co/kn1idpwt8fdo1pdgxkxq0w4m1zo4ponz.js" async="async"></script><script>function onTidioChatApiReady() {
  window.tidioChatApi.hide();
  window.tidioChatApi.on("close", function() {
    window.tidioChatApi.hide();
  });
}
if (window.tidioChatApi) {
  window.tidioChatApi.on("ready", onTidioChatApiReady);
} else {
  document.addEventListener("tidioChat-ready", onTidioChatApiReady);
}

var chatBtnFn = () => {
  document.getElementById("chat_btn").addEventListener("click", function(){
    window.tidioChatApi.show();
    window.tidioChatApi.open();
  });
}
chatBtnFn()
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/gh/metowolf/MetingJS@1.2/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/tororo.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>