{"meta":{"title":"Serein's blog","subtitle":"","description":"热爱大前端并怀揣着梦想","author":"Serein","url":"https://serein.icu","root":"/"},"pages":[{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://serein.icu/categories/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2022-03-10T15:19:56.000Z","updated":"2022-03-10T15:19:55.403Z","comments":false,"path":"about/index.html","permalink":"https://serein.icu/about/index.html","excerpt":"","text":"Serein“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在不断获得了友谊和朋友时，说明你将取得 成功 。 联系我B站：爆炸吧-现充（bilibili YYDS !） QQ：1297711534 (间接性失联) 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-03-13T03:14:57.264Z","comments":true,"path":"archives/index.html","permalink":"https://serein.icu/archives/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://serein.icu/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://serein.icu/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://serein.icu/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://serein.icu/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-03-11T06:56:26.059Z","comments":false,"path":"List/movies/index.html","permalink":"https://serein.icu/List/movies/index.html","excerpt":"","text":"奥斯卡最佳动画短片《鹬》（Piper）"},{"title":"","date":"2022-03-12T03:23:13.000Z","updated":"2022-03-13T03:23:35.157Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://serein.icu/List/gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"Music-BOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-03-11T06:18:21.494Z","comments":false,"path":"List/music/index.html","permalink":"https://serein.icu/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-13T03:18:40.109Z","updated":"2022-03-13T03:18:40.109Z","comments":false,"path":"List/gallery/index.html","permalink":"https://serein.icu/List/gallery/index.html","excerpt":"","text":"壁紙 /List/gallery/wallpaper"}],"posts":[{"title":"TypeScript学习笔记","slug":"TypeScript入门学习","date":"2022-05-03T13:45:00.000Z","updated":"2022-05-03T14:10:15.675Z","comments":true,"path":"posts/13.html","link":"","permalink":"https://serein.icu/posts/13.html","excerpt":"","text":"快速入门TypeScript简介 TypeScript是JavaScript的超集。 它对JS进行了扩展，向JS中引入了类型的概念，并添加了许多新的特性。 TS代码需要通过编译器编译为JS，然后再交由JS解析器执行。 TS完全兼容JS，换言之，任何的JS代码都可以直接当成JS使用。 相较于JS而言，TS拥有了静态类型，更加严格的语法，更强大的功能；TS可以在代码执行前就完成代码的检查，减小了运行时异常的出现的几率；TS代码可以编译为任意版本的JS代码，可有效解决不同JS运行环境的兼容问题；同样的功能，TS的代码量要大于JS，但由于TS的代码结构更加清晰，变量类型更加明确，在后期代码的维护中TS却远远胜于JS。 TypeScript 开发环境搭建 下载Node.js 64位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x64.msi 32位：https://nodejs.org/dist/v14.15.1/node-v14.15.1-x86.msi 安装Node.js 使用npm全局安装typescript 进入命令行 输入：npm i -g typescript 创建一个ts文件 使用tsc对ts文件进行编译 进入命令行 进入ts文件所在目录 执行命令：tsc xxx.ts 基本类型 类型声明 类型声明是TS非常重要的一个特点 通过类型声明可以指定TS中变量（参数、形参）的类型 指定类型后，当为变量赋值时，TS编译器会自动检查值是否符合类型声明，符合则赋值，否则报错 简而言之，类型声明给变量设置了类型，使得变量只能存储某种类型的值 语法： let 变量: 类型; let 变量: 类型 = 值; function fn(参数: 类型, 参数: 类型): 类型{ ... } 自动类型判断 TS拥有自动的类型判断机制 当对变量的声明和赋值是同时进行的，TS编译器会自动判断变量的类型 所以如果你的变量的声明和赋值时同时进行的，可以省略掉类型声明 类型： 类型 例子 描述 number 1, -33, 2.5 任意数字 string ‘hi’, “hi”, hi 任意字符串 boolean true、false 布尔值true或false 字面量 其本身 限制变量的值就是该字面量的值 any * 任意类型 unknown * 类型安全的any void 空值（undefined） 没有值（或undefined） never 没有值 不能是任何值 object {name:’孙悟空’} 任意的JS对象 array [1,2,3] 任意JS数组 tuple [4,5] 元素，TS新增类型，固定长度数组 enum enum{A, B} 枚举，TS中新增类型 number let decimal: number = 6; let hex: number = 0xf00d; let binary: number = 0b1010; let octal: number = 0o744; let big: bigint = 100n; - boolean - ```typescript let isDone: boolean = false; string let color: string = \"blue\"; color = 'red'; let fullName: string = `Bob Bobbington`; let age: number = 37; let sentence: string = `Hello, my name is ${fullName}. I'll be ${age + 1} years old next month.`; - 字面量 - 也可以使用字面量去指定变量的类型，通过字面量可以确定变量的取值范围 - ```typescript let color: 'red' | 'blue' | 'black'; let num: 1 | 2 | 3 | 4 | 5; any let d: any = 4; d = 'hello'; d = true; - unknown - ```typescript let notSure: unknown = 4; notSure = 'hello'; void let unusable: void = undefined; - never - ```typescript function error(message: string): never { throw new Error(message); } object（没啥用） let obj: object = {}; - array - ```typescript let list: number[] = [1, 2, 3]; let list: Array&lt;number&gt; = [1, 2, 3]; tuple let x: [string, number]; x = [\"hello\", 10]; - enum - ```typescript enum Color { Red, Green, Blue, } let c: Color = Color.Green; enum Color { Red = 1, Green, Blue, } let c: Color = Color.Green; enum Color { Red = 1, Green = 2, Blue = 4, } let c: Color = Color.Green; 类型断言 有些情况下，变量的类型对于我们来说是很明确，但是TS编译器却并不清楚，此时，可以通过类型断言来告诉编译器变量的类型，断言有两种形式： 第一种 let someValue: unknown = \"this is a string\"; let strLength: number = (someValue as string).length; - 第二种 - ```typescript let someValue: unknown = \"this is a string\"; let strLength: number = (&lt;string&gt;someValue).length; 编译选项 自动编译文件 编译文件时，使用 -w 指令后，TS编译器会自动监视文件的变化，并在文件发生变化时对文件进行重新编译。 示例： tsc xxx.ts -w - 自动编译整个项目 - 如果直接使用tsc指令，则可以自动将当前项目下的所有ts文件编译为js文件。 - 但是能直接使用tsc命令的前提时，要先在项目根目录下创建一个ts的配置文件 tsconfig.json - tsconfig.json是一个JSON文件，添加配置文件后，只需只需 tsc 命令即可完成对整个项目的编译 - 配置选项： - include - 定义希望被编译文件所在的目录 - 默认值：[\"\\*\\*/\\*\"] - 示例： - ```json \"include\":[\"src/**/*\", \"tests/**/*\"] - 上述示例中，所有src目录和tests目录下的文件都会被编译 exclude 定义需要排除在外的目录 默认值：[“node_modules”, “bower_components”, “jspm_packages”] 示例： \"exclude\": [\"./src/hello/**/*\"] - 上述示例中，src下hello目录下的文件都不会被编译 - extends - 定义被继承的配置文件 - 示例： - ```json \"extends\": \"./configs/base\" 上述示例中，当前配置文件中会自动包含config目录下base.json中的所有配置信息 files 指定被编译文件的列表，只有需要编译的文件少时才会用到 示例： \"files\": [ \"core.ts\", \"sys.ts\", \"types.ts\", \"scanner.ts\", \"parser.ts\", \"utilities.ts\", \"binder.ts\", \"checker.ts\", \"tsc.ts\" ] - 列表中的文件都会被TS编译器所编译 - compilerOptions - 编译选项是配置文件中非常重要也比较复杂的配置选项 - 在compilerOptions中包含多个子选项，用来完成对编译的配置 - 项目选项 - target - 设置ts代码编译的目标版本 - 可选值： - ES3（默认）、ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext - 示例： - ```json \"compilerOptions\": { \"target\": \"ES6\" } - 如上设置，我们所编写的ts代码将会被编译为ES6版本的js代码 - lib - 指定代码运行时所包含的库（宿主环境） - 可选值： - ES5、ES6/ES2015、ES7/ES2016、ES2017、ES2018、ES2019、ES2020、ESNext、DOM、WebWorker、ScriptHost ...... - 示例： - ```json \"compilerOptions\": { \"target\": \"ES6\", \"lib\": [\"ES6\", \"DOM\"], \"outDir\": \"dist\", \"outFile\": \"dist/aa.js\" } - module - 设置编译后代码使用的模块化系统 - 可选值： - CommonJS、UMD、AMD、System、ES2020、ESNext、None - 示例： - ```typescript \"compilerOptions\": { \"module\": \"CommonJS\" } - outDir - 编译后文件的所在目录 - 默认情况下，编译后的js文件会和ts文件位于相同的目录，设置outDir后可以改变编译后文件的位置 - 示例： - ```json \"compilerOptions\": { \"outDir\": \"dist\" } - 设置后编译后的js文件将会生成到dist目录 - outFile - 将所有的文件编译为一个js文件 - 默认会将所有的编写在全局作用域中的代码合并为一个js文件，如果module制定了None、System或AMD则会将模块一起合并到文件之中 - 示例： - ```json \"compilerOptions\": { \"outFile\": \"dist/app.js\" } - rootDir - 指定代码的根目录，默认情况下编译后文件的目录结构会以最长的公共目录为根目录，通过rootDir可以手动指定根目录 - 示例： - ```json \"compilerOptions\": { \"rootDir\": \"./src\" } - allowJs - 是否对js文件编译 - checkJs - 是否对js文件进行检查 - 示例： - ```json \"compilerOptions\": { \"allowJs\": true, \"checkJs\": true } - removeComments - 是否删除注释 - 默认值：false - noEmit - 不对代码进行编译 - 默认值：false - sourceMap - 是否生成sourceMap - 默认值：false - 严格检查 - strict - 启用所有的严格检查，默认值为true，设置后相当于开启了所有的严格检查 - alwaysStrict - 总是以严格模式对代码进行编译 - noImplicitAny - 禁止隐式的any类型 - noImplicitThis - 禁止类型不明确的this - strictBindCallApply - 严格检查bind、call和apply的参数列表 - strictFunctionTypes - 严格检查函数的类型 - strictNullChecks - 严格的空值检查 - strictPropertyInitialization - 严格检查属性是否初始化 - 额外检查 - noFallthroughCasesInSwitch - 检查switch语句包含正确的break - noImplicitReturns - 检查函数没有隐式的返回值 - noUnusedLocals - 检查未使用的局部变量 - noUnusedParameters - 检查未使用的参数 - 高级 - allowUnreachableCode - 检查不可达代码 - 可选值： - true，忽略不可达代码 - false，不可达代码将引起错误 - noEmitOnError - 有错误的情况下不进行编译 - 默认值：false webpack 通常情况下，实际开发中我们都需要使用构建工具对代码进行打包，TS同样也可以结合构建工具一起使用，下边以webpack为例介绍一下如何结合构建工具使用TS。 步骤： 初始化项目 进入项目根目录，执行命令 npm init -y 主要作用：创建package.json文件 下载构建工具 npm i -D webpack webpack-cli webpack-dev-server typescript ts-loader clean-webpack-plugin 共安装了7个包 webpack 构建工具webpack webpack-cli webpack的命令行工具 webpack-dev-server webpack的开发服务器 typescript ts编译器 ts-loader ts加载器，用于在webpack中编译ts文件 html-webpack-plugin webpack中html插件，用来自动创建html文件 clean-webpack-plugin webpack中的清除插件，每次构建都会先清除目录 根目录下创建webpack的配置文件webpack.config.js const path = require(\"path\"); const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); const { CleanWebpackPlugin } = require(\"clean-webpack-plugin\"); module.exports = { optimization:{ minimize: false // 关闭代码压缩，可选 }, entry: \"./src/index.ts\", devtool: \"inline-source-map\", devServer: { contentBase: './dist' }, output: { path: path.resolve(__dirname, \"dist\"), filename: \"bundle.js\", environment: { arrowFunction: false // 关闭webpack的箭头函数，可选 } }, resolve: { extensions: [\".ts\", \".js\"] }, module: { rules: [ { test: /\\.ts$/, use: { loader: \"ts-loader\" }, exclude: /node_modules/ } ] }, plugins: [ new CleanWebpackPlugin(), new HtmlWebpackPlugin({ title:'TS测试' }), ] } 4. 根目录下创建tsconfig.json，配置可以根据自己需要 - ```json { \"compilerOptions\": { \"target\": \"ES2015\", \"module\": \"ES2015\", \"strict\": true } } 修改package.json添加如下配置 { ...略... \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\", \"build\": \"webpack\", \"start\": \"webpack serve --open chrome.exe\" }, ...略... } 6. 在src下创建ts文件，并在并命令行执行```npm run build```对代码进行编译，或者执行```npm start```来启动开发服务器 ## Babel - 经过一系列的配置，使得TS和webpack已经结合到了一起，除了webpack，开发中还经常需要结合babel来对代码进行转换以使其可以兼容到更多的浏览器，在上述步骤的基础上，通过以下步骤再将babel引入到项目中。 1. 安装依赖包： - ```npm i -D @babel/core @babel/preset-env babel-loader core-js``` - 共安装了4个包，分别是： - @babel/core - babel的核心工具 - @babel/preset-env - babel的预定义环境 - @babel-loader - babel在webpack中的加载器 - core-js - core-js用来使老版本的浏览器支持新版ES语法 2. 修改webpack.config.js配置文件 - ```javascript ...略... module: { rules: [ { test: /\\.ts$/, use: [ { loader: \"babel-loader\", options:{ presets: [ [ \"@babel/preset-env\", { \"targets\":{ \"chrome\": \"58\", \"ie\": \"11\" }, \"corejs\":\"3\", \"useBuiltIns\": \"usage\" } ] ] } }, { loader: \"ts-loader\", } ], exclude: /node_modules/ } ] } ...略... 如此一来，使用ts编译后的文件将会再次被babel处理，使得代码可以在大部分浏览器中直接使用，可以在配置选项的targets中指定要兼容的浏览器版本。","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://serein.icu/categories/TypeScript/"}],"tags":[{"name":"TS","slug":"TS","permalink":"https://serein.icu/tags/TS/"}]},{"title":"Echarts入门","slug":"echart","date":"2022-04-27T01:38:00.000Z","updated":"2022-04-27T14:04:56.155Z","comments":true,"path":"posts/12.html","link":"","permalink":"https://serein.icu/posts/12.html","excerpt":"","text":"Echarts入门详细教程请查阅Echarts官网 入门案例：销售柱状图 &lt;!-- 引入echarts依赖包 --&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/echarts/5.1.2/echarts.js\"&gt;&lt;/script&gt; *{ margin: 0; padding: 0; } div{ width: 800px; height: 400px; } &lt;!-- 准备一个容器：容器就是显示图标区域 --&gt; &lt;div&gt;&lt;/div&gt; //基于准备好的DOM初始化echarts实例 let dom = document.querySelector('div'); //创建echarts实例 let mycharts = echarts.init(dom); //指定图表的配置项与数据 mycharts.setOption({ //图表的标题 title:{ //主标题的设置 text:'数据可视化', //子标题 subtext:\"echarts基本使用\", //主标题的颜色 textStyle:{ color:'black' }, //设置标题位置 left:'center' }, //x轴的配置项 xAxis:{ //数据 data:[\"衣服\",'直播','游戏','电影'] }, //y轴的配置项 yAxis:{ //显示Y轴的线 axisLine:{ show:true }, //显示Y轴刻度 axisTick:{ show:true } }, //系列的设置：绘制什么样类型的图表、数据的展示在这里设置 series:[ { //图表类型的设置 type:\"bar\", //图表的数据 bar柱状图 line折线图 pie饼图 data:[10,20,30,40], color:'#d53a35' } ] }); 思考：ECharts 的绘图流程是怎样的？1. 引入 js 库2. 编写渲染容器 DOM，添加 width 和 height 样式属性3. 获取渲染 DOM 对象4. 初始化 ECharts 对象5. 编写 option 参数6. 调用 setOption 完成渲染 进阶案例：多 ECharts 实例 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;echarts展示多个图表&lt;/title&gt; &lt;!-- 引入echarts依赖包 --&gt; &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/echarts/5.1.2/echarts.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart, #chart2{ width: 700px; height: 300px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备一个容器：容器就是显示图标区域 --&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;div id=\"chart2\"&gt;&lt;/div&gt; &lt;script&gt; //基于准备好的DOM初始化echarts实例 const chartDom = document.getElementById('chart') const chartDom2 = document.getElementById('chart2') //创建echarts实例 const chart = echarts.init(chartDom) const chart2 = echarts.init(chartDom2) //指定图表的配置项与数据 chart.setOption({ //x轴的配置项 xAxis: { type: 'category', boundaryGap: false, data: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'] }, //y轴的配置项 yAxis: { //显示Y轴的线 axisLine: { show: true }, //显示Y轴刻度 axisTick: { show: true } }, //系列的设置：绘制什么样类型的图表、数据的展示在这里设置 series: [ { //图表类型的设置 type: 'line', //图表的数据 bar柱状图 line折线图 pie饼图 data: [820, 932, 901, 934, 1290, 1330, 1320], areaStyle: {} } ] }); chart2.setOption({ // 图例组件 legend: { data: ['高度(km)与气温(°C)变化关系'], top: '20' }, //提示框组件 tooltip: { trigger: 'axis', formatter: 'Temperature : &lt;br/&gt;{b}km : {c}°C' }, // 直角坐标系内绘图网格，单个 grid 内最多可以放置上下两个 X 轴，左右两个 Y 轴 grid: { left: '3%', right: '4%', bottom: '3%', containLabel: true }, xAxis: { type: 'value', axisLine: { show: true }, axisTick: { show: true }, axisLabel: { formatter: '{value} °C' } }, yAxis: { type: 'category', axisLine: { onZero: false }, axisLabel: { formatter: '{value} km' }, boundaryGap: false, data: ['0', '10', '20', '30', '40', '50', '60', '70', '80'] }, series: [{ name: '高度(km)与气温(°C)变化关系', type: 'line', smooth: true, lineStyle: { width: 3, shadowColor: 'rgba(0,0,0,0.4)', shadowBlur: 10, shadowOffsetY: 10 }, data: [15, -50, -56.5, -46.5, -22.1, -2.5, -27.7, -55.7, -76.5] }] }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; Echarts基本概念ECharts 基本概念: 系列系列（series）是指：一组数值映射成对应的图 案例：多系列混合 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart { width: 800px; height: 400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;script&gt; const chartDom = document.getElementById('chart') const chart = echarts.init(chartDom) const option = { xAxis: { data: ['一季度', '二季度', '三季度', '四季度'] }, yAxis: {}, series: [{ type: 'pie', center: ['65%', 60], radius: 35, data: [{ name: '分类1', value: 50 }, { name: '分类2', value: 60 }, { name: '分类3', value: 55 }, { name: '分类4', value: 70 }] }, { type: 'line', data: [100, 112, 96, 123] }, { type: 'bar', data: [79, 81, 88, 72] }] } chart.setOption(option) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ECharts 4.0 新特性：datasetECharts 4 开始支持了 数据集（dataset）组件用于单独的数据集声明，从而数据可以单独管理，被多个组件复用，并且可以自由指定数据到视觉的映射。这一特性能将逻辑和数据分离，带来更好的复用，并易于理解。 案例：dataset 移植 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart { width: 800px; height: 400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;script&gt; const chartDom = document.getElementById('chart') const chart = echarts.init(chartDom) const option = { xAxis: { type: 'category' }, yAxis: {}, dataset: { source: [ ['一季度', 79, 100, '分类1', 50], ['二季度', 81, 112, '分类2', 60], ['三季度', 88, 96, '分类3', 55], ['四季度', 72, 123, '分类4', 70], ] }, series: [{ type: 'pie', center: ['65%', 60], radius: 35, encode: { itemName: 3, value: 4 } }, { type: 'line', encode: { x: 0, y: 2 } }, { type: 'bar', encode: { x: 0, y: 1 } }] } chart.setOption(option) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ECharts 基本概念: 组件ECharts 中除了绘图之外其他部分，都可抽象为 「组件」。例如，ECharts 中至少有这些组件：xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）、angleAxis（极坐标系角度轴）… 案例：各种组件 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart { width: 800px; height: 400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;script&gt; const chartDom = document.getElementById('chart') const chart = echarts.init(chartDom) const option = { title: { text: '数据可视化', subtext: '慕课网数据可视化体系课' }, xAxis: { type: 'category' }, yAxis: {}, legend: { data: [{ name: '分类', // 强制设置图形为圆。 icon: 'circle', // 设置文本为红色 textStyle: { color: 'red' } }, '折线图', '柱状图'], left: 100 }, toolbox: { feature: { dataZoom: { yAxisIndex: 'none' }, restore: {}, saveAsImage: {} } }, dataZoom: [{ show: true, start: 30, end: 70 }], dataset: { source: [ ['一季度', 79, 100, '分类1', 50], ['二季度', 81, 112, '分类2', 60], ['三季度', 88, 96, '分类3', 55], ['四季度', 72, 123, '分类4', 70], ] }, grid: [{ left: 50, top: 70 }], series: [{ name: '分类', type: 'pie', center: ['65%', 60], radius: 35, encode: { itemName: 3, value: 4 } }, { name: '折线图', type: 'line', encode: { x: 0, y: 2 } }, { name: '柱状图', type: 'bar', encode: { x: 0, y: 1 } }] } chart.setOption(option) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ECharts 基本概念：定位大多数组件都提供了定位属性，我们可以采用类似 CSS absolute 的定位属性来控制组件的位置，下面这个案例可以通过修改 grid 组件定位来控制图表的位置 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart { width: 800px; height: 400px; margin-top: 10px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; top: &lt;input type=\"text\" id=\"top\"&gt; left: &lt;input type=\"text\" id=\"left\"&gt; right: &lt;input type=\"text\" id=\"right\"&gt; bottom: &lt;input type=\"text\" id=\"bottom\"&gt; &lt;/div&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;script&gt; let _left = 0 let _top = 0 let _bottom = 0 let _right = 0 const topInput = document.getElementById('top') const leftInput = document.getElementById('left') const bottomInput = document.getElementById('bottom') const rightInput = document.getElementById('right') const chartDom = document.getElementById('chart') const chart = echarts.init(chartDom) function addInputEvent(dom, key) { dom.addEventListener('input', function(e) { value = e.target.value switch(key) { case 'top': _top = value break case 'left': _left = value break case 'bottom': _bottom = value break case 'right': _right = value break } render() }) } function render() { const option = { title: { text: '数据可视化', subtext: '慕课网数据可视化体系课' }, xAxis: { type: 'category' }, yAxis: {}, dataset: { source: [ ['一季度', 79, 100, '分类1', 50], ['二季度', 81, 112, '分类2', 60], ['三季度', 88, 96, '分类3', 55], ['四季度', 72, 123, '分类4', 70], ] }, grid: [{ left: _left, top: _top, right: _right, bottom: _bottom }], series: [{ name: '折线图', type: 'line', encode: { x: 0, y: 2 } }] } chart.setOption(option) } window.onload = function() { topInput.value = _top leftInput.value = _left bottomInput.value = _bottom rightInput.value = _right addInputEvent(topInput, 'top') addInputEvent(leftInput, 'left') addInputEvent(bottomInput, 'bottom') addInputEvent(rightInput, 'right') render() } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; ECharts 基本概念：坐标系很多系列，例如 line（折线图）、bar（柱状图）、scatter（散点图）、heatmap（热力图）等等，需要运行在 “坐标系” 上。坐标系用于布局这些图，以及显示数据的刻度等等。例如 ECharts 中至少支持这些坐标系：直角坐标系、极坐标系、地理坐标系（GEO）、单轴坐标系、日历坐标系 等。其他一些系列，例如 pie（饼图）、tree（树图）等等，并不依赖坐标系，能独立存在。还有一些图，例如 graph（关系图）等，既能独立存在，也能布局在坐标系中，依据用户的设定而来。 一个坐标系，可能由多个组件协作而成。我们以最常见的直角坐标系来举例。直角坐标系中，包括有 xAxis（直角坐标系 X 轴）、yAxis（直角坐标系 Y 轴）、grid（直角坐标系底板）三种组件。xAxis、yAxis 被 grid 自动引用并组织起来，共同工作。 案例：散点图我们来看下图，这是最简单的使用直角坐标系的方式：只声明了 xAxis、yAxis 和一个 scatter（散点图系列），ECharts 会为它们创建 grid 并进行关联： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart { width: 800px; height: 400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;script&gt; const chartDom = document.getElementById('chart') const chart = echarts.init(chartDom) const option = { xAxis: {}, yAxis: {}, dataset: { source: [ [13, 44], [51, 51], [51, 32], [67, 19], [19, 33] ] }, series: [{ type: 'scatter', encode: { x: 0, y: 1 } }] } chart.setOption(option) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 案例：双坐标系再来看下图，两个 yAxis，共享了一个 xAxis。两个 series，也共享了这个 xAxis，但是分别使用不同的 yAxis，使用 yAxisIndex 来指定它自己使用的是哪个 yAxis： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart { width: 800px; height: 400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;script&gt; const chartDom = document.getElementById('chart') const chart = echarts.init(chartDom) const option = { legend: {}, tooltip: {}, xAxis: { type: 'category' }, yAxis: [{ min: 0, max: 100 }, { min: 0, max: 100 }], dataset: { source: [ ['product', '2012', '2013', '2014', '2015'], ['Matcha Latte', 41.1, 30.4, 65.1, 53.3], ['Milk Tea', 86.5, 92.1, 85.7, 83.1] ] }, series: [ { type: 'bar', seriesLayoutBy: 'row', yAxisIndex: 0 }, { type: 'line', seriesLayoutBy: 'row', yAxisIndex: 1 } ] } chart.setOption(option) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 案例：多坐标系再来看下图，一个 ECharts 实例中，有多个 grid，每个 grid 分别有 xAxis、yAxis，他们使用 xAxisIndex、yAxisIndex、gridIndex 来指定引用关系： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;script src=\"https://cdn.jsdelivr.net/npm/echarts@4.7.0/dist/echarts.min.js\"&gt;&lt;/script&gt; &lt;style&gt; #chart { width: 800px; height: 400px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"chart\"&gt;&lt;/div&gt; &lt;script&gt; const chartDom = document.getElementById('chart') const chart = echarts.init(chartDom) const option = { legend: {}, tooltip: {}, xAxis: [{ type: 'category', gridIndex: 0 }, { type: 'category', gridIndex: 1 }], yAxis: [{ gridIndex: 0 }, { gridIndex: 1 }], dataset: { source: [ ['product', '2012', '2013', '2014', '2015'], ['Matcha Latte', 41.1, 30.4, 65.1, 53.3], ['Milk Tea', 86.5, 92.1, 85.7, 83.1], ['Cheese Cocoa', 24.1, 67.2, 79.5, 86.4] ] }, grid: [{ bottom: '55%' }, { top: '55%' }], series: [ // 这几个系列会在第一个直角坐标系中，每个系列对应到 dataset 的每一行。 { type: 'bar', seriesLayoutBy: 'row' }, { type: 'bar', seriesLayoutBy: 'row' }, { type: 'bar', seriesLayoutBy: 'row' }, // 这几个系列会在第二个直角坐标系中，每个系列对应到 dataset 的每一列。 { type: 'bar', xAxisIndex: 1, yAxisIndex: 1 }, { type: 'bar', xAxisIndex: 1, yAxisIndex: 1 }, { type: 'bar', xAxisIndex: 1, yAxisIndex: 1 }, { type: 'bar', xAxisIndex: 1, yAxisIndex: 1 } ] } chart.setOption(option) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;","categories":[{"name":"Echarts","slug":"Echarts","permalink":"https://serein.icu/categories/Echarts/"}],"tags":[{"name":"Echarts","slug":"Echarts","permalink":"https://serein.icu/tags/Echarts/"}]},{"title":"Svg入门","slug":"svg","date":"2022-04-26T14:16:00.000Z","updated":"2022-04-26T14:34:27.920Z","comments":true,"path":"posts/11.html","link":"","permalink":"https://serein.icu/posts/11.html","excerpt":"","text":"svgSVG是一种基于 XML 的图像文件格式，它的英文全称为Scalable Vector Graphics，意思为可缩放的矢量图形 基本的 SVG 元素你可以深入 SVG 复杂的细节，但这对我们即将创建的图标不是必须的。以下列表涵盖了我们将用到的构建块。 &lt;svg&gt; 包裹并定义整个矢量图。&lt;svg&gt; 标签之于矢量图就如同 &lt;html&gt; 标签之于一个 web 页面。 &lt;line&gt; 创建一条直线。 &lt;polyline&gt; 创建折线。 &lt;rect&gt; 创建矩形。 &lt;circle&gt; 创建圆。 &lt;ellipse&gt; 创建圆和椭圆。 &lt;polygon&gt; 创建多边形。 &lt;path&gt; 通过指定点以及点和点之间的线来创建任意形状。 详细使用所有标签都要包裹在 &lt;svg&gt; 中使用 &lt;line&gt; &lt;!-- x1 y1 是第一个点坐标 x2 y2 是第二个点坐标 --&gt; &lt;line x1=\"\" y1=\"\" x2=\"\" y2=\"\"&gt;&lt;/line&gt; &lt;polyline&gt;&lt;!-- 依次传入点坐标，即可绘制 --&gt; &lt;polyline points=\" x1 y1 x2 y2 x3 y3 ... \"&gt;&lt;/polyline&gt; &lt;!-- 你也可以把上面的代码写成： --&gt; &lt;polyline points=\"x1 y1, x2 y2, x3 y3\"&gt;&lt;/polyline&gt; &lt;!-- 或 --&gt; &lt;polyline points=\"x1 y1 x2 y2 x3 y3\"&gt;&lt;/polyline&gt; &lt;rect&gt;&lt;!-- x y 左上角点坐标 width 宽度 height 高度 --&gt; &lt;rect x=\"\" y=\"\" width=\"\" height=\"\"&gt;&lt;/rect&gt; &lt;circle&gt;&lt;!-- cx cy 圆心点坐标 r 半径 style 样式 --&gt; &lt;circle cx='70' cy='95' r='50' style='stroke:black; fill:none'&gt;&lt;/circle&gt; &lt;ellipse&gt;&lt;!-- cx cy 圆心点坐标 rx x轴半径 ry y轴半径 --&gt; &lt;ellipse cx=\"\" cy=\"\" rx=\"\" ry=\"\" style=\"fill:black;\"&gt;&lt;/ellipse&gt; &lt;polygon&gt;&lt;polygon points=\"x1 y1, x2 y2, x3 y3\" /&gt; &lt;path&gt;&lt;!-- M 移动到初始位置 L 画线 Z 将结束和开始点闭合 --&gt; &lt;path d=\" M x1 y1 L x2 y2 L x3 y3 L x4 y4 L x5 y5 L x6 y6 L x7 y7 Z \"&gt;&lt;/path&gt; 起始文件&lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Hand Coded SVG&lt;/title&gt; &lt;style&gt; html, body { height: 100%; width: 100%; background: #e9e9e9; } body { margin: 0; text-align: center; } .grid { width: 750px; height: 500px; margin: 0 auto; padding-top: 100px; padding-left: 100px; background-image: url('grid.png'); position: relative; } .grid::before { content: \"\"; border-left: 1px solid #7c7cea; position: absolute; top: 0; left: 100px; width: 750px; height: 600px; } .grid::after { content: \"\"; border-top: 1px solid #7c7cea; position: absolute; top: 100px; left: 0; width: 850px; height: 500px; } svg { stroke: #000; stroke-width: 5; stroke-linecap: round; stroke-linejoin: round; fill: none; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"grid\"&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 学习指南： SVG入门—如何手写SVG SVG 入门指南 Svg基本使用 * { margin: 0; padding: 0; } .box { width: 800px; height: 800px; } &lt;body&gt; &lt;!-- svg双闭合标签：默认宽度与高度300 * 150 svg绘制图形务必在svg标签内部使用绘制图形 --&gt; &lt;svg class=\"box\"&gt; &lt;!-- x1 y1第一个点的坐标 x2 y2 第二个点的坐标 --&gt; &lt;line x1=\"100\" y1=\"100\" x2=\"200\" y2=\"200\" stroke=\"red\"&gt;&lt;/line&gt; &lt;line x1=\"100\" y1=\"200\" x2=\"200\" y2=\"100\" stroke=\"red\"&gt;&lt;/line&gt; &lt;!-- 绘制折线:可以多个点，多个点的时候，最好带有逗号 --&gt; &lt;polyline points=\"300 300, 50 100, 120 400,20,20\" fill-opacity=\"0\" stroke=\"cyan\"&gt;&lt;/polyline&gt; &lt;!-- 绘制矩形 --&gt; &lt;!-- fill属性：设置填充颜色的 fill-opacity设置填充颜色的透明度 stroke：线的颜色 --&gt; &lt;rect x=\"400\" y=\"400\" width=\"150\" height=\"50\" fill=\"pink\"&gt;&lt;/rect&gt; &lt;!-- 绘制圆形 --&gt; &lt;circle cx='370' cy='95' r='50' style='stroke:yellow; fill:none'&gt;&lt;/circle&gt; &lt;!-- 绘制圆形|椭圆 --&gt; &lt;ellipse cx=\"500\" cy=\"500\" rx=\"100\" ry=\"50\" style=\"fill:black;\"&gt;&lt;/ellipse&gt; &lt;!-- 多边行 --&gt; &lt;polygon points=\"600 100, 300 400, 750 100\" stroke=\"red\" fill-opacity=\"0\" /&gt; &lt;!-- 绘制任意图形 --&gt; &lt;path fill-opacity=\"0\" stroke=\"green\" d=\" M 10 10 L 20 400 L 30 120 L 40 66 L 50 99 L 60 120 L 70 99 Z \"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/body&gt;","categories":[{"name":"Svg","slug":"Svg","permalink":"https://serein.icu/categories/Svg/"}],"tags":[{"name":"Svg","slug":"Svg","permalink":"https://serein.icu/tags/Svg/"}]},{"title":"Canvas入门","slug":"canvas","date":"2022-04-26T07:22:00.000Z","updated":"2022-04-26T15:14:19.223Z","comments":true,"path":"posts/10.html","link":"","permalink":"https://serein.icu/posts/10.html","excerpt":"","text":"canvascanvas 是 HTML5 的新特性，它允许我们使用 canvas 元素在网页上通过 JavaScript 绘制图像。 canvas标签&lt;canvas&gt; 标签只是图形容器，相当于一个画布，canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成，相当于使用画笔在画布上画画。 注意：必须指定宽高 &lt;canvas id=\"charts\" width=\"800\" height=\"400\"&gt;&lt;/canvas&gt; getContext()context 是一个封装了很多绘图功能的对象，我们在页面中创建一个 canvas 标签之后，首先要使用 getContext() 获取 canvas 的上下文环境，目前 getContext() 的参数只有 2d，暂时还不支持 3d getContext(\"2d\") 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 const canvas = document.getElementById('charts'); const context = canvas.getContext('2d'); 绘制线段 moveTo(x, y)：把路径移动到画布中的指定点，不创建线条 lineTo(x, y)：添加一个新点，然后在画布中创建从该点到最后指定点的线条context.strokeStyle = 'yellowgreen'; context.moveTo(0, 0); context.lineTo(100, 100); context.stroke(); 绘制矩形 fillRect(x, y, width, height) 绘制填充颜色的矩形 strokeRect(x, y, width, height) 绘制线条的矩形 context.fillStyle = \"pink\"; context.strokeStyle = \"darkred\"; context.fillRect(0, 0, 100, 100); context.strokeRect(120, 0, 100, 100); 绘制圆形 arc(x, y, radius, starAngle, endAngle, anticlockwise) x : 圆心的 x 坐标 y：圆心的 y 坐标 radius ： 半径 starAngle ：开始角度 endAngle：结束角度 anticlockwise ：是否逆时针（true）为逆时针，(false)为顺时针 context.beginPath(); context.arc(300, 350, 100, 0, Math.PI * 2, true); //不关闭路径路径会一直保留下去 context.closePath(); context.fillStyle = 'rgba(0,255,0,0.25)'; context.fill(); // 或 // context.stroke(); // 此时就会有问题 清除路径清除绘画的路径，多个图形就不会连接在一起 context.beginPath() context.closePath() 清除矩形区域当在一个画布反复绘制图形，需要将上一次的图形清空 clearRect(x, y, width, height) 绘制文字 fillText(text, x, y, maxWidth) 推荐：一个少女心满满的例子带你入门 Canvas 实操练习绘制线段 * { margin: 0; padding: 0; } canvas { border: 1px solid black; } &lt;body&gt; &lt;!-- canvas画布:是HTML5中新增的一个特性，双闭合标签 --&gt; &lt;!-- canvas标签默认宽度与高度 300 * 150 --&gt; &lt;!-- 浏览器认为canvas标签是一张图片 --&gt; &lt;!-- 给canvas画布添加文本内容没有任何意义 --&gt; &lt;!-- 给canvas标签添加子节点没有任何意义的 --&gt; &lt;!-- 你想操作canvas画布：画布当中绘制图形、显示一个文字，都必须通过JS完成 --&gt; &lt;!-- canvas标签的w|h务必通过canvas标签属性width|height设置 --&gt; &lt;!-- 切记不能通过样式去设置画布的宽度与高度 --&gt; &lt;canvas width=\"600\" height=\"400\"&gt;&lt;/canvas&gt; &lt;/body&gt; //canvas标签任何操作务必通过JS完成 //通过JS当中\"笔\"去完成 let canvas = document.querySelector('canvas'); //获取画布的笔【上下文】 let ctx = canvas.getContext('2d'); //绘制线段:绘制线段的起点的设置 ctx.moveTo(100,100); //其他点的设置：可以有多个 ctx.lineTo(100,200); ctx.lineTo(200,100); //设置图形的填充的颜色 ctx.fillStyle = \"red\"; ctx.fill(); //设置线段的颜色与宽度 ctx.strokeStyle = \"purple\"; ctx.lineWidth=\"20\" //可以设置起点与最终的结束点连接在一起 ctx.closePath(); //stroke方法绘制线段 ctx.stroke(); 绘制矩形 * { margin: 0; padding: 0; } canvas { border: 1px solid black; } &lt;body&gt; &lt;canvas width=\"600\" height=\"400\"&gt;&lt;/canvas&gt; &lt;/body&gt; //获取DOM节点 let canvas = document.querySelector('canvas'); //获取上下文 let ctx = canvas.getContext('2d'); //绘制矩形第一种方式:参数为x、y、w、h //这种的矩形没有办法设置填充颜色 ctx.strokeRect(100,200,100,200); //第二种方式绘制矩形 //填充颜色可以替换 //绘制图形之前设置填充颜色 ctx.fillStyle = 'skyblue'; ctx.fill(); //可不写 ctx.fillRect(300,200,100,200); 绘制圆形 * { margin: 0; padding: 0; } canvas { border: 1px solid black; } &lt;body&gt; &lt;canvas width=\"600\" height=\"400\"&gt;&lt;/canvas&gt; &lt;/body&gt; //获取DOM let canvas = document.querySelector('canvas'); //获取上下文 let ctx = canvas.getContext('2d'); //绘制圆形 ctx.beginPath(); //绘制圆形的方法：x、y,r,起始弧度、结束的弧度,是否逆时针绘制 ctx.arc(100,100,50,0,2 * Math.PI,true); ctx.closePath(); //设置填充颜色 ctx.fillStyle = 'red'; ctx.fill(); //绘制圆形 ctx.stroke(); //绘制一个圆弧 ctx.beginPath(); ctx.arc(200,200,50,0,1,true); ctx.stroke(); 清除画布与绘制文字 * { margin: 0; padding: 0; } canvas { border: 1px solid black; } &lt;body&gt; &lt;canvas width=\"600\" height=\"400\"&gt;&lt;/canvas&gt; &lt;/body&gt; //获取节点 let canvas = document.querySelector('canvas'); //获取上下文-笔 let ctx = canvas.getContext('2d'); //绘制矩形 ctx.fillRect(100,200,100,200); //清除画布-整个画布被清除 //ctx.clearRect(0,0,600,400); //清除部分画布 ctx.clearRect(100,200,50,100); //设置文字大小 ctx.font=\"20px 微软雅黑\"; ctx.fillStyle ='red'; //绘制文字 ctx.fillText(\"数据可视化\",50,20); 案例：绘制一个柱状图 *{ margin: 0; padding: 0; } canvas{ border: 1px solid red; } &lt;body&gt; &lt;canvas width=\"800\" height=\"420\"&gt;&lt;/canvas&gt; &lt;/body&gt; //获取节点 let canvas = document.querySelector('canvas'); //获取上下文 let ctx = canvas.getContext('2d'); //绘制文本--左上角的文本 ctx.font=\"16px 微软雅黑\"; ctx.fillText('数据可视化',50,80); //绘制线段 ctx.moveTo(100,100); ctx.lineTo(100,400); ctx.lineTo(700,400); ctx.stroke(); //绘制其他的线段 ctx.moveTo(100,100); ctx.lineTo(700,100); ctx.fillText('150',70,110); ctx.moveTo(100,160); ctx.lineTo(700,160); ctx.fillText('120',70,170); ctx.moveTo(100,220); ctx.lineTo(700,220); ctx.fillText('90',70,230); ctx.moveTo(100,280); ctx.lineTo(700,280); ctx.fillText('60',70,290); ctx.moveTo(100,340); ctx.lineTo(700,340); ctx.fillText('30',70,350); ctx.fillText('0',70,400); ctx.stroke(); //绘制水平轴底部的线段 ctx.moveTo(250,400); ctx.lineTo(250,410); //底部的文字 ctx.fillText('食品',170,415); ctx.moveTo(400,400); ctx.lineTo(400,410); ctx.fillText('数码',310,415); ctx.moveTo(550,400); ctx.lineTo(550,410); ctx.fillText('服饰',450,415); ctx.fillText('箱包',600,415); ctx.stroke(); //绘制矩形 ctx.fillStyle = 'red'; ctx.fillRect(120,200,100,200) ctx.fillRect(270,160,100,240) ctx.fillRect(420,220,100,180) ctx.fillRect(570,100,100,300)","categories":[{"name":"Canvas","slug":"Canvas","permalink":"https://serein.icu/categories/Canvas/"}],"tags":[{"name":"Canvas","slug":"Canvas","permalink":"https://serein.icu/tags/Canvas/"}]},{"title":"JavaScript中的浅拷贝与深拷贝","slug":"浅拷贝与深拷贝","date":"2022-04-14T09:30:00.000Z","updated":"2022-04-17T02:40:53.050Z","comments":true,"path":"posts/9.html","link":"","permalink":"https://serein.icu/posts/9.html","excerpt":"","text":"为什么有深拷贝和浅拷贝？这个要从js中的数据类型说起，js中数据类型分为基本数据类型和引用数据类型。基本类型值指的是那些保存在栈内存中的简单数据段，即这种值是完全保存在内存中的一个位置。包含Number，String，Boolean，Null，Undefined ，Symbol。 引用类型值指的是那些保存在堆内存中的对象，所以引用类型的值保存的是一个指针，这个指针指向存储在堆中的一个对象。除了上面的 6 种基本数据类型外，剩下的就是引用类型了，统称为 Object 类型。细分的话，有：Object 类型、Array 类型、Date 类型、RegExp 类型、Function 类型 等。 正因为引用类型的这种机制， 当我们从一个变量向另一个变量复制引用类型的值时，实际上是将这个引用类型在栈内存中的引用地址复制了一份给新的变量，其实就是一个指针。因此当操作结束后，这两个变量实际上指向的是同一个在堆内存中的对象，改变其中任意一个对象，另一个对象也会跟着改变。 因此深拷贝和浅拷贝只发生在引用类型中。简单来说他们的区别在于：层次： 浅拷贝：只会将对象的各个属性进行依次复制，并不会进行递归复制，也就是说只会赋值目标对象的第一层属性。 深拷贝不同于浅拷贝，它不只拷贝目标对象的第一层属性，而是递归拷贝目标对象的所有属性。 是否开辟新的栈： 浅拷贝：对于目标对象第一层为基本数据类型的数据，就是直接赋值，即「传值」；而对于目标对象第一层为引用数据类型的数据，就是直接赋存于栈内存中的堆内存地址,即「传址」,并没有开辟新的栈，也就是复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变， 深拷贝：深拷贝复制则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。 浅拷贝赋值与浅拷贝当把一个对象赋值给一个新的变量时，赋的对象是该对象在栈中的地址，而不是堆中的数据。也就是新旧两个对象指的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，两个对象联动的会一起改变。 var obj1 = { 'name' : 'zhangsan', 'language' : [1,[2,3],[4,5]], }; var obj2 = obj1; obj2.name = \"lisi\"; obj2.language[1] = [\"二\",\"三\"]; console.log('obj1',obj1) console.log('obj2',obj2) 浅拷贝是按位拷贝对象，它会创建一个新对象，对原有对象的成员进行依次拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是引用类型，拷贝的就是内存地址。因此如果新对象中的某个对象成员改变了地址，就会影响到原有的对象。 //手写浅拷贝 function shallowCopy(obj1) { let obj2 = Array.isArray(obj1) ? [] : {} for (let i in obj1) { obj2[i] = obj1[i] } return obj2 } var obj1 = { 'name' : 'zhangsan', 'language' : [1,[2,3],[4,5]], }; var obj2 = shallowCopy(obj1); obj2.name = \"lisi\"; obj2.language[1] = [\"二\",\"三\"]; console.log('obj1',obj1) console.log('obj2',obj2) 浅拷贝的实现1. Object.assign()Object.assign() 方法可以把源对象自身的任意多个的可枚举属性拷贝给目标对象，然后返回目标对象，但是Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。此方法对于Array和Object均可适用。注意： ES6扩展运算符与其相似，只是一个浅拷贝，仅对引用类型数据的第一层进行了拷贝，而倘若再深的层次就不会进行拷贝 var obj1 = { 'name' : 'zhangsan', 'language' : [1,[2,3],[4,5]], }; var obj2 = Object.assign({}, obj1); obj2.name = \"lisi\"; obj2.language[1] = [\"二\",\"三\"]; console.log('obj1',obj1) console.log('obj2',obj2) 2. Array.prototype.concat()和Array.prototype.slice()Array.prototype.concat()和Array.prototype.slice()均为Array原型上的方法，只适用于Array。 var arr1 = [1,3,{ user: 'aaa' }] var arr2 = arr1.concat(); arr2[0] = '一'; arr2[2].user = 'AAA'; console.log('arr1',arr1) console.log('arr2',arr2) var arr1 = [1,3,{ user: 'aaa' }] var arr2 = arr1.slice(); arr2[0] = '一'; arr2[2].user = 'AAA'; console.log('arr1',arr1) console.log('arr2',arr2) 补充说明： Array的slice和contact方法都不会修改原数组，而是会返回一个对原数组进行浅拷贝的新数组。这两种方法同Object.assign()一样，都是对第一层属性依次拷贝，如果第一层的属性是基本数据类型，就拷贝值；如果是引用数据类型，就拷贝内存地址。 深拷贝在计算机中开辟了一块新的内存地址用于存放复制的对象。（对属性中所有引用类型的值，遍历到是基本类型的值为止。 ） 深拷贝实现方式1. JSON.parse(JSON.stringify())原理： 用JSON.stringify()将对象转成字符串，再用JSON.parse()把字符串解析成对象。 var obj1 = { 'name' : 'zhangsan', 'language' : [1,[2,3],[4,5]], }; var obj2 = JSON.parse(JSON.stringify(obj1)); obj2.name = \"lisi\"; obj2.language[1] = [\"二\",\"三\"]; console.log('obj1',obj1) console.log('obj2',obj2) 缺点： 这种方法可以实现数组和对象和基本数据类型的深拷贝，但不能处理函数。因为JSON.stringify()方法是将一个javascript值转换我一个JSON字符串，不能接受函数。其他影响如下： 如果对象中有时间对象，那么用该方法拷贝之后的对象中，时间是字符串形式而不是时间对象如果对象中有RegExp、Error对象，那么序列化的结果是空 如果对象中有函数或者undefined，那么序列化的结果会把函数或undefined丢失 如果对象中有NAN、infinity、-infinity，那么序列化的结果会变成null JSON.stringfy（）只能序列化对象的可枚举自有属性，如果对象中有是构造函数生成的，那么拷贝后会丢弃对象的constructor 如果对象中存在循环引用也无法正确实现深拷贝 2. 手写深拷贝函数 function deepCopy(obj){ var result= Array.isArray(obj) ? [] : {} if (obj &amp;&amp; typeof(obj) === 'object') { for (let i in obj) { if (obj.hasOwnProperty(i)){ // 思考：这句是否有必要？ if (obj[i] &amp;&amp; typeof(obj[i]) === 'object') { result[i] = deepCopy(obj[i]) } else { result[i] = obj[i] } } } } return result } var obj1 = { a: 1, b: { c: 2 } }; var obj2 = deepCopy(obj1); obj2.a = '一'; obj2.b.c = '二' console.log('obj1', obj1) console.log('obj2', obj2) obj.hasOwnProperty(prop)用来判断obj这个对象中是否含有prop这个属性，返回布尔值，有则true，没有则false 以上有个缺陷：当遇到两个互相引用的对象时，会出现死循环的情况，从而导致爆栈。为了避免相互引用的对象导致死循环的情况，则应该在遍历的时候判断是否互相引用。 3. 函数库也可以使用一些函数库，比如函数库lodash，也有提供_.cloneDeep用来做深拷贝； var _ = require('lodash'); var obj1 = { a: 1, b: { f: { g: 1 } }, c: [1, 2, 3] }; var obj2 = _.cloneDeep(obj1); console.log(obj1.b.f === obj2.b.f); // false 总结","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://serein.icu/categories/JavaScript/"}],"tags":[{"name":"浅拷贝与深拷贝","slug":"浅拷贝与深拷贝","permalink":"https://serein.icu/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"}]},{"title":"Vue组件通信总结","slug":"Vue组件通信总结","date":"2022-04-09T08:20:00.000Z","updated":"2022-04-10T06:55:42.387Z","comments":true,"path":"posts/8.html","link":"","permalink":"https://serein.icu/posts/8.html","excerpt":"","text":"Vue组件通信总结props使用场景：[父子通信] 注意事项：如果父组件给子组件传递数据（函数），本质其实是子组件给父组件传递数据如果父组件给子组件传递的数据（非函数），本质就是父组件给子组件传递数据 接收数据：第一种方式（只接收）：props : [‘name’]第二种方式（限制类型）：props : {name:String}第三种方式（限制类型、限制必要性、指定默认值）： props:{ name:{ type:String, //类型 required:true, //必要性 default:'老王' //默认值 } } 路由的props配置​作用：让路由组件更方便的收到参数 { name:'xiangqing', path:'detail/:id', component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 props:{a:900} //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件 props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props(route){ return { id:route.query.id, title:route.query.title } } } 自定义事件使用场景：[子组件给父组件传递数据]$on 与 $emit 全局事件总线$bus使用场景：[万能]Vue.prototype.$bus = this pubsub.js（消息订阅与发布）在React框架中使用较多，在Vue中基本不用使用场景：[万能] Vuex（使用场景较多）使用场景：[万能] webStorage 存储内容大小一般支持5MB左右（不同浏览器可能还不一样）浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 插槽使用场景：[ 父子组件间通信（一般是HTML结构）]插槽官方链接 默认插槽 具名插槽 作用域插槽：子组件的数据来源于父组件，但是子组件决定不了自身结构与外观。&lt;template&gt; &lt;div&gt; &lt;h2&gt;效果一: 显示TODO列表时, 已完成的TODO为绿色&lt;/h2&gt; &lt;List :todos=\"todos\"&gt; &lt;!-- 书写template --&gt; &lt;template slot-scope=\"todo\"&gt; &lt;h5 :style=\"{color:todo.todo.isComplete?'green':'black'}\"&gt;{{todo.todo.text}}&lt;/h5&gt; &lt;/template&gt; &lt;/List&gt; &lt;List :todos=\"todos\"&gt; &lt;!-- 书写template --&gt; &lt;template slot-scope=\"todo\"&gt; &lt;a :style=\"{color:todo.todo.isComplete?'green':'black'}\"&gt;{{todo.todo.text}}&lt;/a&gt; &lt;/template&gt; &lt;/List&gt; &lt;hr&gt; &lt;h2&gt;效果二: 显示TODO列表时, 带序号, TODO的颜色为蓝绿搭配&lt;/h2&gt; &lt;List1 :data=\"todos\"&gt; &lt;template slot-scope=\"{row,index}\"&gt; &lt;h1 :style=\"{color:row.isComplete?'green':'hotpink'}\"&gt;索引值{{index}}---------{{row.text}}&lt;/h1&gt; &lt;/template&gt; &lt;/List1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/ecmascript-6\"&gt; //子组件 import List from './List' import List1 from './List1' export default { name: 'ScopeSlotTest', data () { return { todos: [ {id: 1, text: 'AAA', isComplete: false}, {id: 2, text: 'BBB', isComplete: true}, {id: 3, text: 'CCC', isComplete: false}, {id: 4, text: 'DDD', isComplete: true}, ] } }, components: { List, List1 } } &lt;/script&gt; &lt;template&gt; &lt;ul&gt; &lt;li v-for=\"(todo,index) in todos\" :key=\"index\"&gt; &lt;!-- 坑：熊孩子挖到坑，父亲填坑 --&gt; &lt;!-- 数据来源于父亲：但是子组件决定不了结构与外观 --&gt; &lt;!-- :todo是作用域插槽子组件数据回传父组件的方式，不是props传递数据，父组件用slot-scope接收 --&gt; &lt;slot :todo=\"todo\"&gt;&lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; export default { name:&nbsp;'List', props: { todos: Array } } &lt;/script&gt; &lt;template&gt; &lt;ul&gt; &lt;li v-for=\"(todo,index) in data\" :key=\"index\"&gt; &lt;!-- 坑：熊孩子挖到坑，父亲填坑 --&gt; &lt;!-- 数据来源于父亲：但是子组件决定不了结构与外网--&gt; &lt;slot :row=\"todo\" :index=\"index \"&gt;&lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;script&gt; export default { name:&nbsp;'List1', props: { data: Array } } &lt;/script&gt; 效果图 事件相关的深入学习事件：第一种原生DOM事件，第二种自定义事件。组件绑定原生DOM事件，并非原生DOM事件，而是所谓的自定义事件。如果你想把自定义事件变为原生DOM事件，需要加上修饰符.native修饰这个修饰符（Vue3弃用），可以把自定义事件【名字：原生DOM类型的】变为原生DOM事件， &lt;template&gt; &lt;div&gt; &lt;h1&gt;EventTest组件&lt;/h1&gt; &lt;!-- 原生DOM事件 --&gt; &lt;button @click=\"handler\"&gt;原生btn按钮&lt;/button&gt; &lt;!-- 使用Event1组件：底下这个组件 @click.native 原生DOM事件，利用事件的委派--&gt; &lt;Event1 @click.native=\"handler1\"&gt;&lt;/Event1&gt; &lt;hr/&gt; &lt;!-- 自定义事件对于原生DOM没有任何意义 --&gt; &lt;!-- &lt;button @erha=\"handler3\"&gt; 原生的btn&lt;/button&gt; --&gt; &lt;Event2 @click=\"handler2\" @xxx=\"handler2\"&gt;&lt;/Event2&gt; &lt;!-- 表单元素 color:选取颜色 range：范围条 date：日历 week--&gt; &lt;input type=\"week\" /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/ecmascript-6\"&gt; import Event1 from './Event1.vue' import Event2 from './Event2.vue' export default { name: 'EventTest', components: { Event1, Event2, }, methods: { //原生DOM事件的回调 handler(event){ console.log(event); }, handler1(){ console.log('66666666'); }, handler2(params){ console.log(params); } } } &lt;/script&gt; &lt;template&gt; &lt;div style=\"background: #ccc; height: 80px;\"&gt; &lt;h2&gt;Event1组件&lt;/h2&gt; &lt;span&gt;其它内容&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;template&gt; &lt;div style=\"background: #ccc; height: 80px;\"&gt; &lt;h2&gt;Event2组件&lt;/h2&gt; &lt;button @click=\"$emit('click',66666)\"&gt;分发自定义click事件&lt;/button&gt;&lt;br&gt; &lt;button @click=\"$emit('xxx',77777)\"&gt;分发自定义xxx事件&lt;/button&gt;&lt;br&gt; &lt;/div&gt; &lt;/template&gt; v-model深入v-model：指令，可以收集表单数据【text、radio、checkbox、range】等等切记：v-model收集checkbox需要用数组收集v-model实现组件通信实现原理： :value与input事件实现的，而且还需要注意可以通过v-model实现父子组件数据同步 &lt;template&gt; &lt;div&gt; &lt;h2&gt;深入v-model&lt;/h2&gt; &lt;input type=\"text\" v-model=\"msg\"&gt; &lt;span&gt;{{msg}}&lt;/span&gt; &lt;br&gt; &lt;h2&gt;深入v-model原理&lt;/h2&gt; &lt;!-- 原生DOM当中是有oninput事件：当表单元素发生文本的变化的时候就会立即出发 --&gt; &lt;input type=\"text\" :value=\"msg\" @input=\" msg = $event.target.value\"/&gt; &lt;span&gt;{{msg}}&lt;/span&gt; &lt;!--深入学习v-model：实现父子组件数据同步（实现父子组件通信）--&gt; &lt;!--并非原生DOM：自定义组件 $event接收数据--&gt; &lt;!-- :value是props，父子组件通信 @input属于自定义事件 --&gt; &lt;CustomInput :value=\"msg\" @input=\"msg = $event\"&gt;&lt;/CustomInput&gt; &lt;!--简化--&gt; &lt;CustomInput v-model=\"msg\"&gt;&lt;/CustomInput&gt; &lt;hr&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/ecmascript-6\"&gt; import CustomInput from './CustomInput.vue' export default { name: 'ModelTest', data() { return { msg:\"饿了想吃饭\" } }, components: { CustomInput } } &lt;/script&gt; &lt;template&gt; &lt;div style=\"background: #ccc; height: 50px;\"&gt; &lt;h2&gt;input包装组件----{{value}}&lt;/h2&gt; &lt;input :value=\"value\" @input=\"$emit('input',$event.target.value)\"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/ecmascript-6\"&gt; export default { name: 'CustomInput', props:['value'] } &lt;/script&gt; 事件修饰符sync可以实现父子组件数据同步:money.sync：代表父组件给子组件传递props【money】，给当前子组件绑定一个自定义事件（update:money） &lt;template&gt; &lt;div&gt; 小明的爸爸现在有{{ money }}元 &lt;h2&gt;不使用sync修改符&lt;/h2&gt; &lt;!-- :money 父组件给子组件传递props @update:money 给子组件绑定的自定义事件只不过名字叫做update:money 目前现在这种操作，起始和v-model很相似，可以实现父子组件数据同步 --&gt; &lt;Child :money=\"money\" @update:money=\"money = $event\"&gt;&lt;/Child&gt; &lt;h2&gt;使用sync修改符&lt;/h2&gt; &lt;!-- :money.sync 一、父组件给子组件传递props money 二、给当前子组件绑定一个自定义事件，而且事件名称为update:money --&gt; &lt;Child :money.sync=\"money\"&gt;&lt;/Child&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/ecmascript-6\"&gt; import Child from './Child.vue' export default { name: 'SyncTest', data() { return { money: 10000 } }, components: { Child, } } &lt;/script&gt; &lt;template&gt; &lt;div style=\"background: #ccc; height: 50px;\"&gt; &lt;span&gt;小明每次花100元&lt;/span&gt; &lt;button @click=\"$emit('update:money',money - 100)\"&gt;花钱&lt;/button&gt; 爸爸还剩 {{money}} 元 &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/ecmascript-6\"&gt; export default { name: 'Child', props:['money'] } &lt;/script&gt; $attrs 与 $listeners父子组件通信$attrs： 组件实例的属性，可以获取到父亲传递的props数据（前提子组件没有通过props接受）$listeners： 组件实例的属性，可以获取到父亲传递自定义事件（对象形式呈现） &lt;template&gt; &lt;div&gt; &lt;h2&gt;自定义带Hover提示的按钮&lt;/h2&gt; &lt;!-- 当用户在使用我们封装的按钮的时候，需要向HintButton组件传递相应参数（el-button进行二次封装） --&gt; &lt;!-- @click自定义事件 --&gt; &lt;HintButton type=\"success\" icon=\"el-icon-plus\" title=\"提示按钮\" @click=\"handler\"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script type=\"text/ecmascript-6\"&gt; import HintButton from './HintButton'; export default { name: 'AttrsListenersTest', components:{ HintButton }, methods: { handler() { alert('弹弹弹'); }, }, } &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;!-- 可以巧妙利用a标签实现按钮带有提示功能 --&gt; &lt;a :title=\"title\"&gt; &lt;!-- v-bind和v-on不能简写--&gt; &lt;el-button v-bind=\"$attrs\" v-on=\"$listeners\"&gt;添加&lt;/el-button&gt; &lt;/a&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"\", props:['title'], mounted(){ //this.$attrs:可以获取到父组件传递的props数据 //对于子组件而言，父组件给的数据可以利用props接收，但是需要注意，如果子组件通过props接收的属性，在$attrs属性当中是获取不到的 console.log(this.$attrs); //$listeners，它也是组件实例自身的一个属性，它可以获取父组件给子组件传递自定义事件 console.log(this.$listeners); } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 深入mixin 如果项目当中出现很多结构相似功能，想到组件复用如果项目当中很多的组件JS业务逻辑相似，想到mixin（可以把多个组件JS部分重复、相似的地方提取复用） ref、$children 与 $parent父子组件通信ref: 如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例，可以通过实例直接调用组件的方法或访问数据 –&gt; 实现父子通信$children: 组件实例的属性，可以获取当前组件的全部的子组件【返回数组】$parent: 可以在子组件内部获取唯一的父组件【返回组件实例】 &lt;template&gt; &lt;div&gt; &lt;h2&gt;BABA有存款: {{ money }}&lt;/h2&gt; &lt;button @click=\"JieQianFromXM(100)\"&gt;找小明借钱100&lt;/button&gt;&lt;br /&gt; &lt;button @click=\"JieQianFromXH(150)\"&gt;找小红借钱150&lt;/button&gt;&lt;br /&gt; &lt;button @click=\"JieQianAll(200)\"&gt;找所有孩子借钱200&lt;/button&gt;&lt;br /&gt; &lt;button @click=\"SendInfo\"&gt;我是baba&lt;/button&gt; &lt;br /&gt; &lt;!-- ref：获取节点（组件标签） --&gt; &lt;!-- 在Vue组件中可以通过ref获取子组件，就可以进行操作子组件的数据与方法 --&gt; &lt;Son ref=\"xm\" /&gt; &lt;br /&gt; &lt;Daughter ref=\"xh\"/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Son from \"./Son\"; import Daughter from \"./Daughter\"; export default { name: \"ChildrenParentTest\", components: { Son, Daughter, }, data() { return { money: 1000, }; }, methods: { //找儿子小明借钱 JieQianFromXM(money) { //父组件的数据累加100 this.money += money; //ref可以获取真实DOM节点，当然也可以获取子组件标签（或者子组件的数据与方法） this.$refs.xm.money -= money; }, // 向女儿小红借钱 JieQianFromXH(money) { //父组件的数据累加150 this.money += money; this.$refs.xh.money -= money; }, // 找全部孩子借钱 JieQianAll(money){ this.money += 2*money; // 组件实例自身拥有一个属性$children,可以获取到当前组件的全部子组件 this.$children.forEach(item=&gt;item.money-=money); //不建议用枚举获取子组件：因为如果子组件过多,没办法确定到底是哪个子组件 // this.$children[0].money -=money; }, SendInfo(){ //ref在父组件中获取到子组件（数据+方法） this.$refs.xm.tinghua(); this.$refs.xh.tinghua(); } } }; &lt;/script&gt; 因为这里Son与Daughter子组件的method业务逻辑相似，所以这里利用mixin混入实现代码复用在ChildrenParentTest根目录下创建myMixin文件夹，添加myMixin.js //对外暴露的对象，可以放置组件复用JS业务逻辑 export default { methods: { // 听话 tinghua(){ alert('不听不听，王八念经') }, // 给爸爸钱 geiQian(money){ this.money-=money; //需要在子组件内部获取到父组件 //可以通过$parent属性获取到某一个组件的父组件，可以操作父组件的数据与方法 this.$parent.money+=money; } } } &lt;template&gt; &lt;div style=\"background: #ccc; height: 50px;\"&gt; &lt;h3&gt;儿子小明: 有存款: {{money}}&lt;/h3&gt; &lt;button @click=\"geiQian(50)\"&gt;给BABA钱: 50&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import myMixin from '@/views/Communication/ChildrenParentTest/myMixin/myMixin' export default { name:&nbsp;'Son', mixins:[myMixin], data () { return { money: 30000 } } } &lt;/script&gt; 女儿组件与儿子组件同理 &lt;template&gt; &lt;div style=\"background: #ccc; height: 50px;\"&gt; &lt;h3&gt;女儿小红: 有存款: {{money}}&lt;/h3&gt; &lt;button @click=\"geiQian(100)\"&gt;给BABA钱: 100&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import myMixin from '@/views/Communication/ChildrenParentTest/myMixin/myMixin' export default { name:&nbsp;'Daughter', mixins:[myMixin], data () { return { money: 20000 } } } &lt;/script&gt; provide / inject概念:provide / inject 是vue2.2.0新增的api, 简单来说就是父组件中通过provide来提供变量, 然后再子组件中通过inject来注入变量。注意:这里不论子组件嵌套有多深, 只要调用了inject 那么就可以注入provide中的数据，而不局限于只能从当前父组件的props属性中回去数据提示： provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。vue的provide/inject实现响应式数据监听假设有三个组件: A.vue、B.vue、C.vue 其中 C是B的子组件，B是A的子组件 &lt;template&gt; &lt;div&gt; &lt;comB&gt;&lt;/comB&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import comB from '../components/test/comB.vue' export default { name: \"A\", provide: { for: \"demo\" }, components:{ comB } } &lt;/script&gt; &lt;template&gt; &lt;div&gt; {{demo}} &lt;comC&gt;&lt;/comC&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import comC from '../components/test/comC.vue' export default { name: \"B\", inject: ['for'], data() { return { demo: this.for } }, components: { comC } } &lt;/script&gt; &lt;template&gt; &lt;div&gt; {{demo}} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"C\", inject: ['for'], data() { return { demo: this.for } } } &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"},{"name":"组件通信","slug":"组件通信","permalink":"https://serein.icu/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"}]},{"title":"尚品汇Vue项目总结","slug":"尚品汇项目总结","date":"2022-04-08T03:30:00.000Z","updated":"2022-05-03T06:19:34.529Z","comments":true,"path":"posts/7.html","link":"","permalink":"https://serein.icu/posts/7.html","excerpt":"","text":"前端Vue核心 开发一个前端模块可以概括为以下几个步骤： 写静态页面、拆分为静态组件； 发请求（API）； vuex（actions、mutations、state三连操作）； 组件获取仓库数据，动态展示； 尚品汇前台商品系统vue文件目录分析public文件夹：静态资源，webpack进行打包的时候会原封不动打包到dist文件夹中。pubilc/index.html 是一个模板文件，作用是生成项目的入口文件，webpack打包的js,css也会自动注入到该页面中。我们浏览器访问项目的时候就会默认打开生成好的index.html。 src文件夹（程序员代码文件夹）assets： 存放公用的静态资源components： 非路由组件（全局组件），其他组件放在views或者pages文件夹中App.vue： 唯一的根组件main.js： 程序入口文件，最先执行的文件 项目配置项目运行，浏览器自动打开\"scripts\": { \"serve\": \"vue-cli-service serve --open\", \"build\": \"vue-cli-service build\", \"lint\": \"vue-cli-service lint\" } 关闭eslint校验工具（不关闭会有各种规范，不按照规范就会报错）根目录下创建vue.config.js,进行配置 module.exports = { //关闭eslint lintOnSave: false } src文件夹配置别名,创建jsconfig.json用@/代替src/，exclude表示不可以使用该别名的文件 { \"compilerOptions\": { \"baseUrl\": \"./\", \"paths\": { \"@/*\": [ \"src/*\" ] } }, \"exclude\": [ \"node_modules\", \"dist\" ] } 组件页面样式组件页面的样式使用的是less样式，浏览器不识别该样式，需要下载相关依赖npm install –save less less-loader@5如果想让组件识别less样式，则在组件中设置 &lt;style scoped lang=\"less\"&gt; 清除vue页面默认的样式vue是单页面开发，我们只需要修改public下的index.html文件 &lt;link rel=\"stylesheet\" href=\"reset.css\"&gt; views/pages文件夹 创建views/pages文件夹，并创建路由组件 创建router文件夹，并创建index.js进行路由配置，最终在main.js中引入注册路由组件和非路由组件区别 非路由组件放在components中，路由组件放在pages或views中非路由组件通过标签使用，路由组件通过路由使用在main.js注册玩路由，所有的路由和非路由组件身上都会拥有$router和$route属性$router：一般进行编程式导航进行路由跳转$route：一般获取路由信息（name path params等） 路由跳转方式 声明式导航router-link标签 ,可以把router-link理解为一个a标签，它 也可以加class修饰 编程式导航 ：声明式导航能做的编程式都能做，而且还可以处理一些业务 路由传参query、params两个属性可以传递参数 query参数：不属于路径当中的一部分，类似于get请求，地址栏表现为 /search?k1=v1&amp;k2=v2query参数对应的路由信息 path: “/search”params参数：属于路径当中的一部分，需要注意，在配置路由的时候，需要占位 ,地址栏表现为 /search/v1/v2params参数对应的路由信息要修改为path: “/search/:keyword” 这里的/:keyword就是一个params参数的占位符 params传参问题1. 如何指定params参数可传可不传 如果路由path要求传递params参数,但是没有传递,会发现地址栏URL有问题，详情如下： Search路由项的path已经指定要传一个keyword的params参数，如下所示： path: “/search/:keyword”, 执行下面进行路由跳转的代码： this.$router.push({name:”Search”,query:{keyword:this.keyword}}) 当前跳转代码没有传递params参数 地址栏信息：http://localhost:8080/#/?keyword=asd 此时的地址信息少了/search 正常的地址栏信息: http://localhost:8080/#/search?keyword=asd 解决方法：可以通过改变path来指定params参数可传可不传path: “/search/:keyword?”,?表示该参数可传可不传 参考连接：https://blog.csdn.net/weixin_44867717/article/details/109773945 2. 已知params可传可不传，但是如果传递的时空串，如何解决 this.$router.push({name:”Search”,query:{keyword:this.keyword},params:{keyword:’’}}) 出现的问题和1中的问题相同,地址信息少了/search 解决方法： 加入||undefined，当我们传递的参数为空串时地址栏url也可以保持正常this.$router.push({name:”Search”,query:{keyword:this.keyword},params:{keyword:’’||undefined}}) 3. 路由组件能不能传递props数据？可以，但是只能传递params参数,具体知识为props属性参考连接：https://router.vuejs.org/zh/guide/essentials/passing-props.html 传参方法字符串形式this.$router.push(“/search/“+this.params传参+”?k=”+this.query传参) 模板字符串this.router.push(“/search/+router.push(“/search/+router.push(“/search/+{this.params传参}?k=${this.query传参}”)注意： 上面字符串的传参方法可以看出params参数和’/‘结合，query参数和？结合http://localhost:8080/#/search/asd?keyword=asd上面url中asd为params的值，keyword=asd为query传递的值。 对象（常用）this.$router.push({name:“路由名字”,params:{传参},query:{传参})以对象方式传参时，如果我们传参中使用了params，只能使用name，不能使用path，如果只是使用query传参，可以使用path 多次执行相同的push问题多次执行相同的push问题，控制台会出现警告例如：使用this.$router.push({name:‘Search’,params:{keyword:”…”||undefined}})时，如果多次执行相同的push，控制台会出现警告。 let result = this.$router.push({name:\"Search\",query:{keyword:this.keyword}}) console.log(result) 执行一次上面代码：多次执行出现警告： 原因： push是一个promise，promise需要传递成功和失败两个参数，我们的push中没有传递。方法：this.$router.push({name:‘Search’,params:{keyword:”…”||undefined}},()=&gt;{},()=&gt;{})后面两项分别代表执行成功和失败的回调函数。这种写法治标不治本，将来在别的组件中push|replace,编程式导航还是会有类似错误push是VueRouter.prototype的一个方法，在router中的index重写该方法即可(看不懂也没关系，这是前端面试题) //1、先把VueRouter原型对象的push，保存一份 let originPush = VueRouter.prototype.push; //2、重写push|replace //第一个参数：告诉原来的push，跳转的目标位置和传递了哪些参数 VueRouter.prototype.push = function (location,resolve,reject){ if(resolve &amp;&amp; reject){ originPush.call(this,location,resolve,reject) }else{ originPush.call(this,location,() =&gt; {},() =&gt; {}) } } 定义全局组件我们的三级联动组件是全局组件，全局的配置都需要在main.js中配置 //将三级联动组件注册为全局组件 import TypeNav from '@/pages/Home/TypeNav'; //第一个参数：全局组件名字，第二个参数：全局组件 Vue.component(TypeNav.name,TypeNav); 在Home组件中使用该全局组件，全局组件可以在任一页面中直接使用，不需要导入声明 &lt;template&gt; &lt;div&gt; &lt;!-- 三级联动全局组件已经注册为全局组件，因此不需要引入--&gt; &lt;TypeNav/&gt; &lt;/div&gt; &lt;/template&gt; 封装axiosaxios中文文档，包含详细信息：https://www.kancloud.cn/yunye/axios/234845在根目录下创建api文件夹，创建request.js文件 import axios from \"axios\"; //1、对axios二次封装 const requests = axios.create({ //基础路径，requests发出的请求在端口号后面会跟改baseURl baseURL:'/api', timeout: 5000, }) //2、配置请求拦截器 requests.interceptors.request.use(config =&gt; { //config内主要是对请求头Header配置 //比如添加token return config; }) //3、配置相应拦截器 requests.interceptors.response.use((res) =&gt; { //成功的回调函数 return res.data; },(error) =&gt; { //失败的回调函数 console.log(\"响应失败\"+error) return Promise.reject(new Error('fail')) }) //4、对外暴露 export default requests; 前端通过代理解决跨域问题在根目录下的vue.config.js中配置,proxy为通过代理解决跨域问题。我们在封装axios的时候已经设置了baseURL为api,所以所有的请求都会携带/api，这里我们就将/api进行了转换。如果你的项目没有封装axios，或者没有配置baseURL，建议进行配置。要保证baseURL和这里的代理映射相同，此处都为’/api’ module.exports = { // 关闭ESLINT校验工具 lintOnSave: false, devServer: { //代理服务器解决跨域 proxy: { //会把请求路径中的/api换为后面的代理服务器 '/api': { //提供数据的服务器地址 target: 'http://39.98.123.211', } }, } } webpack官网相关知识解读网站中的webpack.config.js就是vue.config.js文件 请求接口统一封装在文件夹api中创建index.js文件，用于封装所有请求将每个请求封装为一个函数，并暴露出去，组件只需要调用相应函数即可，这样当我们的接口比较多时，如果需要修改只需要修改该文件即可。如下所示： //当前模块，API进行统一管理，即对请求接口统一管理 import requests from \"@/api/request\"; //首页三级分类接口 export const reqCateGoryList = () =&gt; { return requests({ url: '/product/getBaseCategoryList', method: 'GET' }) } 当组件想要使用相关请求时，只需要导入相关函数即可，以上图的reqCateGoryList 为例: import {reqCateGoryList} from './api' //发起请求 reqCateGoryList(); nprogress进度条插件打开一个页面时，往往会伴随一些请求，并且会在页面上方出现进度条。它的原理时，在我们发起请求的时候开启进度条，在请求成功后关闭进度条，所以只需要在request.js中进行配置。 对应的request.js设置 import axios from \"axios\"; //引入进度条 import nprogress from 'nprogress'; //引入进度条样式 import \"nprogress/nprogress.css\"; //1、对axios二次封装 const requests = axios.create({ //基础路径，requests发出的请求在端口号后面会跟改baseURl baseURL:'/api', timeout: 5000, }) //2、配置请求拦截器 requests.interceptors.request.use(config =&gt; { //config内主要是对请求头Header配置 //比如添加token //开启进度条 nprogress.start() return config }) //3、配置相应拦截器 requests.interceptors.response.use((res) =&gt; { //成功的回调函数 //响应成功，关闭进度条 nprogress.done() return res.data },(error) =&gt; { //失败的回调函数 console.log(\"响应失败\"+error) return Promise.reject(new Error('fail')) }) //4、对外暴露 export default requests 可以通过修改nprogress.css文件的background来修改进度条颜色 手动引入vuex首先确保安装了vuex,根目录创建store文件夹，文件夹下创建index.js，内容如下： import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) //对外暴露store的一个实例 export default new Vuex.Store({ state:{}, mutations:{}, actions:{}, }) 如果想要使用vuex，还要再main.js中引入main.js:(1) 引入文件(2) 注册store但凡是在main.js中的Vue实例中注册的实体，在所有的组件中都会有（this.$.实体名）属性 import store from './store' new Vue({ render: h =&gt; h(App), //注册路由，此时组件中都会拥有$router $route属性 router, //注册store,此时组件中都会拥有$store store }).$mount('#app') async await使用如果我们没有封装请求api，而是直接调用axios，就不需要使用async await案例：我们将一个axios请求封装为了函数，我们在下面代码中调用了该函数： import {reqCateGoryList} from '@/api' export default { actions:{ categoryList(){ let result = reqCateGoryList() console.log(result) } } } 浏览器结果 返回了一个promise,证明这是一个promise请求，但是我们想要的是图片中的data数据。没有将函数封装前我们都会通过then()回调函数拿到服务器返回的数据，现在我们将其封装了，依然可以使用then获取数据，代码如下 actions:{ categoryList(){ let result = reqCateGoryList().then( res=&gt;{ console.log(\"res\") console.log(res) return res } ) console.log(\"result\") console.log(result) } } 结果 由于我们的promis是异步请求，我们发现请求需要花费时间，但是它是异步的，所有后面的console.log(“result”)；console.log(result)会先执行，等我们的请求得到响应后，才执行console.log(“res”)；console.log(res)，这也符合异步的原则，但是我们如果在请求下面啊执行的是将那个请求的结果赋值给某个变量，这样就会导致被赋值的变量先执行，并且赋值为undefine，因为此时promise还没有完成 所以我们引入了async await,async写在函数名前，await写在api函数前面。await含义是async标识的函数体内的并且在await标识代码后面的代码先等待await标识的异步请求执行完，再执行。这也使得只有reqCateGoryList执行完，result 得到返回值后，才会执行后面的输出操作 async categoryList(){ let result = await reqCateGoryList() console.log(\"result\") console.log(result) } 结果 vuexstate、actions、mutations、getters的辅助函数使用，当多次访问store中的上述属性时，要使用4个属性的辅助函数，可以减少代码量在使用上面的函数时，如果需要传递多个参数，需要把多个参数组合为一个对象传入(vuex是不允许多个参数分开传递的) async addOrUpdateShopCart({commit},{skuId,skuNum}){ let result = await reqAddOrUpdateShopCart(skuId,skuNum) console.log(result) if(result.data === 200){ } 辅助函数官网链接 注意：使用action时，函数的第一个参数，必须是{commit}，即使不涉及到mutations操作，也必须加上该参数，否则会报错 loadsh插件防抖和节流在进行窗口的resize、scroll，输入框内容校验等操作时，如果事件处理函数调用的频率无限制，会加重浏览器的负担，导致用户体验非常糟糕。此时我们可以采用debounce（防抖）和throttle（节流）的方式来减少调用频率，同时又不影响实际效果。安装lodash插件，该插件提供了防抖和节流的函数，我们可以引入js文件，直接调用。当然也可以自己写防抖和节流的函数lodash官网防抖函数节流函数防抖：用户操作很频繁，但是只执行一次，减少业务负担。节流：用户操作很频繁，但是把频繁的操作变为少量的操作，使浏览器有充分时间解析代码防抖和节流简述 例如：下面代码就是将changeIndex设置了节流，如果操作很频繁，限制50ms执行一次。这里函数定义采用的键值对形式。throttle的返回值就是一个函数，所以直接键值对赋值就可以，函数的参数在function中传入即可。 import {throttle} from 'lodash' methods: { //鼠标进入修改响应元素的背景颜色 //采用键值对形式创建函数，将changeIndex定义为节流函数，该函数触发很频繁时，设置50ms才会执行一次 changeIndex: throttle(function (index){ this.currentIndex = index },50), //鼠标移除触发时间 leaveIndex(){ this.currentIndex = -1 } } 编程式导航+事件委托实现路由跳转 如上图所示，三级标签列表有很多，每一个标签都是一个页面链接，我们要实现通过点击表现进行路由跳转。路由跳转的两种方法：导航式路由，编程式路由 对于导航式路由，我们有多少个a标签就会生成多少个router-link标签，这样当我们频繁操作时会出现卡顿现象。对于编程式路由，我们是通过触发点击事件实现路由跳转。同理有多少个a标签就会有多少个触发函数。虽然不会出现卡顿，但是也会影响性能。 上面两种方法无论采用哪一种，都会影响性能。我们提出一种：编程时导航+事件委派 的方式实现路由跳转。事件委派即把子节点的触发事件都委托给父节点。这样只需要一个回调函数goSearch就可以解决。 事件委派问题： 如何确定我们点击的一定是a标签呢？如何保证我们只能通过点击a标签才跳转呢？ 如何获取子节点标签的商品名称和商品id (我们是通过商品名称和商品id进行页面跳转的) 解决方法：对于问题1：为三个等级的a标签添加自定义属性date-categoryName绑定商品标签名称来标识a标签（其余的标签是没有该属性的） 对于问题2：为三个等级的a标签再添加自定义属性data-category1Id、data-category2Id、data-category3Id来获取三个等级a标签的商品id，用于路由跳转 我们可以通过在函数中传入event参数，获取当前的点击事件，通过event.target属性获取当前点击节点，再通过dataset属性获取节点的属性信息。 &lt;div class=\"all-sort-list2\" @click=\"goSearch\" @mouseleave=\"leaveIndex\"&gt; &lt;div class=\"item\" v-for=\"(c1,index) in categoryList\" v-show=\"index!==16\" :key=\"c1.categoryId\" :class=\"{cur:currentIndex===index}\"&gt; &lt;h3 @mouseenter=\"changeIndex(index)\"&gt; &lt;a :data-categoryName=\"c1.categoryName\" :data-category1Id=\"c1.categoryId\" &gt;{{c1.categoryName}}&lt;/a&gt; &lt;/h3&gt; &lt;div class=\"item-list clearfix\" :style=\"{display:currentIndex===index?'block':'none'}\"&gt; &lt;div class=\"subitem\" v-for=\"(c2,index) in c1.categoryChild\" :key=\"c2.categoryId\"&gt; &lt;dl class=\"fore\"&gt; &lt;dt&gt; &lt;a :data-categoryName=\"c2.categoryName\" :data-category2Id=\"c2.categoryId\"&gt;{{c2.categoryName}}&lt;/a&gt; &lt;/dt&gt; &lt;dd&gt; &lt;em v-for=\"(c3,index) in c2.categoryChild\" :key=\"c3.categoryId\"&gt; &lt;a :data-categoryName=\"c2.categoryName\" :data-category3Id=\"c3.categoryId\"&gt;{{c3.categoryName}}&lt;/a&gt; &lt;/em&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 注意：event是系统属性，所以我们只需要在函数定义的时候作为参数传入，在函数使用的时候不需要传入该参数。 //函数使用 &lt;div class=\"all-sort-list2\" @click=\"goSearch\" @mouseleave=\"leaveIndex\"&gt; //函数定义 goSearch(event){ console.log(event.target) } 对应的goSearrch函数 goSearch(event){ let element = event.target //html中会把大写转为小写 //获取目前鼠标点击标签的categoryname,category1id,category2id,category3id， // 通过四个属性是否存在来判断是否为a标签，以及属于哪一个等级的a标签 let {categoryname,category1id,category2id,category3id} = element.dataset //categoryname存在，表示为a标签 if(categoryname){ //category1id一级a标签 //整理路由跳转的参数 let location = {name:'Search'}//跳转路由name let query = {categoryName:categoryname}//路由参数 if(category1id){ query.category1Id = category1id }else if(category2id){ //category2id二级a标签 query.category2Id = category2id }else if(category3id){ //category3id三级a标签 query.category3Id = category3id } //整理完参数 location.query = query //路由跳转 this.$router.push(location) } } Vue路由销毁问题Vue在路由切换的时候会销毁旧路由我们在三级列表全局组件TypeNav中的mounted进行了请求一次商品分类列表数据由于Vue在路由切换的时候会销毁旧路由，当我们再次使用三级列表全局组件时还会发一次请求。如下图所示：当我们在包含三级列表全局组件的不同组件之间进行切换时，都会进行一次信息请求。 由于信息都是一样的，出于性能的考虑我们希望该数据只请求一次，所以我们把这次请求放在App.vue的mounted中。（根组件App.vue的mounted只会执行一次）注意：虽然main.js也是只执行一次，但是不可以放在main.js中。因为只有组件的身上才会有$store属性。 mock插件使用mock用来拦截前端ajax请求，返回我们自定义的数据用于测试前端接口。将不同的数据类型封装为不同的json文件，创建mockServer.js文件 banner、floor分别为轮播图和页面底部的假数据。 import Mock from 'mockjs' //webpack默认对外暴露：json、图片 import banner from './banner.json' import floor from './floor.json' //mock数据：第一个参数请求地址、第二个参：请求数据 Mock.mock(\"/mock/banner\",{code:200,data:banner}) Mock.mock(\"/mock/floor\",{code:200,data:floor}) //记得要在main.js中引入一下 import ''@/mock/mockServer vuex数据存储与使用我们会把公共的数据放在store中，然后使用时再去store中取。以我们的首页轮播图数据为例。 在轮播图组件ListContainer.vue组件加载完毕后发起轮播图数据请求。mounted() { this.$store.dispatch(\"getBannerList\") } 请求实际是在store中的actions中完成的actions:{ //获取首页轮播图数据 async getBannerList({commit}){ let result = await reqGetBannerList() if(result.code === 200){ commit(\"BANNERLIST\",result.data) } } } 获取到数据后存入store仓库，在mutations完成//唯一修改state的部分 mutations:{ BANNERLIST(state,bannerList){ state.bannerList = bannerList } } 轮播图组件ListContainer.vue组件在store中获取轮播图数据。由于在这个数据是通过异步请求获得的，所以我们要通过计算属性computed获取轮播图数据&lt;script&gt; import {mapState} from \"vuex\"; export default { name: \"index\", //主键挂载完毕，请求轮播图图片 mounted() { this.$store.dispatch(\"getBannerList\") }, computed:{ ...mapState({ bannerList: (state =&gt; state.home.bannerList) }) } } &lt;/script&gt; 总结： 只要是公共数据都会放在store中，之后的实现步骤就是上面的固定步骤。 swiper插件实现轮播图swiper官网 官网中给出了代码实例：做一个简要总结 安装swiper 在需要使用轮播图的组件内导入swpier和它的css样式 在组件中创建swiper需要的dom标签（html代码，参考官网代码） 创建swiper实例 注意： 在创建swiper对象时，我们会传递一个参数用于获取展示轮播图的DOM元素，官网直接通过class （而且这个class不能修改，是swiper的css文件自带的） 获取。但是这样有缺点：当页面中有多个轮播图时，因为它们使用了相同的class修饰的DOM，就会出现所有的swiper使用同样的数据，这肯定不是我们希望看到的。 解决方法：在轮播图最外层DOM中添加ref属性&lt;div class=\"swiper-container\" id=\"mySwiper\" ref=\"cur\"&gt; 通过ref属性值获取DOM let mySwiper = new Swiper(this.$refs.cur,{...}) &lt;!--banner轮播--&gt; &lt;div class=\"swiper-container\" id=\"mySwiper\" ref=\"cur\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" v-for=\"(carouse,index) in bannerList\" :key=\"carouse.id\"&gt; &lt;img :src=\"carouse.imgUrl\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\" &gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script&gt; //引入Swiper import Swiper from 'swiper' //引入Swiper样式 import 'swiper/css/swiper.css' &lt;/script&gt; 接下来要考虑的是什么时候去加载这个swiper，我们第一时间想到的是在mounted中创建这个实例，但是会出现无法加载轮播图片的问题。 原因： 我们在mounted中先去异步请求了轮播图数据，然后又创建的swiper实例。由于请求数据是异步的，所以浏览器不会等待该请求执行完再去创建swiper，而是先创建了swiper实例，但是此时我们的轮播图数据还没有获得，就导致了轮播图展示失败。 mounted() { //请求数据 this.$store.dispatch(\"getBannerList\") //创建swiper实例 let mySwiper = new Swiper(document.getElementsByClassName(\"swiper-container\"),{ pagination:{ el: '.swiper-pagination', clickable: true, }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, }) } 解决方法一：等我们的数据请求完毕后再创建swiper实例。只需要加一个1000ms时间延迟再创建swiper实例.。将上面代码改为： mounted() { this.$store.dispatch(\"getBannerList\") setTimeout(()=&gt;{ let mySwiper = new Swiper(document.getElementsByClassName(\"swiper-container\"),{ pagination:{ el: '.swiper-pagination', clickable: true, }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, }) },1000) }, 方法一肯定不是最好的，但是我们开发的第一要义就是实现功能，之后再完善。 解决方法二：我们可以使用watch监听bannerList轮播图列表属性，因为bannerList初始值为空，当它有数据时，我们就可以创建swiper对象 watch:{ bannerList(newValue,oldValue){ let mySwiper = new Swiper(this.$refs.cur,{ pagination:{ el: '.swiper-pagination', clickable: true, }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, }) } } 即使这样也还是无法实现轮播图，原因是，我们轮播图的html中有v-for的循环，我们是通过v-for遍历bannerList中的图片数据，然后展示。我们的watch只能保证在bannerList变化时创建swiper对象，但是并不能保证此时v-for已经执行完了。假如watch先监听到bannerList数据变化，执行回调函数创建了swiper对象，之后v-for才执行，这样也是无法渲染轮播图图片 （因为swiper对象生效的前提是html即dom结构已经渲染好了） 完美解决方案： 使用watch+this.$nextTick()官方介绍：this. $nextTick它会将回调延迟到下次 DOM 更新循环之后执行（循环就是这里的v-for）个人理解： 无非是等我们页面中的结构都有了再去执行回调函数 完整代码 &lt;template&gt; &lt;!--列表--&gt; &lt;div class=\"list-container\"&gt; &lt;div class=\"sortList clearfix\"&gt; &lt;div class=\"center\"&gt; &lt;!--banner轮播--&gt; &lt;div class=\"swiper-container\" id=\"mySwiper\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" v-for=\"(carouse,index) in bannerList\" :key=\"carouse.id\"&gt; &lt;img :src=\"carouse.imgUrl\" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\" &gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //引入Swiper import Swiper from 'swiper' //引入Swiper样式 import 'swiper/css/swiper.css' import {mapState} from \"vuex\"; export default { name: \"index\", //主键挂载完毕，ajax请求轮播图图片 mounted() { this.$store.dispatch(\"getBannerList\") }, computed:{ ...mapState({ //从仓库中获取轮播图数据 bannerList: (state) =&gt; {return state.home.bannerList} }) }, watch:{ bannerList(newValue,oldValue){ //this.$nextTick()使用 this.$nextTick(()=&gt;{ let mySwiper = new Swiper(document.getElementsByClassName(\"swiper-container\"),{ pagination:{ el: '.swiper-pagination', clickable: true, }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, }) }) } } } &lt;/script&gt; 注意： 之前我们在学习watch时，一般都是监听的定义在data中的属性，但是我们这里是监听的computed中的属性，这样也是完全可以的，并且如果你的业务数据也是从store中通过computed动态获取的，也需要watch监听数据变化执行相应回调函数，完全可以模仿上面的写法。 将轮播图模块提取为全局组件需要注意的是我们要把定义swiper对象放在watch中执行，并且还要设置immediate：true属性，这样可以实现，无论数据有没有变化，上来立即监听一次。 全局组件Carousel代码 &lt;template&gt; &lt;div class=\"swiper-container\" ref=\"cur\" id=\"floor1Swiper\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" v-for=\"(carouse,index) in carouselList\" :key=\"carouse.id\"&gt; &lt;img :src=\"carouse.imgUrl\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 如果需要分页器 --&gt; &lt;div class=\"swiper-pagination\"&gt;&lt;/div&gt; &lt;!-- 如果需要导航按钮 --&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Swiper from \"swiper\"; export default { name: \"Carousel\", props:[\"carouselList\"], watch: { carouselList: { //这里监听，无论数据有没有变化，上来立即监听一次 immediate: true, //监听后执行的函数 handler(){ //第一次ListContainer中的轮播图Swiper定义是采用watch+ this.$nextTick()实现 this.$nextTick(() =&gt; { let mySwiper = new Swiper(this.$refs.cur,{ loop: true, // 循环模式选项 // 如果需要分页器 pagination: { el: '.swiper-pagination', // clickable: true }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, // 如果需要滚动条 scrollbar: { el: '.swiper-scrollbar', }, }) }) } } } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 在main.js中注册全局组件并引入swiper的css样式文件 // 注册轮播图组件 import Carousel from '@/components/Carousel' Vue.component(Carousel.name,Carousel) // 引入swiper样式 import 'swiper/css/swiper.css' 在其它组件中使用轮播图模块：&lt;Carousel :carouselList=\"list.carouselList\"/&gt; getters使用getters使用如果不使用getters属性，我们在组件获取state中的数据表达式为：this.$store.state.子模块.属性Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。注意： 仓库中的getters是全局属性，是不分模块的。即store中所有模块的getter内的函数都可以通过 $store.getters.函数名 获取 下图为store内容 我们在Search模块中获取商品列表数据就是通过getters实现，需要注意的是当网络出现故障时应该将返回值设置为空，如果不设置返回值就变成了undefined store中search模块代码 import {reqGetSearchInfo} from '@/api'; const state = { searchList:{}, } const mutations = { SEARCHLIST(state,searchList){ state.searchList = searchList } } const actions = { //第二个参数data默认是一个空对象 async getSearchListr({commit},data={}){ let result = await reqGetSearchInfo(data) if(result.code === 200){ commit(\"SEARCHLIST\",result.data) } } } const getters = { goodsList(state){ //网络出现故障时应该将返回值设置为空 return state.searchList.goodsList||[] } } export default { state, mutations, actions, getters, } 在Search组件中使用getters获取仓库数据 //只展示了使用getters的代码 &lt;script&gt; //引入mapGetters import {mapGetters} from 'vuex' export default { name: 'Search', computed:{ //使用mapGetters，参数是一个数组，数组的元素对应getters中的函数名 ...mapGetters(['goodsList']) } } &lt;/script&gt; Object.asign实现对象拷贝参考链接 Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 Object.assign(target, ...sources) 【target：目标对象】，【souce：源对象（可多个）】 举个栗子： const object1 = { a: 1, b: 2, c: 3 }; const object2 = Object.assign({c: 4, d: 5}, object1); console.log(object2.c, object2.d); console.log(object1) // { a: 1, b: 2, c: 3 } console.log(object2) // { c: 3, d: 5, a: 1, b: 2 } 注意： 1.如果目标对象中的属性具有相同的键，则属性将被源对象中的属性覆盖。后面的源对象的属性将类似地覆盖前面的源对象的属性 2.Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象。该方法使用源对象的[[Get]]和目标 对象的[[Set]]，所以它会调用相关 getter 和 setter。因此，它分配属性，而不仅仅是复制或定义新的属性。如 果合并源包含getter，这可能使其不适合将新属性合并到原型中。为了将属性定义（包括其可枚举性）复制到 原型，应使用Object.getOwnPropertyDescriptor()和Object.defineProperty() 。 对象深拷贝针对深拷贝，需要使用其他办法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。 let obj1 = { a: 0 , b: { c: 0}}; let obj2 = Object.assign({}, obj1); console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} obj1.a = 1; console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} console.log(JSON.stringify(obj2)); // { a: 0, b: { c: 0}} obj2.a = 2; console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 0}} console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 0}} obj2.b.c = 3; console.log(JSON.stringify(obj1)); // { a: 1, b: { c: 3}} console.log(JSON.stringify(obj2)); // { a: 2, b: { c: 3}} 最后一次赋值的时候，b是值是对象的引用，只要修改任意一个，其他的也会受影响 // Deep Clone （深拷贝） obj1 = { a: 0 , b: { c: 0}}; let obj3 = JSON.parse(JSON.stringify(obj1)); obj1.a = 4; obj1.b.c = 4; console.log(JSON.stringify(obj3)); // { a: 0, b: { c: 0}} 利用路由信息变化实现动态搜索最佳方法： 我们每次进行新的搜索时，我们的query和params参数中的部分内容肯定会改变，而且这两个参数是路由的属性。我们可以通过监听路由信息的变化来动态发起搜索请求 如下图所示，$route是组件的属性，所以watch是可以监听的（watch可以监听组件data中所有的属性）注意： 组件中data的属性包括：自己定义的、系统自带的（如 $route）、父组件向子组件传递的等等 watch: { //监听路由的信息是否发生变化，如果发生变化，再次发起请求 $route(newValue, oldValue) { //每一次请求完毕，应该把相应的1、2、3级分类的id置空的，让他接受下一次的相应1、2、3 //分类名字与关键字不用清理：因为每一次路由发生变化的时候，都会给他赋予新的数据 this.searchParams.category1Id = undefined; this.searchParams.category2Id = undefined; this.searchParams.category3Id = undefined; //再次发请求之前整理带给服务器参数 Object.assign(this.searchParams, this.$route.query, this.$route.params); //再次发起ajax请求 this.getData(); }, } 面包屑相关操作本次项目的面包屑操作主要就是两个删除逻辑。 当分类属性（query）删除时删除面包屑同时修改路由信息。 当搜索关键字（params）删除时删除面包屑、修改路由信息、同时删除输入框内的关键字。 query删除时因为此部分在面包屑中是通过categoryName展示的，所以删除时应将该属性值制空或undefined。可以通过路由再次跳转修改路由信息和url链接 //删除分类 removeBread(){ this.searchParams.categoryName = undefined this.$router.push({name:'Search',params:this.$route.params}) }, params删除时和query删除的唯一不同点是此部分会多一步操作：删除输入框内的关键字（因为params参数是从输入框内获取的）输入框是在Header组件中的 header和search组件是兄弟组件，要实现该操作就要通过兄弟组件之间进行通信完成。 这里通过$bus实现header和search组件的通信 在main.js中注册 new Vue({ //全局事件总线$bus配置 beforeCreate() { //此处的this就是这个new Vue()对象 //网络有很多bus通信总结，原理相同，换汤不换药 Vue.prototype.$bus = this }, render: h =&gt; h(App), //router2、注册路由，此时组件中都会拥有$router $route属性 router, //注册store,此时组件中都会拥有$store store }).$mount('#app') search组件使用$bus通信，第一个参数可以理解为为通信的暗号，还可以有第二个参数（用于传递数据），我们这里只是用于通知header组件进行相应操作，所以没有设置第二个参数 //删除搜索关键字 removeBreadParams(){ this.searchParams.keyword = undefined //通知兄弟组件header删除输入框的keyword关键字 this.$bus.$emit(\"clear\") this.$router.push({name:'Search',query:this.$route.query}) } header组件接受$bus通信，注意：组件挂载时就监听clear事件 mounted() { // 组件挂载时就监听clear事件，clear事件在search模块中定义 // 当删除关键字面包屑时，触发该事件，同时header的输入框绑定的keyword要删除 this.$bus.$on(\"clear\",()=&gt;{ this.keyword = '' }) } SearchSelector子组件传参及面包屑操作SearchSelector组件有两个属性也会生成面包屑，分别为品牌名、手机属性。如下图所示 此处生成面包屑时会涉及到子组件向父组件传递信息操作，之后的操作面包屑操作原理相同。唯一的区别是，这里删除面包屑时不需要修改地址栏url，因为url是由路由地址确定的，并且只有query、params两个参数变化回影响路由地址变化。 总结：面包屑由四个属性影响：parads、query、品牌、手机属性面包屑生成逻辑判断searchParams相关属性是否存在，存在即显示面包屑删除逻辑 &lt;script&gt; import SearchSelector from './SearchSelector/SearchSelector' import {mapGetters} from 'vuex' export default { name: 'Search', components: { SearchSelector }, data(){ return{ //动态获取searchParams searchParams:{ category1Id: \"\",//一级分类id category2Id: \"\",//二级分类id category3Id: \"\",//三级分类id categoryName: \"\", keyword: \"\", order: \"1:desc\", pageNo: 1, pageSize: 10, props: [],//平台售卖属性 trademark: \"\"//品牌 }, } }, //在组件挂在之前动态编辑searchParams的值，因为组件挂在之后会使用到searchParams beforeMount() { //Object.assign方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。 //Object.assign 方法只会拷贝源对象自身的并且可枚举的属性到目标对象 Object.assign(this.searchParams,this.$route.query,this.$route.params) }, methods:{ //搜索 searchInfo(){ this.$store.dispatch(\"getSearchListr\",this.searchParams) }, //删除分类(query)面包屑 removeBread(){ this.searchParams.categoryName = undefined this.$router.push({name:'Search',params:this.$route.params}) }, //删除搜索关键字(params)面包屑 removeBreadParams(){ this.searchParams.keyword = undefined //通知兄弟组件header删除输入框的keyword关键字 this.$bus.$emit(\"clear\") this.$router.push({name:'Search',query:this.$route.query}) }, //获取子组件传递的品牌信息（自定义事件） tradeMarkInfo(tradeMark){ //接口文档中trademark的信息是\"ID:品牌名称\"形式 this.searchParams.trademark = `${tradeMark.tmId}:${tradeMark.tmName}` this.searchInfo() }, //删除品牌面包屑 removeTradeMark(){ this.searchParams.trademark = undefined this.searchInfo() }, //获取子组件传递的属性信息（自定义事件） attrInfo(attr,attrValue){ //searchParams.props元素为字符串形式，api文档有介绍 let props = `${attr.attrId}:${attrValue}:${attr.attrName}` //数组去重 if(this.searchParams.props.indexOf(props)===-1){ this.searchParams.props.push(props) this.searchInfo() } }, //删除属性面包屑 removeAttr(index){ this.searchParams.props.splice(index,1) } }, mounted() { this.searchInfo() }, computed:{ ...mapGetters(['goodsList']) }, //watch可以监听组件上的属性 watch:{ $route:{ handler(newValue,oldValue){ console.log(this.$route) Object.assign(this.searchParams,this.$route.query,this.$route.params) this.searchInfo() //如果下一次搜索时只有params参数，拷贝后会发现searchParams会保留上一次的query参数 //所以每次请求结束后将相应参数制空 this.searchParams.category1Id = undefind; this.searchParams.category2Id = undefind; this.searchParams.category3Id = undefind; }, } }, } &lt;/script&gt; 商品排序排序的逻辑比较简单，只是改变一下请求参数中的order字段，后端会根据order值返回不同的数据来实现升降序order属性值为字符串，例如‘1：asc’、‘2：desc’。1代表综合，2代表价格，asc代表升序，desc代表降序我们的升降序是通过箭头图标来辨别的，如图所示： 图标是iconfont网站的图标，通过引入在线css的方式引入图标 在public文件index引入该css&lt;link rel=\"stylesheet\" href=\"https://at.alicdn.com/t/font_2994457_qqwrvmss9l9.css\"&gt; 在search模块使用该图标 &lt;div class=\"sui-navbar\"&gt; &lt;div class=\"navbar-inner filter\"&gt; &lt;ul class=\"sui-nav\"&gt; &lt;!-- 这里isOne、isTwo、isAsc、isDesc是计算属性，如果不使用计算属性要在页面中写很长的代码--&gt; &lt;li :class=\"{active:isOne}\" @click=\"changeOrder('1')\"&gt; &lt;!--阿里图标前置类iconfont--&gt; &lt;a &gt;综合&lt;span v-show=\"isOne\" class=\"iconfont\" :class=\"{'icon-up':isAsc,'icon-down':isDesc}\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;li :class={active:isTwo} @click=\"changeOrder('2')\"&gt; &lt;a &gt;价格&lt;span v-show=\"isTwo\" class=\"iconfont\" :class=\"{'icon-up':isAsc,'icon-down':isDesc}\"&gt;&lt;/span&gt;&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/div&gt; isOne、isTwo、isAsc、isDesc计算属性代码 computed:{ ...mapGetters(['goodsList']), isOne(){ return this.searchParams.order.indexOf('1')!==-1 }, isTwo(){ return this.searchParams.order.indexOf('2')!==-1 }, isDesc(){ return this.searchParams.order.indexOf('desc')!==-1 }, isAsc(){ return this.searchParams.order.indexOf('asc')!==-1 }, }, 点击‘综合’或‘价格’的触发函数changeOrder //flag用于区分综合、价格，1：综合，2：价格 changeOrder(flag){ let newSearchOrder = this.searchParams.order //将order拆为两个字段orderFlag(1:2)、order(asc:desc) let orderFlag = this.searchParams.order.split(':')[0] let order = this.searchParams.order.split(':')[1] //由综合到价格、由价格到综合 if(orderFlag!==flag){ //点击的不是同一个按钮 newSearchOrder = `${flag}:desc` this.searchInfo() }else{ //多次点击的是不是同一个按钮 newSearchOrder = `${flag}:${order==='desc'?'asc':'desc'}` } //需要给order重新赋值 this.searchParams.order = newSearchOrder; //再次发请求 this.searchInfo(); } 手写分页器实际开发中是不会手写的，一般都会用一些开源库封装好的分页，比如element ui。但是这个知识还是值得学习一下的。核心属性：pageNo（当前页码）、pageSize（每一页展示条数）、total（一共多少条数据）、continues（连续展示的页码）核心逻辑是获取连续页码的起始页码和末尾页码，通过计算属性获得。（计算属性如果想返回多个数值，可以通过对象形式返回） //连续页码的起始页码、末尾页码 startNumAndEnd(){ let start = 0 , end = 0; //规定连续页码数字5（totalPage至少5页） //不正常现象 if(this.continues &gt; this.totalPage){ start = 1 end = this.totalPage }else{ //正常现象 Math.floor:想下取整 start = this.pageNo - Math.floor(this.continues/2) end = this.pageNo + Math.floor(this.continues/2) //start出现不正常现象纠正 if(start &lt; 1){ start = 1 end = this.continues } //end出现不正常现象纠正 if(end &gt; this.totalPage){ end = this.totalPage start = this.totalPage - this.continues + 1 } } return {start,end} } 当点击页码会将pageNo传递给父组件，然后父组件发起请求，最后渲染。这里还是应用通过自定义事件实现子组件向父组件传递信息 字符串拼接&lt;router-link :to=\"`/detail/${goods.id}`\"&gt;&lt;/router-link&gt; 滚动条使用前端路由，当切换到新路由时，想要页面滚到顶部，或者是保持原先的滚动位置，就像重新加载页面那样。 vue-router 能做到，而且更好，它让你可以自定义路由切换时页面如何滚动router滚动行为 undefined细节访问undefined的属性值会引起红色警告，可以不处理，但是要明白警告的原因。以获取商品categoryView信息为例，categoryView是一个对象。对应的getters代码 const getters = { categoryView(state){ return state.goodInfo.categoryView } } 对应的computed代码 computed:{ ...mapGetters(['categoryView']) } html代码 &lt;div class=\"conPoin\"&gt; &lt;span v-show=\"categoryView.category1Name\" &gt;{{categoryView.category1Name}}&lt;/span&gt; &lt;span v-show=\"categoryView.category2Name\" &gt;{{categoryView.category2Name}}&lt;/span&gt; &lt;span v-show=\"categoryView.category3Name\" &gt;{{categoryView.category3Name}}&lt;/span&gt; &lt;/div&gt; 细节在于getters的返回值。如果getters按上面代码写为return state.goodInfo.categoryView，页面可以正常运行，但是会出现红色警告。 原因： 假设我们网络故障，导致goodInfo的数据没有请求到，即goodInfo是一个空的对象，当我们去调用getters中的return state.goodInfo.categoryView时，因为goodInfo为空，所以也不存在categoryView，即我们getters得到的categoryView为undefined。所以我们在html使用该变量时就会出现没有该属性的报错。即：网络正常时不会出错，一旦无网络或者网络问题就会报错。总结： 所以我们在写getters的时候要养成一个习惯在返回值后面加一个||条件。即当属性值undefined时，会返回||后面的数据，这样就不会报错。如果返回值为对象加|| {}，数组：|| []。此处categoryView为对象，所以将getters代码改为return state.goodInfo.categoryView || {} 商品详情商品详情唯一难点就是点击轮播图图片时，改变放大镜组件展示的图片。 老师的方法很巧妙：在轮播图组件中设置一个currendIndex，用来记录所点击图片的下标，并用currendIndex实现点击图片高亮设置。当符合图片的下标满足currentIndex===index时，该图片就会被标记为选中。 &lt;div class=\"swiper-container\" ref=\"cur\"&gt; &lt;div class=\"swiper-wrapper\"&gt; &lt;div class=\"swiper-slide\" v-for=\"(skuImage,index) in skuImageList\" :key=\"skuImage.id\"&gt; &lt;img :src=\"skuImage.imgUrl\" :class=\"{active:currentIndex===index}\" @click=\"changeImg(index)\"&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"swiper-button-next\"&gt;&lt;/div&gt; &lt;div class=\"swiper-button-prev\"&gt;&lt;/div&gt; &lt;/div&gt; 轮播图组件和放大镜组件是兄弟组件，所以要通过全局总线通信。在轮播图组件中，点击图片触发全局事件changeImg，参数为图片所在数组的下标。 changeImg(index){ //将点击的图片标识位高亮 this.currentIndex = index //通知兄弟组件修改大图图片 this.$bus.$emit(\"changeImg\",index) } 对应的放大镜组件，首先在mounted监听该全局事件 mounted() { this.$bus.$on(\"changeImg\",(index)=&gt;{ //修改当前响应式图片 this.currentIndex = index; }) } 放大镜组件中也会有一个currentIndex，他用表示大图中显示的图片的下标（因为放大镜组件只能显示一张图片），全局事件传递的index赋值给currentIndex ，通过computed计算属性改变放大镜组件展示的图片下标 computed:{ imgObj(){ return this.skuImageList[this.currentIndex] || {} } }, 放大镜相关知识&lt;template&gt; &lt;div class=\"spec-preview\"&gt; &lt;img :src=\"imgObj.imgUrl\" /&gt; &lt;div class=\"event\" @mousemove=\"handler\"&gt;&lt;/div&gt; &lt;div class=\"big\"&gt; &lt;img :src=\"imgObj.imgUrl\" ref=\"big\"/&gt; &lt;/div&gt; &lt;!-- 遮罩层 --&gt; &lt;div class=\"mask\" ref=\"mask\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"Zoom\", props: [\"skuImageList\"], data() { return { currentIndex:0 } }, computed:{ imgObj(){ return this.skuImageList[this.currentIndex]||{} } }, mounted(){ //全局事件总线：获取兄弟组件传递过来的索引值 this.$bus.$on('getIndex',(index)=&gt;{ //修改当前响应式数据 this.currentIndex = index; }) }, methods: { handler(event) { let mask = this.$refs.mask; let big = this.$refs.big; let left = event.offsetX - mask.offsetWidth/2; let top = event.offsetY - mask.offsetHeight/2; //约束范围 if(left &lt;=0) left = 0; if(left &gt;=mask.offsetWidth) left = mask.offsetWidth; if(top&lt;=0)top = 0; if(top&gt;=mask.offsetHeight) top = mask.offsetHeight; //修改元素的left|top属性值 mask.style.left = left+'px'; mask.style.top = top +'px'; big.style.left = - 2 * left+'px'; big.style.top = -2 * top +'px'; }, }, }; &lt;/script&gt; &lt;style lang=\"less\"&gt; .spec-preview { position: relative; width: 400px; height: 400px; border: 1px solid #ccc; img { width: 100%; height: 100%; } .event { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 998; } .mask { width: 50%; height: 50%; background-color: rgba(0, 255, 0, 0.3); position: absolute; left: 0; top: 0; display: none; } .big { width: 100%; height: 100%; position: absolute; top: -1px; left: 100%; border: 1px solid #aaa; overflow: hidden; z-index: 998; display: none; background: white; img { width: 200%; max-width: 200%; height: 200%; position: absolute; left: 0; top: 0; } } .event:hover ~ .mask, .event:hover ~ .big { display: block; } } &lt;/style&gt; 失焦事件blur与change事件在绝大部分情况下表现都非常相似，输入结束后，离开输入框，会先后触发change与blur，唯有两点例外。 1. 没有进行任何输入时，不会触发change。在这种情况下，输入框并不会触发change事件，但一定会触发blur事件。在判断表单修改状态时，这种差异会非常有用，通过change事件能轻易地找到哪些字段发生了变更以及其值的变更轨迹。 2. 输入后值并没有发生变更。这种情况是指，在没有失焦的情况下，在输入框内进行返回的删除与输入操作，但最终的值与原值一样，这种情况下，keydown、input、keyup、blur都会触发，但change依旧不会触发。 加入购物车成功路由点击加入购物车时，会向后端发送API请求，但是该请求的返回值中data为null，所以我们只需要根据状态码code判断是否跳转到‘加入购物车成功页面’。 detail组件‘加入购物车’请求函数： async addShopCar() { try{ await this.$store.dispatch(\"addOrUpdateShopCart\", { skuId: this.$route.params.skuId, skuNum: this.skuNum }); //一些简单的数据，比如skuNum通过query传过去 //复杂的数据通过session存储， //sessionStorage、localStorage只能存储字符串 sessionStorage.setItem(\"SKUINFO\",JSON.stringify(this.skuInfo)) this.$router.push({name:'AddCartSuccess',query:{'skuNum':this.skuNum}}) }catch (error){ alert(error.message) } } detail store对应代码 //将产品添加到购物车中 async addOrUpdateShopCart({commit},{skuId,skuNum}){ let result = await reqAddOrUpdateShopCart(skuId,skuNum) if(result.code === 200){ return 'ok' }else{ return Promise.reject(new Error('faile')) } } 跳转‘加入购物车成功页面’的同时要携带商品的信息。本项目只是传递的商品的一些标签属性，并没有传递商品的型号类别的信息，比如颜色、内存等信息，自己可以手动实现，比较简单。 当我们想要实现两个毫无关系的组件传递数据时，首相想到的就是路由的query传递参数，但是query适合传递单个数值的简单参数，所以如果想要传递对象之类的复杂信息，就可以通过Web Storage实现。 sessionStorage、localStorage概念：sessionStorage： 为每一个给定的源维持一个独立的存储区域，该区域在页面会话期间可用（即只要浏览器处于打开状态，包括页面重新加载和恢复）。localStorage： 同样的功能，但是在浏览器关闭，然后重新打开后数据仍然存在。注意： 无论是session还是local存储的值都是字符串形式。如果我们想要存储对象，需要在存储前JSON.stringify()将对象转为字符串，在取数据后通过JSON.parse()将字符串转为对象。 购物车组件开发根据api接口文档封装请求函数 export const reqGetCartList = () =&gt; { return requests({ url:'/cart/cartList', method:'GET' })} 但是如果想要获取详细信息，还需要一个用户的uuidToken，用来验证用户身份。但是该请求函数没有参数，所以我们只能把uuidToken加在请求头中 创建utils工具包文件夹，创建生成uuid的js文件，对外暴露为函数（记得导入uuid =&gt; npm install uuid）生成临时游客的uuid（随机字符串）,每个用户的uuid不能发生变化，还要持久存储 import {v4 as uuidv4} from 'uuid' //生成临时游客的uuid（随机字符串）,每个用户的uuid不能发生变化，还要持久存储 export const getUUID = () =&gt; { //1、判断本地存储是否由uuid let uuid_token = localStorage.getItem('UUIDTOKEN') //2、本地存储没有uuid if(!uuid_token){ //2.1生成uuid uuid_token = uuidv4() //2.2存储本地 localStorage.setItem(\"UUIDTOKEN\",uuid_token) } //当用户有uuid时就不会再生成 return uuid_token } 用户的uuid_token定义在store中的detail模块 const state = { goodInfo:{}, //游客身份 uuid_token: getUUID() } 在request.js中设置请求头 import store from '@/store'; requests.interceptors.request.use(config =&gt; { //config内主要是对请求头Header配置 //比如添加token //1、先判断uuid_token是否为空 if(store.state.detail.uuid_token){ //2、userTempId字段和后端统一 config.headers['userTempId'] = store.state.detail.uuid_token } //开启进度条 nprogress.start(); return config; }) 注意： this.$store只能在组件中使用，不能在js文件中使用。如果要在js中使用，需要引入import store from ‘@/store’; 购物车商品数量1. 购物车商品信息展示比较简单，就不多做赘述。2. every函数使用 every遍历某个数组，判断数组中的元素是否满足表达式，全部为满足返回true，否则返回false 例如判断底部勾选框是否全部勾选代码部分 //判断底部勾选框是否全部勾选 isAllCheck() { //every遍历某个数组，判断数组中的元素是否满足表达式，全部为满足返回true，否则返回false return this.cartInfoList.every(item =&gt; item.isChecked === 1) } 3. 修改商品数量前端代码部分： &lt;li class=\"cart-list-con5\"&gt; &lt;a href=\"javascript:void(0)\" class=\"mins\" @click=\"handler('minus',-1,cartInfo)\"&gt;-&lt;/a&gt; &lt;input autocomplete=\"off\" type=\"text\" :value=\"cartInfo.skuNum\" @change=\"handler('change',$event.target.value,cartInfo)\" minnum=\"1\" class=\"itxt\"&gt; &lt;a href=\"javascript:void(0)\" class=\"plus\" @click=\"handler('add',1,cartInfo)\"&gt;+&lt;/a&gt; &lt;/li&gt; handler函数，修改商品数量时，加入节流操作 添加到购物车和对已有物品进行数量改动使用的同一个api，可以查看api文档。handler函数有三个参数，type区分操作，disNum用于表示数量变化（正负）,cart商品的信息 //加入节流操作 handler: throttle(async function(type,disNum,cart){ //减按钮判断当前数量是否为1 if(type === 'minus') { //当商品数量为1是，不可以再减少 if(cart.skuNum === 1){ return; } } //输入框修改,难点：要判断输入的内容是否合法 if(type === 'change'){ //输入内容不合法时 if(isNaN(disNum * 1) || disNum &lt;= 0){ disNum = 0; }else{ disNum = parseInt(disNum) - cart.skuNum } } //加按钮disNum不需要改变 try{ await this.$store.dispatch('addOrUpdateShopCart',{skuId:cart.skuId,skuNum:disNum}) //商品数量修改成功后再次获取服务器数据 await this.$store.dispatch(\"getCartList\") }catch (error){ alert(error) } },100), 购物车状态修改和商品删除action部分：以删除购物车某个商品数据为例 //修改购物车某一个产品的选中状态 async reqUpdateCheckedById({commit},{skuId,isChecked}){ let result = await reqUpdateCheckedById(skuId,isChecked) if(result.code === 200){ return 'ok' }else{ return Promise.reject(new Error('fail')) } } method部分：（重点是try、catch） // 修改某一个商品的勾选状态 async updateChecked(cartInfo, event) { try { let isChecked = event.target.checked ? 1 : 0; await this.$store.dispatch(\"shopcart/UpdateCheckedById\", {skuId: cartInfo.skuId,isChecked }); /修改成功，刷新数据 this.getDate(); } catch (error) { alert(error.message); } } 删除多个商品（actions扩展）由于后台只提供了删除单个商品的接口，所以要删除多个商品时，只能多次调用actions中的函数。我们可能最简单的方法是在method的方法中多次执行dispatch删除函数，当然这种做法也可行，但是为了深入了解actions，我们还是要将批量删除封装为actions函数。actions扩展官网的教程，一个标准的actions函数如下所示： deleteAllCheckedById(context) { console.log(context) } 我们可以看一下context到底是什么 context中是包含dispatch、getters、state的，即我们可以在actions函数中通过dispatch调用其他的actions函数，可以通过getters获取仓库的数据。这样我们的批量删除就简单了，对应的actions函数代码让如下 // 删除全部勾选产品 deleteAllCheckedCart({dispatch,getters}){ // context:小仓库，commit【提交mutation修改state】 getters【计算属性】 dispatch 【派系action】 state【当前仓库数据】 // 获取购物车中的全部产品(是一个数组) let PromiseAll = [] getters.cartInfoList.forEach(item =&gt; { let promise = item.isChecked == 1 ? dispatch('DeleteCartById',item.skuId) : '' PromiseAll.push(promise) }); // 只要全部promise都成功,返回结果即为成功 // 如果有一个失败,返回即为失败结果 return Promise.all(PromiseAll) }, 上面代码使用到了Promise.all Promise.all可以将多个Promise实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是一个结果数组，而失败的时候则返回最先被reject失败状态的值。 购物车组件method批量删除函数 //删除选中的所有商品 async deleteAllCheckedById(){ try{ await this.$store.dispatch('deleteAllCheckedById') //删除成功，刷新数据 this.$store.dispatch(\"getCartList\") }catch (error){ alert(error) } } 修改商品的全部状态和批量删除的原理相同，直接贴代码。actions // 修改全部商品状态 updateAllCartIsChecked({getters,dispatch},isChecked){ let PromiseAll = [] getters.cartInfoList.forEach(item =&gt; { let promise = dispatch('UpdateCheckedById',{skuId:item.skuId,isChecked}) PromiseAll.push(promise) }) return Promise.all(PromiseAll) } method //修改全部商品的状态 async allChecked(event){ let flag = event.target.checked ? 1 : 0 try{ await this.$store.dispatch('updateAllChecked',flag) //修改成功，刷新数据 this.$store.dispatch(\"getCartList\") }catch (error){ alert(error) } } 注册登录业务用户注册模块actions //用户注册 async userRegister({ commit }, user) { let result = await reqUserRegister(user); if (result.code == 200) { return \"ok\"; } else { return Promise.reject(new Error(\"failed\")); } } methods注册功能这里用到了表单验证插件 vee-validate首先在src目录下的plugins文件夹中创建validate.js文件 // vee-validate插件：表单验证区域 import Vue from 'vue' import VeeValidate from 'vee-validate' // 中文提示信息 import zh_CN from \"vee-validate/dist/locale/zh_CN\"; Vue.use(VeeValidate) // 表单验证 VeeValidate.Validator.localize(\"zh_CN\", { messages: { ...zh_CN.messages, is: (field) =&gt; `${field}必须与密码相同`, // 修改内置规则的 message，让确认密码和密码相同 }, attributes: { phone: \"手机号\", code: \"验证码\", password: \"密码\", passwordRepe: \"确认密码\", agree: '协议' }, }); // 自定义校验规则 //定义协议必须打勾同意 VeeValidate.Validator.extend('agree', { validate: value =&gt; { return value }, getMessage: field =&gt; field + '必须同意' }) 在main.js组件注册 //引入表单校验插件 import \"@/plugins/validate\"; html &lt;div class=\"content\"&gt; &lt;label&gt;手机号:&lt;/label&gt; &lt;input placeholder=\"请输入你的手机号\" v-model=\"phone\" name=\"phone\" v-validate=\"{ required: true, regex: /^1\\d{10}$/ }\" :class=\"{ invalid: errors.has('phone') }\" /&gt; &lt;span class=\"error-msg\"&gt;{{ errors.first(\"phone\") }}&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;label&gt;验证码:&lt;/label&gt; &lt;input placeholder=\"请输入你的验证码\" v-model=\"code\" name=\"code\" v-validate=\"{ required: true, regex: /^\\d{6}$/ }\" :class=\"{ invalid: errors.has('code') }\" /&gt; &lt;button style=\"width:100px;height:38px\" @click=\"getCode\"&gt; 获取验证码 &lt;/button&gt; &lt;span class=\"error-msg\"&gt;{{ errors.first(\"code\") }}&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;label&gt;登录密码:&lt;/label&gt; &lt;input placeholder=\"请输入你的密码\" v-model=\"password\" name=\"password\" v-validate=\"{ required: true, regex: /^[0-9A-Za-z]{8,20}$/ }\" :class=\"{ invalid: errors.has('password') }\" /&gt; &lt;span class=\"error-msg\"&gt;{{ errors.first(\"password\") }}&lt;/span&gt; &lt;/div&gt; &lt;div class=\"content\"&gt; &lt;label&gt;确认密码:&lt;/label&gt; &lt;input placeholder=\"请输入确认密码\" v-model=\"password1\" name=\"password1\" v-validate=\"{ required: true, is: password }\" :class=\"{ invalid: errors.has('password1') }\" /&gt; &lt;span class=\"error-msg\"&gt;{{ errors.first(\"password1\") }}&lt;/span&gt; &lt;/div&gt; &lt;div class=\"controls\"&gt; &lt;input type=\"checkbox\" v-model=\"agree\" name=\"agree\" v-validate=\"{ required: true, tongyi: true }\" :class=\"{ invalid: errors.has('agree') }\" /&gt; &lt;span&gt;同意协议并注册《尚品汇用户协议》&lt;/span&gt; &lt;span class=\"error-msg\"&gt;{{ errors.first(\"agree\") }}&lt;/span&gt; &lt;/div&gt; &lt;div class=\"btn\"&gt; &lt;button @click=\"userRegister\"&gt;完成注册&lt;/button&gt; &lt;/div&gt; methods //用户注册 async userRegister() { const success = await this.$validator.validateAll(); //全部表单验证成功，在向服务器发请求，进行祖册 //只要有一个表单没有成功，不会发请求 if (success) { try { const { phone, code, password, password1 } = this; await this.$store.dispatch(\"userRegister\", { phone, code, password, }); //注册成功进行路由的跳转 this.$router.push(\"/login\"); } catch (error) { alert(error.message); } } } 登录模块html &lt;form &gt; &lt;div class=\"input-text clearFix\"&gt; &lt;span&gt;&lt;/span&gt; &lt;input type=\"text\" placeholder=\"邮箱/用户名/手机号\" v-model=\"phone\"&gt; &lt;/div&gt; &lt;div class=\"input-text clearFix\"&gt; &lt;span class=\"pwd\"&gt;&lt;/span&gt; &lt;input type=\"password\" placeholder=\"请输入密码\" v-model=\"password\"&gt; &lt;/div&gt; &lt;div class=\"setting clearFix\"&gt; &lt;label class=\"checkbox inline\"&gt; &lt;input name=\"m1\" type=\"checkbox\" value=\"2\" checked=\"\"&gt; 自动登录 &lt;/label&gt; &lt;span class=\"forget\"&gt;忘记密码？&lt;/span&gt; &lt;/div&gt; &lt;button class=\"btn\" @click.prevent=\"goLogin\"&gt;登&amp;nbsp;&amp;nbsp;录&lt;/button&gt; &lt;/form&gt; 由于登录按钮的父节点是一个form表单，如果使用@click触发登录事件，form表单会执行默认事件action实现页面跳转。这里我们使用 @click.prevent，它可以阻止自身默认事件的执行。 actions //登录业务 async userLogin({ commit }, data) { let result = await reqUserLogin(data); //服务器下发token，用户唯一标识符(uuid) //将来经常通过带token找服务器要用户信息进行展示 if (result.code == 200) { //用户已经登录成功且获取到token commit(\"USERLOGIN\", result.data.token); //持久化存储token setToken(result.data.token); return \"ok\"; } else { return Promise.reject(new Error(\"faile\")); } mutations设置用户token //设置用户token SETUSERTOKEN(state,token){ state.token = token } 登录组件methods //登录的回调函数 async userLogin() { try { //登录成功 const { phone, password } = this; phone&amp;&amp;password&amp;&amp;(await this.$store.dispatch(\"userLogin\", { phone, password })); //登录的路由组件：看路由当中是否包含query参数，有：调到query参数指定路由，没有：调到home let toPath = this.$route.query.redirect||\"/home\"; this.$router.push(toPath); } catch (error) { alert(error.message); } }, actions登录成功后获取用户信息 //获取用户信息 async getUserInfo({ commit }) { let result = await reqUserInfo(); if (result.code == 200) { //提交用户信息 commit(\"GETUSERINFO\", result.data); return 'ok'; }else{ return Promise.reject(new Error('faile')); } } mutations存储用户信息 //存储用户信息 SETUSERINFO(state,data){ state.userInfo = data } 导航守卫思路：直接看流程图为什么要判断name？ 因为store中的token是通过localStorage获取的，token有存放在本地。当页面刷新时，本地token不会消失，所以store中的token也不会消失。但是，store中的其他数据（用户信息等）会清空，此时会出现用户信息不存在，但是有token，这种情况是不可以访问其他页面的，必须先去获取用户信息。由于用户信息是一个对象，所以我们通过它的一个属性name判断用户信息是否存在。所以不仅要判断token,还要判断用户信息 //全局守卫：前置守卫（在路由跳转之间进行判断） router.beforeEach(async (to, from, next) =&gt; { //to:获取到要跳转到的路由信息 //from：获取到从哪个路由跳转过来来的信息 //next: next() 放行 next(path) 放行 //方便测试 统一放行 // next(); //获取仓库中的token-----可以确定用户是登录了 let token = store.state.user.token; let name = store.state.user.userInfo.name; //用户登录了 if(token){ //已经登录而且还想去登录------不行 if(to.path==\"/login\"||to.path=='/register'){ next('/'); }else{ //已经登陆了,访问的是非登录与注册 //登录了且拥有用户信息放行 if(name){ next(); }else{ //登陆了且没有用户信息 //在路由跳转之前获取用户信息且放行 try { await store.dispatch('getUserInfo'); next(); } catch (error) { //token失效从新登录 await store.dispatch('userLogout'); next('/login') } } } }else{ //未登录：不能去交易相关、不能去支付相关【pay|paysuccess】、不能去个人中心 //未登录去上面这些路由-----登录 let toPath = to.path; if(toPath.indexOf('/trade')!=-1 || toPath.indexOf('/pay')!=-1||toPath.indexOf('/center')!=-1){ //把未登录的时候向去而没有去成的信息，存储于地址栏中【路由】 next('/login?redirect='+toPath); }else{ //去的不是上面这些路由（home|search|shopCart）---放行 next(); } } }); 交易模块支付弹窗（这里使用了element-UI） import {Button,MessageBox} from 'element-ui'; //ElementUI注册组件 //ElementUI注册组件的时候，还有一种写法，挂在原型上Vue.component(Button.name,Button); Vue.prototype.$msgbox = MessageBox; Vue.prototype.$alert = MessageBox.alert; &lt;div class=\"submit\"&gt; &lt;a class=\"btn\" @click=\"open\"&gt;立即支付&lt;/a&gt; &lt;/div&gt; &lt;script&gt; //生成二维码插件 import QRCode from \"qrcode\"; // 支付弹窗 async open() { // 生成二维码（地址） let qrCode = await QRCode.toDataURL(this.payInfo.codeUrl) this.$alert(`&lt;img src=${qrCode} /&gt;`, \"请你微信支付\", { dangerouslyUseHTMLString: true, //是否将 message 属性作为 HTML 片段处理 center:true, //是否居中布局 showClose:false, //MessageBox 是否显示右上角关闭按钮 showCancelButton:true, //是否显示取消按钮 showConfirmButton:true, //是否显示确定按钮 cancelButtonText: '支付遇见问题', //取消按钮的文本内容 confirmButtonText: '已支付成功', //确定按钮的文本内容 // 关闭弹出框的配置值 beforeClose:(type,instance,done)=&gt;{ //此处必须用箭头函数 // type：区分取消|确定按钮 // instance：当前组件实例 // done：关闭弹出框的方法 if(type=='cancel'){ alert('请联系管理员'); console.log('请联系管理员'); clearInterval(this.timer); this.timer = null; // 关闭弹出框 done() }else{ if(this.code == 200){ clearInterval(this.timer) this.timer = null done() this.$router.push('/paysuccess') } } } }).catch(e =&gt; e); // 支付成功，需要路由跳转，支付失败，提示信息 if(!this.timer){ //定时器间歇发送请求获取订单支付状态 this.timer = setInterval(async () =&gt; { let result = await this.$API.reqPayStatus(this.orderId) console.log(result); if(result.code == 200){ //1、清除定时器 clearInterval(this.timer) this.timer = null /2、保存支付成功返回的code this.code = result.code //3、关闭弹出框 this.$msgbox.close() //4、跳转到下一个路由 this.$router.push('/paysuccess') } },1000) } } &lt;/script&gt; 个人中心虽然二级路由在后台管理系统常用，但是我们的个人中心也可以用到二级路由。注意： 我们的子路由最好放在父路由文件夹下，二级路由要么不写/，要么写全：’/center/myorder’。 //个人中心 { name: 'Center', path: '/center', component: () =&gt; import('@/pages/Center'), children: [ { //二级路由要么不写/，要么写全：'/center/myorder' path: 'myorder', component: () =&gt; import('@/pages/Center/MyOrder') }, { path: 'groupbuy', component: () =&gt; import('@/pages/Center/GroupOrder'), }, // 表示当我们访问center路由时，center中的router-view部分默认显示myorder二级路由内容。 { path:'/center', redirect:'/center/myorder' } ] } 路由独享的守卫全局导航守卫已经帮助我们限制未登录的用户不可以访问相关页面。但是还会有一个问题例如： 用户已经登陆，用户在home页直接通过地址栏访问trade结算页面，发现可以成功进入该页面，正常情况，用户只能通过在shopcart页面点击去结算按钮才可以到达trade页面。我们可以通过路由独享守卫解决该问题 路由独享的守卫：只针对一个路由的守卫，所以该守卫会定义在某个路由中。以上面问题为例，我们可以通过路由独享的守卫解决。在trade路由信息中加入路由独享守卫 //交易组件 { name: 'Trade', path: '/trade', meta: {show:true}, component: () =&gt; import('@/pages/Trade'), //路由独享首位 beforeEnter: (to, from, next) =&gt; { if(from.path === '/shopcart' ){ next() }else{ next(false) } } } 图片懒加载插件的使用直接参考官方教程懒加载vue-lazyload插件官网 vue使用插件的原理每个插件都会有一个install方法，install后就可以在我们的代码中可以使用该插件。这个install有两类参数，第一个为Vue实例，后面的参数可以自定义。 vue使用插件的步骤 引入插件 import VueLazyload from “vue-lazyload” 注册插件 Vue.use(VueLazyload) 这里的Vue.use()实际上就是调用了插件的install方法。如此之后，我们就可以使用该插件了。 表单验证vee-validateelement-UI 路由懒加载当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了。路由懒加载链接代码示例 //详情页面组件 { //需要params传参（产品id） path: \"/detail/:skuId\", name: 'Detail', component: ()=&gt; import('../pages/Detail'), meta:{show: true}, }, //添加购物车成功 { path: \"/addcartsuccess\", name: 'AddCartSuccess', component: ()=&gt; import('../pages/AddCartSuccess'), meta:{show: true}, } 打包项目项目到此基本就完成了，接下来就是打包上线。在项目文件夹下执行npm run build。会生成dist打包文件 dist就是我们打包好的项目文件 dist文件下的js文件存放我们所有的js文件，并且经过了加密，并且还会生成对应的map文件。 map文件作用： 因为代码是经过加密的，如果运行时报错，输出的错误信息无法准确得知时那里的代码报错。有了map就可以向未加密的代码一样，准确的输出是哪一行那一列有错。 当然map文件也可以去除（map文件大小还是比较大的）在vue.config.js配置productionSourceMap: false即可。注意：vue.config.js配置改变，需要重启项目 尚品汇后台管理系统后台模板介绍该模板基于elementUI组件库开发简洁版: https://github.com/PanJiaChen/vue-admin-template加强版: https://github.com/PanJiaChen/vue-element-admin 模板常用的文件与文件夹认知【简洁版】 build—–index.js：webpack配置文件【很少修改这个文件】mock—–mock数据的文件夹【模拟一些假的数据mockjs实现的】，因为咱们实际开发的时候，利用的是真是接口node_modules—–项目依赖的模块public—–icon图标，静态页面，publick文件夹里面经常放置一些静态资源，而且在项目打包的时候webpack不会编译这个文件夹，原封不动的打包到dist文件夹里面src—–程序员源代码的地方—–api文件夹:涉及请求相关的—–assets文件夹：里面放置一些静态资源（一般共享的），放在aseets文件夹里面静态资源，在webpack打包的时候，会进行编译—–components文件夹：一般放置非路由组件获取全局组件—–icons这个文件夹的里面放置了一些svg矢量图—–layout文件夹：他里面放置一些组件与混入—–router文件夹：与路由相关的—–store文件夹：一定是与vuex相关的—–style文件夹：与样式相关的—–utils文件夹：request.js是axios二次封装文件—–views文件夹：里面放置的是路由组件App.vue： 根组件main.js： 入口文件permission.js： 与导航守卫相关、settings： 项目配置项文件.editorconfig： 编程风格配置文件webpack配置文件webpack可以监测到当前开发环境—–.env.development 开发环境—–.env.producation 上线环境—–.env.staging 测试环境env文件的配置均以VUE_APP开头可以在main.js通过webpack提供的对象process身上的env属性获取.env文件的全部配置信息 获取当前的开发环境具体代码：console.log(process.env) 相关应用 //根据开发环境决定axios实例的baseURL const service = axios.create({ baseURL: process.env.VUE_APP_BASE_API, // url = base url + request url // withCredentials: true, // send cookies when cross-domain requests timeout: 5000 // request timeout }) 完成登录业务 步骤： 静态组件完成 书写API（换成真实的接口） axios二次封装 换成真实接口之后需要解决代理跨域问题(解决代理跨域问题) 品牌管理静态组件这里使用ElementUI搭建静态组件（效果图在下一标题） &lt;template&gt; &lt;div&gt; &lt;!-- 按钮 --&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\"&gt;添加&lt;/el-button&gt; &lt;!-- 表格组件 data：表格组件将来需要展示的数据---数据类型 border：是给表格添加边框 colum属性 label：显示标题 width：对应宽度 aligin：标题的对齐方式 prop：对应列内容的字段名 注意：elementUI当中的table组件，展示的数据是以一列一列进行展示数据 --&gt; &lt;el-table style=\"width: 100%\" border &gt; &lt;el-table-column prop=\"prop\" label=\"序号\" width=\"80px\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"品牌名称\" width=\"width\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"品牌LOGO\" width=\"width\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页器 当前展示第几页，数据总条数，每页展示条数，连续页码数 @size-change=\"handleSizeChange\" --pageSize 改变时会触发 @current-change=\"handleCurrentChange\" --currentPage 改变时会触发 current-page：代表的是当前第几页 total：代表分页器一共需要展示多少条数据 page-size：代表每一页需要多少条数据 layout：可以实现分页器布局 pager-count：按钮的数量 如果设置为9，则连续页码个数为7 --&gt; &lt;el-pagination style=\"margin-top:20px;text-align:center;\" :current-page=\"5\" :total=\"99\" :page-size=\"5\" :page-sizes=\"[3, 5, 7]\" :pager-count='7' layout=\"prev, pager, next, jumper, -&gt;, sizes, total\" &gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/template&gt; 品牌列表动态展示1.书写相关的API接口 // 引入API接口 import API from '@/api' Vue.prototype.$API = API 2.展示动态数据 实际效果图 &lt;template&gt; &lt;div&gt; &lt;!-- 按钮 --&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\"&gt;添加&lt;/el-button&gt; &lt;el-table style=\"width: 100%\" border :data=\"records\"&gt; &lt;el-table-column type=\"index\" label=\"序号\" width=\"80px\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"tmName\" label=\"品牌名称\" width=\"width\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"品牌LOGO\" width=\"width\" align=\"center\"&gt; &lt;!-- 作用域插槽 --&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;img :src=\"row.logoUrl\" alt=\"\" style=\"width:100px;height:100px\"&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"操作\" width=\"width\" align=\"center\"&gt; &lt;template slot-scope=\"{row}\"&gt; &lt;el-button type=\"warning\" icon=\"el-icon-edit\" size=\"mini\"&gt;修改&lt;/el-button&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" size=\"mini\"&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination style=\"margin-top:20px;text-align:center;\" :current-page=\"page\" :total=\"total\" :page-size=\"limit\" :page-sizes=\"[3, 5, 7]\" :pager-count='7' @current-change=\"getPageList\" @size-change=\"handleSizeChange\" layout=\"prev, pager, next, jumper, -&gt;, sizes, total\" &gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"tradeMark\", data() { return { // 代表的分页器第几页 page:1, // 当前页面展示数据条数 limit:3, // 总共多少条数据 total:0, // 列表展示数据 records:[] } }, mounted() { this.getPageList(); }, methods: { // 获取列表数据方法 async getPageList(pager=1){ this.page=pager const {page,limit} = this; // 获取品牌列表的接口 let result = await this.$API.tradeMark.reqTradeMarkList(page,limit) if(result.code === 200){ this.total = result.data.total this.records = result.data.records } }, // 当分页器某一页需要需要展示数据条数发生变化的时候触发 handleSizeChange(limit){ this.limit = limit this.getPageList() } }, }; &lt;/script&gt; 添加与修改品牌对话框效果图： // 添加品牌 /admin/product/baseTrademark/save post 参数:logoUrl,tmName // 切记：对于新增的品牌，给服务器传递数据，不需要传递id，id是由服务器生成 // 修改品牌 /admin/product/baseTrademark/update put 参数:id,logoUrl,tmName // 切记：对于修改某一个品牌的操作，前端携带的参数需要带上id，你需要告诉服务器修改的是哪一个品牌 export const reqAddOrUpdateTradeMark = (tradeMark) =&gt; { if(tradeMark.id){ return request({url:'/admin/product/baseTrademark/update',method:'put',data:tradeMark}) }else{ return request({url:'/admin/product/baseTrademark/save',method:'post',data:tradeMark}) } } &lt;template&gt; &lt;div&gt; &lt;!-- 按钮 --&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\" @click=\"showDialog\"&gt;添加&lt;/el-button&gt; &lt;el-table style=\"width: 100%\" border :data=\"records\"&gt; &lt;el-table-column type=\"index\" label=\"序号\" width=\"80px\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"tmName\" label=\"品牌名称\" width=\"width\" align=\"center\" &gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"品牌LOGO\" width=\"width\" align=\"center\"&gt; &lt;template slot-scope=\"{ row }\"&gt; &lt;img :src=\"row.logoUrl\" alt=\"\" style=\"width: 100px; height: 100px\" /&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"操作\" width=\"width\" align=\"center\"&gt; &lt;template slot-scope=\"{row}\"&gt; &lt;el-button type=\"warning\" icon=\"el-icon-edit\" size=\"mini\" @click=\"updateTradeMark(row)\"&gt;修改&lt;/el-button&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" size=\"mini\"&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 对话框 :visible.sync:控制对话框显示与隐藏用的 --&gt; &lt;el-dialog :title=\"tmForm.id?'修改品牌':'添加品牌'\" :visible.sync=\"dialogFormVisible\"&gt; &lt;!-- form表单：model属性，这个属性的作用是把表单的数据收集到那个对象的身上，将来表单验证也需要这个属性 --&gt; &lt;el-form style=\"width: 75%\" :model=\"tmForm\"&gt; &lt;el-form-item label=\"品牌名称\" label-width=\"100px\"&gt; &lt;el-input autocomplete=\"off\" v-model=\"tmForm.tmName\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"品牌LOGO\" label-width=\"100px\"&gt; &lt;!-- 这里收集数据，不能使用v-model，因为不是表单元素 action：设置上传图片的地址 :show-file-list=\"false\" 是否显示已上传文件列表 :on-success=\"handleAvatarSuccess\" 可以检测到图片上传成功，当图片上传成功，会执行一次 :before-upload=\"beforeAvatarUpload\" 可以在上传图片之前，执行一次 --&gt; &lt;el-upload class=\"avatar-uploader\" action=\"/dev-api/admin/product/fileUpload\" :show-file-list=\"false\" :on-success=\"handleAvatarSuccess\" :before-upload=\"beforeAvatarUpload\" &gt; &lt;img v-if=\"tmForm.logoUrl\" :src=\"tmForm.logoUrl\" class=\"avatar\" /&gt; &lt;i v-else class=\"el-icon-plus avatar-uploader-icon\"&gt;&lt;/i&gt; &lt;div slot=\"tip\" class=\"el-upload__tip\"&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button @click=\"dialogFormVisible = false\"&gt;取 消&lt;/el-button&gt; &lt;el-button type=\"primary\" @click=\"addOrUpdateTradeMark\"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"tradeMark\", data() { return { // 对话框显示与隐藏控制的属性 dialogFormVisible: false, // 搜集品牌信息 tmForm:{ logoUrl:'', tmName:'' } }; }, mounted() { this.getPageList(); }, methods: { // 获取列表数据方法，在组件挂载完毕或当前页码改变时调用 async getPageList(pager = 1) { this.page = pager; const { page, limit } = this; // 获取品牌列表的接口 let result = await this.$API.tradeMark.reqTradeMarkList(page, limit); if (result.code === 200) { this.total = result.data.total; this.records = result.data.records; } }, // 点击添加品牌的按钮 showDialog() { // 显示对话框 this.dialogFormVisible = true; this.tmForm = { logoUrl:'', tmName:'' } }, // 修改某个品牌 updateTradeMark(row) { // row：当前用户选中的信息，携带id // 显示对话框 this.dialogFormVisible = true; // 将已有的品牌信息赋值给tmForm进行展示 // 将服务器返回品牌的信息直接赋值给tmForm进行展示 // 因为tmForm在对话框处作为v-model绑定的值，不能直接赋值，所以这里做一个对象浅拷贝 this.tmForm = {...row} }, //图片上传成功 handleAvatarSuccess(res, file) { // res：上传成功之后返回前端数据 // file：上传成功之后服务器返回前端数据 // 收集品牌图片数据，因为将来需要带给服务器 this.tmForm.logoUrl = res.data }, // 图片上传之前 beforeAvatarUpload(file) { const isJPG = file.type === \"image/jpeg\"; const isLt2M = file.size / 1024 / 1024 &lt; 2; if (!isJPG) { this.$message.error(\"上传头像图片只能是 JPG 格式!\"); } if (!isLt2M) { this.$message.error(\"上传头像图片大小不能超过 2MB!\"); } return isJPG &amp;&amp; isLt2M; }, // 确认按钮（添加品牌|修改品牌） async addOrUpdateTradeMark(){ this.dialogFormVisible=false let result = await this.$API.tradeMark.reqAddOrUpdateTradeMark(this.tmForm) if(result.code === 200){ // 弹出提示信息 this.$message({type:'success',message:this.tmForm.id?'修改品牌成功':'添加品牌成功'}) // 添加或修改品牌成功之后。需要再次获取品牌列表进行展示 // 如果添加品牌：停留在第一页，修改品牌应该留在当前页面 this.getPageList(this.tmForm.id?this.page:1) } } }, }; &lt;/script&gt; &lt;style&gt; .avatar-uploader .el-upload { border: 1px dashed #d9d9d9; border-radius: 6px; cursor: pointer; position: relative; overflow: hidden; } .avatar-uploader .el-upload:hover { border-color: #409eff; } .avatar-uploader-icon { font-size: 28px; color: #8c939d; width: 178px; height: 178px; line-height: 178px; text-align: center; } .avatar { width: 178px; height: 178px; display: block; } &lt;/style&gt; 表单验证功能elementUI提供表单验证功能（自定义校验规则–重点） &lt;template&gt; &lt;div&gt; &lt;!-- 对话框 :visible.sync:控制对话框显示与隐藏用的 Form 组件提供了表单验证的功能，只需要通过 rules 属性传入约定的验证规则，并将 Form-Item 的 prop 属性设置为需校验的字段名即可。校验规则参见 async-validator --&gt; &lt;el-dialog :title=\"tmForm.id ? '修改品牌' : '添加品牌'\" :visible.sync=\"dialogFormVisible\"&gt; &lt;!-- form表单：model属性，这个属性的作用是把表单的数据收集到那个对象的身上，将来表单验证也需要这个属性 --&gt; &lt;el-form style=\"width: 75%\" :model=\"tmForm\" :rules=\"rules\" ref=\"ruleForm\"&gt; &lt;el-form-item label=\"品牌名称\" label-width=\"100px\" prop=\"tmName\"&gt; &lt;el-input autocomplete=\"off\" v-model=\"tmForm.tmName\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"品牌LOGO\" label-width=\"100px\" prop=\"logoUrl\"&gt; &lt;el-upload class=\"avatar-uploader\" action=\"/dev-api/admin/product/fileUpload\" :show-file-list=\"false\" :on-success=\"handleAvatarSuccess\" :before-upload=\"beforeAvatarUpload\" &gt; &lt;img v-if=\"tmForm.logoUrl\" :src=\"tmForm.logoUrl\" class=\"avatar\" /&gt; &lt;i v-else class=\"el-icon-plus avatar-uploader-icon\"&gt;&lt;/i&gt; &lt;div slot=\"tip\" class=\"el-upload__tip\"&gt;只能上传jpg/png文件，且不超过500kb&lt;/div&gt; &lt;/el-upload&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;div slot=\"footer\" class=\"dialog-footer\"&gt; &lt;el-button @click=\"dialogFormVisible = false\"&gt;取 消&lt;/el-button&gt; &lt;el-button type=\"primary\" @click=\"addOrUpdateTradeMark\"&gt;确 定&lt;/el-button&gt; &lt;/div&gt; &lt;/el-dialog&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"tradeMark\", data() { // 自定义校验规则 var validatetmName = (rule, value, callback) =&gt; { if (value.length &lt; 2 || value.length &gt; 10) { callback(new Error('长度在 2 到 10 个字符')); }else{ callback() } }; return { // 表单验证 rules: { //品牌名称的验证规则 // require：必须校验字段，message 提示信息 trigger：用户行为设置（事件的设置：change，blur） tmName: [ { required: true, message: \"请输入品牌名称\", trigger: \"blur\" }, // 自定义校验规则 { validator: validatetmName, trigger: 'change' } ], // 品牌logo的验证规则 logoUrl: [{ required: true, message: \"请选择品牌图片\" }], }, }; }, methods: { // 获取列表数据方法，在组件挂载完毕或当前页码改变时调用 async getPageList(pager = 1) { this.page = pager; const { page, limit } = this; // 获取品牌列表的接口 let result = await this.$API.tradeMark.reqTradeMarkList(page, limit); if (result.code === 200) { this.total = result.data.total; this.records = result.data.records; } }, // 对话框确认按钮（添加品牌|修改品牌） addOrUpdateTradeMark() { this.$refs.ruleForm.validate(async (success) =&gt; { // 当全部验证字段都通过，再去书写业务逻辑 if (success) { this.dialogFormVisible = false; let result = await this.$API.tradeMark.reqAddOrUpdateTradeMark(this.tmForm); if (result.code === 200) { // 弹出提示信息 this.$message({ type: \"success\", message: this.tmForm.id ? \"修改品牌成功\" : \"添加品牌成功\", }); // 添加或修改品牌成功之后。需要再次获取品牌列表进行展示 // 如果添加品牌：停留在第一页，修改品牌应该留在当前页面 this.getPageList(this.tmForm.id ? this.page : 1); } } else { console.log('error submit!!'); return false; } }); }, }, }; &lt;/script&gt; 删除品牌操作 // 删除品牌 /admin/product/baseTrademark/remove/{id} delete export const reqDeleteTradeMark = id =&gt; request({url:`/admin/product/baseTrademark/remove/${id}`,method:'delete'}) //表格删除按钮 &lt;el-table-column label=\"操作\" width=\"width\" align=\"center\"&gt; &lt;template slot-scope=\"{ row }\"&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" size=\"mini\" @click=\"deleteTradeMark(row)\"&gt;删除&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;script&gt; // 删除品牌操作 deleteTradeMark(row){ // 弹框 this.$confirm(`你确定删除${row.tmName}?`, '提示', { confirmButtonText: '确定', cancelButtonText: '取消', type: 'warning' }).then(async () =&gt; { // 向服务器发请求 let result = await this.$API.tradeMark.reqDeleteTradeMark(row.id) console.log(result); // 如果成功删除 if(result.code == 200){ // 当用户点击确定按钮的时候会触发 this.$message({ type: 'success', message: '删除成功!' }); // 再次获取品牌列表数据 this.getPageList(this.records.length&gt;1?this.page:this.page-1) } }).catch(() =&gt; { // 当用户点击取消按钮会触发 this.$message({ type: 'info', message: '已取消删除' }); }); } &lt;/script&gt; 三级联动动态展示 由于项目中多次使用该模块，所以将其注册为全局组件 //书写相应的API接口 // 获取商品一级分类接口 /admin/product/getCategory1 get export const reqCategory1List = () =&gt; request({url:`/admin/product/getCategory1`,method:'get'}) // 获取商品二级分类接口 /admin/product/getCategory2/{category1Id} get export const reqCategory2List = category1Id =&gt; request({url:`/admin/product/getCategory2/${category1Id}`,method:'get'}) // 获取商品三级分类接口 /admin/product/getCategory3/{category2Id} get export const reqCategory3List = category2Id =&gt; request({url:`/admin/product/getCategory3/${category2Id}`,method:'get'}) &lt;template&gt; &lt;div&gt; &lt;!-- :inline代表的是行内表单，代表一行可以放置多个表单元素 --&gt; &lt;el-form :inline=\"true\" class=\"demo-form-inline\" :model=\"cFormId\"&gt; &lt;el-form-item label=\"一级分类\"&gt; &lt;!-- v-model收集的是当前选择option的id --&gt; &lt;el-select placeholder=\"请选择\" v-model=\"cFormId.category1Id\" @change=\"handler1\"&gt; &lt;el-option :label=\"c1.name\" :value=\"c1.id\" v-for=\"c1 in list1\" :key=\"c1.id\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"二级分类\"&gt; &lt;el-select placeholder=\"请选择\" v-model=\"cFormId.category2Id\" @change=\"handler2\"&gt; &lt;el-option :label=\"c2.name\" :value=\"c2.id\" v-for=\"c2 in list2\" :key=\"c2.id\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"三级分类\"&gt; &lt;el-select placeholder=\"请选择\" v-model=\"cFormId.category3Id\" @change=\"handler3\"&gt; &lt;el-option :label=\"c3.name\" :value=\"c3.id\" v-for=\"c3 in list3\" :key=\"c3.id\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"CategorySelect\", data() { return { // 一、二、三级分类的数据 list1:[], list2:[], list3:[], // 收集一、二、三级分类id cFormId:{ category1Id:'', category2Id:'', category3Id:'' } } }, // 组件挂载完毕，向服务器发请求，获取一级分类的数据 mounted() { this.getCategoryList1() }, methods: { // 获取一级分类的数据的方法 async getCategoryList1(){ const result = await this.$API.attr.reqCategory1List() if(result.code == 200){ this.list1 = result.data } }, // 一级分类select事件回调（当一级分类的option发生变化时获取相应二级分类的数据） async handler1(){ // 清除二、三级分类数据 this.list2 = [] this.list3 = [] // 如果不清除id，二三级分类依旧展示上一次选中的option this.cFormId.category2Id = '' this.cFormId.category3Id = '' const {category1Id} = this.cFormId this.$emit('getCategoryId',{categoryId:category1Id,level:1}) let result = await this.$API.attr.reqCategory2List(category1Id) if(result.code == 200){ this.list2 = result.data } }, // 二级分类select事件回调（当二级分类的option发生变化时获取相应三级分类的数据） async handler2(){ // 三级分类数据 this.list3 = [] this.cFormId.category3Id = '' const {category2Id} = this.cFormId this.$emit('getCategoryId',{categoryId:category2Id,level:2}) let result = await this.$API.attr.reqCategory3List(category2Id) if(result.code == 200){ this.list3 = result.data } }, // 三级分类select事件回调 handler3(){ const {category3Id} = this.cFormId this.$emit('getCategoryId',{categoryId:category3Id,level:3}) } }, }; &lt;/script&gt; 平台属性动态展示 // 获取平台属性接口 /admin/product/attrInfoList/{category1Id}/{category2Id}/{category3Id} get export const reqAttrList = (category1Id,category2Id,category3Id) =&gt; request({url:`/admin/product/attrInfoList/${category1Id}/${category2Id}/${category3Id}`,method:'get'}) &lt;template&gt; &lt;div&gt; &lt;el-card style=\"margin:20px 0\"&gt; &lt;CategorySelect @getCategoryId=\"getCategoryId\"/&gt; &lt;/el-card&gt; &lt;el-card&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\"&gt;添加属性&lt;/el-button&gt; &lt;el-table style=\"width: 100%\" border :data=\"attrList\"&gt; &lt;el-table-column type=\"index\" label=\"序号\" width=\"80\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"attrName\" label=\"属性名称\" width=\"150\"&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"属性值列表\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;el-tag type=\"success\" v-for=\"attrValue in row.attrValueList\" :key=\"attrValue.id\" style=\"margin:0 20px;\"&gt;{{attrValue.valueName}}&lt;/el-tag&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=\"操作\" width=\"150\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;el-button type=\"warning\" icon=\"el-icon-edit\" size=\"mini\"&gt;&lt;/el-button&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" size=\"mini\"&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Attr', data() { return { category1Id:'', category2Id:'', category3Id:'', // 接受平台属性字段 attrList:[] } }, methods: { // 获取平台属性数据 // 当用户确定三级分类的数据后，向服务器发请求获取平台属性进行展示 async getAttrList(){ const {category1Id,category2Id,category3Id} = this let result = await this.$API.attr.reqAttrList(category1Id,category2Id,category3Id) if(result.code === 200){ this.attrList = result.data } }, // 自定义事件回调 getCategoryId({categoryId,level}){ // 区分三级分类相应id，以及父组件进行存储 if(level==1){ this.category1Id = categoryId this.category2Id = '' this.category3Id = '' }else if(level==2){ this.category2Id = categoryId this.category3Id = '' }else{ // 代表三级分类的id有了 this.category3Id = categoryId this.getAttrList() } } }, } &lt;/script&gt; 平台属性之添加属性与修改属性 //相关API接口 // 添加或修改属性接口 /admin/product/saveAttrInfo post export const reqAddOrUpdateAttr = data =&gt; request({url:`/admin/product/saveAttrInfo`,method:'post',data}) // { // \"attrName\": \"\", 属性名 // \"attrValueList\": [ 属性名中的属性值，因为属性值可以是多个，因此需要的是数组 // { // \"attrId\": 0, 属性的id // \"valueName\": \"string\" 属性值 // } // ], // \"categoryId\": 0, category3Id // \"categoryLevel\": 3, // } &lt;template&gt; &lt;div&gt; &lt;el-card style=\"margin: 20px 0\"&gt; //向子组件传参，控制子组件的select下拉框在父组件切换到添加与修改属性的结构后禁用它 &lt;CategorySelect @getCategoryId=\"getCategoryId\" :show=\"!isShowTable\"/&gt; &lt;/el-card&gt; &lt;el-card&gt; &lt;div v-show=\"isShowTable\"&gt; //此处为平台属性动态展示代码 &lt;/div&gt; &lt;!-- 添加属性 | 修改属性的结构 --&gt; &lt;div v-show=\"!isShowTable\"&gt; &lt;el-form :inline=\"true\" ref=\"form\" label-width=\"80px\" :model=\"attrInfo\"&gt; &lt;el-form-item label=\"属性名\"&gt; &lt;el-input placeholder=\"请输入属性名\" v-model=\"attrInfo.attrName\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\" :disabled=\"!attrInfo.attrName\" @click=\"addAttrValue\"&gt;添加属性值&lt;/el-button&gt; &lt;el-button @click=\"isShowTable = true\"&gt;取消&lt;/el-button&gt; &lt;el-table style=\"width: 100%; margin: 20px 0\" border :data=\"attrInfo.attrValueList\"&gt; &lt;el-table-column type=\"index\" label=\"序号\" width=\"80\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"属性值名称\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;!-- 这里结构需要input与span来回切换 --&gt; &lt;el-input :ref=\"$index\" v-model=\"row.valueName\" placeholder=\"请输入属性值名称\" size=\"mini\" v-if=\"row.flag\" @blur=\"toLook(row)\" @keyup.native.enter=\"toLook(row)\"&gt;&lt;/el-input&gt; &lt;span v-else @click=\"toEdit(row,$index)\" style=\"display:block;\"&gt;{{row.valueName}}&lt;/span&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;!-- 气泡确认框 --&gt; &lt;el-popconfirm :title=\"`确定删除${row.valueName}?`\" @onConfirm=\"deleteAttrValue($index)\"&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" size=\"mini\" slot=\"reference\"&gt;&lt;/el-button&gt; &lt;/el-popconfirm&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-button type=\"primary\" @click=\"addOrUpdateAttr\" :disabled=\"attrInfo.attrValueList.length&lt;1\"&gt;保存&lt;/el-button&gt; &lt;el-button @click=\"isShowTable = true\"&gt;取消&lt;/el-button&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; &lt;!-- 引入第三方库深拷贝的方法 --&gt; import cloneDeep from 'lodash/cloneDeep'; export default { name: \"Attr\", data() { return { // 控制table表格的显示与隐藏 isShowTable: true, // 收集新增属性|修改属性使用 attrInfo: { attrName: \"\", //属性名 attrValueList: [], //属性值，因为属性值可以有多个因此用数组，每一个属性值都是一个对象需要attrId，valueName categoryId: 0, //三级分类的id categoryLevel: 3, //因为服务器也需要区分几级id }, } } methods: { // 添加属性值按钮的回调 addAttrValue(){ // 向属性值的数值添加元素 // attrId：是你相应属性的id，目前我们是添加属性值的操作，还没有相应的属性id，目前而言带给服务器的id为undefined // valueName：相应属性值的名称 this.attrInfo.attrValueList.push({ attrId:this.attrInfo.id, //对于修改某一个属性的时候，可以在已有的属性值基础之上新增新的属性值（新增属性值的时候，需要把已有的属性的id带上） valueName:'', //对于新增某一个属性的时候，不需要向服务器传递属性id，attrInfo中不存在id，故attrId的值为undefined（值为undefind的字段不携带给服务器） //flag属性：给每一个属性值添加一个标记flag，用户切换查看模式与编辑模式，好处：每一个属性值可以控制自己的模式切换 //当前flag属性是响应式数据（数据变化视图跟着变化） flag:true }) // 让新增的input框自动聚焦 this.$nextTick(()=&gt;{ this.$refs[this.attrInfo.attrValueList.length-1].focus() }) }, // 添加属性按钮的回调 addAttr(){ // 切换table显示与隐藏 this.isShowTable = false // 清除数据并收集三级分类id this.attrInfo = { attrName: \"\", //属性名 attrValueList: [], //属性值，因为属性值可以有多个因此用数组，每一个属性值都是一个对象需要attrId，valueName categoryId: this.category3Id, //三级分类的id categoryLevel: 3, //因为服务器也需要区分几级id } }, // 修改按钮，修改某个属性 updateAttr(row){ this.isShowTable = false // 将选中的属性赋值给attrInfo // 由于数据结构当中存在对象里面套数组，数组套对象，因此需要使用深拷贝解决这类问题 this.attrInfo = cloneDeep(row) // 在修改某一个属性的时候，将相应的属性值添加上flag标记 this.attrInfo.attrValueList.forEach(item =&gt; { this.$set(item,'flag',false) }); }, // 切换为查看模式，显示span toLook(row){ // row形参是当前用户添加的最新的属性值 // 如果属性值为空不能作为新的属性值，需要给用户提示，让他重新输入 if(row.valueName.trim() == \"\"){ this.$message(\"请你输入一个不为空的属性值\") return; } // 新增的属性值不能与已有属性值重复 let isRepeat = this.attrInfo.attrValueList.some(item =&gt; { // 需要将row从数组里面判断去除 if(row !== item){ return row.valueName == item.valueName } }) if(isRepeat){ this.$message(\"该属性值已存在，请重新输入\") return; } row.flag = false }, // 切换到编辑模式 toEdit(row,index){ row.flag=true // 获取input节点，实现自动聚焦 // 需要注意，点击span的时候，切换为input变为编辑模式，但是需要注意，对于浏览器而言，页面重绘与重排耗时间 // 因此我们不可能一点击span就立马获取到input // $nextTick()，当节点渲染完毕之后执行一次 this.$nextTick(()=&gt;{ // 获取相应的input实现聚焦 this.$refs[index].focus() }) }, // 气泡确认框确定按钮的回调 deleteAttrValue(index){ // 当前删除属性值的操作是不需要发请求的 this.attrInfo.attrValueList.splice(index,1) }, // 保存按钮，进行添加属性或修改属性的操作 async addOrUpdateAttr(){ // 整理参数：如果用户添加很多属性值，且属性值为空的不应该提交给服务器 // 提交给服务器数据当中不应该出现flag字段 this.attrInfo.attrValueList = this.attrInfo.attrValueList.filter(item =&gt; { // 过滤掉属性值不是空的 if(item.valueName != ''){ // 删除flag属性 delete item.flag return true } }) // 判断所搜集到数组长度，大于等于一才发请求，切换展示平台属性 if(this.attrInfo.attrValueList.length&gt;=1){ try{ // 发请求 await this.$API.attr.reqAddOrUpdateAttr(this.attrInfo) // 展示平台属性的信号量进行切换 this.isShowTable = true this.$message({type:'success',message:'保存成功'}) // 保存成功以后需要再次发请求获取平台属性进行展示 this.getAttrList() }catch(error){ this.$message('保存失败') } } } } } &lt;/script&gt; SPU管理模块列表动态展示 SPU管理模块介绍：SPU你可以理解为类People类【SPU】实例:【SKU】小明：小明 18 男 等等小红：小红 88 女 等等 // 获取SPU列表数据的接口 /admin/product/{page}/{limit} get page limit category3Id export const reqSpuList = (page,limit,category3Id) =&gt; request({url:`/admin/product/${page}/${limit}`,method:'get',params:{category3Id}}) &lt;template&gt; &lt;div&gt; &lt;el-card style=\"margin:20px 0\"&gt; &lt;CategorySelect @getCategoryId=\"getCategoryId\" :show=\"!isShow\"/&gt; &lt;/el-card&gt; &lt;el-card&gt; &lt;!-- 底部这里将来有三部分进行切换 --&gt; &lt;div v-show=\"scene==0\"&gt; &lt;!-- 展示spu列表的结构 --&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\" :disabled=\"!category3Id\" @click=\"addSpu\"&gt;添加SPU&lt;/el-button&gt; &lt;el-table style=\"width: 100%\" border :data=\"records\"&gt; &lt;el-table-column type=\"index\" label=\"序号\" width=\"80\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"spuName\" label=\"SPU名称\" width=\"width\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"description\" label=\"SPU描述\" width=\"width\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;!-- 这里按钮将来用hintButton替换 --&gt; &lt;HintButton type=\"success\" icon=\"el-icon-plus\" size=\"mini\" title=\"添加sku\"&gt;&lt;/HintButton&gt; &lt;HintButton type=\"warning\" icon=\"el-icon-edit\" size=\"mini\" title=\"修改spu\" @click=\"updateSpu(row)\"&gt;&lt;/HintButton&gt; &lt;HintButton type=\"info\" icon=\"el-icon-info\" size=\"mini\" title=\"查看当前spu全部sku列表\"&gt;&lt;/HintButton&gt; &lt;HintButton type=\"danger\" icon=\"el-icon-delete\" size=\"mini\" title=\"删除spu\"&gt;&lt;/HintButton&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;el-pagination style=\"text-align:center;\" :current-page=\"page\" :page-sizes=\"[3, 5, 10]\" :page-size=\"limit\" layout=\"prev, pager, next, jumper, -&gt;, total, sizes\" :total=\"total\" @current-change=\"getSpuList\" @size-change=\"handleSizeChange\"&gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;SpuForm v-show=\"scene==1\"&gt;&lt;/SpuForm&gt; &lt;SkuForm v-show=\"scene==2\"&gt;&lt;/SkuForm&gt; &lt;/el-card&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import SkuForm from './SkuForm' import SpuForm from './SpuForm' export default { name:'Spu', components:{ SkuForm, SpuForm }, data() { return { // 分别是分类的id category1Id:'', category2Id:'', category3Id:'', // 控制三级联动的可操作性 isShow:true, page:1, //分页器当前第几页 limit:3, //每一页需要展示多少条数据 records:[], //spu列表的数据 total:0, //分页器一共需要展示的数据条数 scene:0, // 0 代表展示SPU列表数据 1 添加SPU|添加SPU 2 添加SKU } }, methods: { // 获取SPU列表数据的方法 async getSpuList(pages=1){ this.page = pages const {page,limit,category3Id} = this let result = await this.$API.spu.reqSpuList(page,limit,category3Id) if(result.code === 200){ this.records = result.data.records this.total = result.data.total } }, // 三级联动自定义事件回调 getCategoryId({categoryId,level}){ if(level == 1){ this.category1Id = categoryId // 清除二、三级分类的id this.category2Id = '' this.category3Id = '' }else if(level == 2){ this.category2Id = categoryId this.category3Id = '' }else{ this.category3Id = categoryId // 获取SPU列表数据 this.getSpuList() } }, // 当分页器的某一个展示数据条数发生变化的回调 handleSizeChange(limit){ this.limit = limit this.getSpuList() }, // 添加Spu按钮的回调 addSpu(){ this.scene = 1 }, // 修改Spu updateSpu(row){ this.scene = 1 } }, } &lt;/script&gt; SpuForm组件数据收集与展示 &lt;template&gt; &lt;div&gt; &lt;el-form ref=\"form\" label-width=\"80px\"&gt; &lt;el-form-item label=\"SPU名称\"&gt; &lt;el-input placeholder=\"SPU名称\" v-model=\"spu.spuName\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"品牌\"&gt; &lt;el-select placeholder=\"请选择品牌\" v-model=\"spu.tmId\"&gt; &lt;el-option :label=\"tm.tmName\" :value=\"tm.id\" v-for=\"tm in tradeMarkList\" :key=\"tm.id\" &gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"SPU描述\"&gt; &lt;el-input type=\"textarea\" rows=\"4\" placeholder=\"SPU描述\" v-model=\"spu.description\" &gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"SPU图片\"&gt; &lt;!-- 上传图片：action图片上传的地址 list-type：文件列表的类型 on-preview：图片预览的时候触发 on-remove：当删除图片的时候触发 file-list：照片墙需要展示的数据【数组：数据里面的元素务必有name、url属性】 照片墙在删除或添加图片的时候，需要收集数据的，预览不需要 --&gt; &lt;el-upload action=\"/dev-api/admin/product/fileUpload\" list-type=\"picture-card\" :file-list=\"spuImageList\" :on-preview=\"handlePictureCardPreview\" :on-remove=\"handleRemove\" :on-success=\"handleSuccess\" &gt; &lt;i class=\"el-icon-plus\"&gt;&lt;/i&gt; &lt;/el-upload&gt; &lt;el-dialog :visible.sync=\"dialogVisible\"&gt; &lt;img width=\"100%\" :src=\"dialogImageUrl\" alt=\"\" /&gt; &lt;/el-dialog&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"销售属性\"&gt; &lt;el-select :placeholder=\"`还有${unSelectSaleAttr.length}未选择`\" v-model=\"attrIdAndAttrName\"&gt; &lt;el-option :label=\"unSelect.name\" :value=\"`${unSelect.id}:${unSelect.name}`\" v-for=\"unSelect in unSelectSaleAttr\" :key=\"unSelect.id\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;el-button type=\"primary\" icon=\"el-icon-plus\" :disabled=\"!attrIdAndAttrName\" @click=\"addSaveAttr\"&gt;添加销售属性&lt;/el-button&gt; &lt;!-- 展示当前SPU属于自己的销售属性 --&gt; &lt;el-table style=\"width: 100%\" border :data=\"spu.spuSaleAttrList\"&gt; &lt;el-table-column type=\"index\" label=\"序号\" width=\"80\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"saleAttrName\" label=\"属性名\" width=\"width\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"属性名称列表\" width=\"width\"&gt; &lt;template slot-scope=\"{ row, $index }\"&gt; &lt;!-- el-tag：用户展示已有的属性值列表的数据 @close：删除所点击属性值标签--&gt; &lt;el-tag :key=\"tag.id\" v-for=\"(tag,index) in row.spuSaleAttrValueList\" closable :disable-transitions=\"false\" @close=\"row.spuSaleAttrValueList.splice(index,1)\" &gt; {{ tag.saleAttrValueName }} &lt;/el-tag&gt; &lt;!-- 底下的结构可以当作之前平台属性span与input的切换 --&gt; &lt;!-- 注意：@keyup.enter.native这里不能直接调用handleInputConfirm(row) 直接调用该方法会有bug，点击回车键同时触发回车事件和失去焦点事件，即andleInputConfirm(row)会调用两次 解决办法：在回车事件中调用失去焦点事件 --&gt; &lt;el-input class=\"input-new-tag\" v-if=\"row.inputVisible\" v-model=\"row.inputValue\" ref=\"saveTagInput\" size=\"small\" @keyup.enter.native=\"$event.target.blur\" @blur=\"handleInputConfirm(row)\" &gt; &lt;/el-input&gt; &lt;el-button v-else class=\"button-new-tag\" size=\"small\" @click=\"addSaveAttrValue(row)\"&gt;添加&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;!-- @click点击删除对应属性 --&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" size=\"mini\" @click=\"spu.spuSaleAttrList.splice($index,1)\"&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\"&gt;保存&lt;/el-button&gt; &lt;el-button @click=\"$emit('changeScene', 0)\"&gt;取消&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"SpuForm\", data() { return { dialogImageUrl: \"\", //照片墙图片地址 dialogVisible: false, //控制照片墙预览图片对话框的显示与隐藏 //存储spu信息，是带给服务器的数据 //spu属性初始化的时候是一个空对象，在修改SPU的时候，会向服务器发请求，返回SPU信息（对象），在修改的时候可以利用服务器返回的对象收集最新的数据提交给服务器 //添加SPU，如果是添加SPU的时候并没有向服务器发请求，所以这里初始化不能是空对象，需要添加收集数据的字段 spu: { category3Id: 0, //三级分类的id description: \"\", //描述 spuName: \"\", //SPU名称 tmId: 0, //平台id // 收集SPU图片的信息 spuImageList: [ //要搜集数据对象的数据结构 // { // id: 0, // imgName: \"string\", // imgUrl: \"string\", // spuId: 0, // }, ], // 收集平台属性与属性值 spuSaleAttrList: [ //要搜集数据对象的数据结构 // { // baseSaleAttrId: 0, // id: 0, // saleAttrName: \"string\", // spuId: 0, // spuSaleAttrValueList: [ // { // baseSaleAttrId: 0, // id: 0, // isChecked: \"string\", // saleAttrName: \"string\", // saleAttrValueName: \"string\", // spuId: 0, // }, // ], // }, ], }, tradeMarkList: [], //存储品牌信息 spuImageList: [], //存储spu图片信息 saleAttrList: [], //存储平台销售属性数据 attrIdAndAttrName:'' //收集未选择的销售属性id和名字 }; }, methods: { // 图片墙删除某一个属性的时候会触发 handleRemove(file, fileList) { // file：代表的是删除的那张图片 // fileList：照片墙删除某一张图片以后，剩余的其它图片 // 收集照片墙的数据 // 对于已有的图片【照片墙中显示的图片，有name、url字段的】，因为照片墙展示数据务必要有这两个属性 // 对了服务器而言，不需要name、url字段，将来对于有的图片的数据在提交给服务器的时候，需要处理 this.spuImageList = fileList }, // 照片墙图片预览的回调 handlePictureCardPreview(file) { // file参数：你所点击预览的图片 // 将图片地址赋值给这个属性 this.dialogImageUrl = file.url; //对话框显示 this.dialogVisible = true; }, // 点击修改Spu按钮，初始化SpuForm数据 async initSpuDate(spu) { // 获取spu信息 let result = await this.$API.spu.reqSpu(spu.id); if (result.code === 200) { this.spu = result.data; } // 获取品牌信息 let tradeMarkResult = await this.$API.spu.reqTrademarkList(); if (tradeMarkResult.code === 200) { this.tradeMarkList = tradeMarkResult.data; } // 获取spu图片数据 let spuImageResult = await this.$API.spu.reqSpuImageList(spu.id); if (spuImageResult.code === 200) { let listArr = spuImageResult.data; // 由于图片墙显示图片的数据需要数组，数组里面的元素需要name与url字段 // 需要把服务器返回的数据进行修改 listArr.forEach((item) =&gt; { item.name = item.imgName; item.url = item.imgUrl; }); // 把整理好的数据赋值 this.spuImageList = listArr; } // 获取平台全部销售属性 let saleAttrResult = await this.$API.spu.reqBaseSaleAttrList(); if (saleAttrResult.code === 200) { this.saleAttrList = saleAttrResult.data; } }, // 照片墙图片上传成功的回调 handleSuccess(response, file, fileList){ // response：服务器返回的一些信息 // file：上传成功的图片的信息 fileList：上传成功后全部图片的信息 this.spuImageList = fileList }, // 添加新的销售属性 addSaveAttr(){ // 已经收集需要添加的销售属性信息 // 把收集到的销售属性数据进行分割 const [baseSaleAttrId,saleAttrName] = this.attrIdAndAttrName.split(':') // 向SPU对象的spuSaleAttrValueList属性里面添加新的销售属性 let newSale = {baseSaleAttrId,saleAttrName,spuSaleAttrValueList:[]} this.spu.spuSaleAttrList.push(newSale) // 清空数据 this.attrIdAndAttrName = '' }, // 添加属性值按钮的回调 addSaveAttrValue(row) { //点击销售属性值当中添加按钮的时候，需要有button变为input，通过当前销售属性的inputVisible控制 //挂载在销售属性身上的响应式数据inputVisible，控制button与input切换 this.$set(row,'inputVisible',true) //通过响应式数据inputValue字段收集新增的销售属性值 this.$set(row,'inputValue','') }, //el-input失去焦点的事件 handleInputConfirm(row){ // 从销售属性对象中解构出销售属性值所需的字段 const {baseSaleAttrId,inputValue} = row // 新增的销售属性值名称不能为空 if(inputValue.trim()==''){ this.$message('属性值不能为空') return; } // 新增的销售属性值名称不能重复 let isRepeat = row.spuSaleAttrValueList.some(item =&gt; { return inputValue == item.saleAttrValueName }) if(isRepeat){ this.$message('属性值不能重复') return; } // 新增的销售属性值 let newSaleAttrValue = {baseSaleAttrId,saleAttrValueName:inputValue} row.spuSaleAttrValueList.push(newSaleAttrValue) // 修改inputVisible为false，显示button row.inputVisible = false; }, }, computed: { // 计算出没选择的销售属性 unSelectSaleAttr(){ // 整个平台的销售属性一共三个，颜色，尺寸，版本 --- saleAttrList // 当前SPU拥有的属于自己的销售属性 --- spu.spuSaleAttrList let result = this.saleAttrList.filter(item1 =&gt; { return this.spu.spuSaleAttrList.every(item2 =&gt; { return item1.name!=item2.saleAttrName }) }) return result } }, }; &lt;/script&gt; &lt;style&gt; .el-tag + .el-tag { margin-left: 10px; } .button-new-tag { margin-left: 10px; height: 32px; line-height: 30px; padding-top: 0; padding-bottom: 0; } .input-new-tag { width: 90px; margin-left: 10px; vertical-align: bottom; } &lt;/style&gt; SPU模块完成修改spu的保存与取消操作Spu父组件相关代码 &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;HintButton type=\"warning\" icon=\"el-icon-edit\" size=\"mini\" title=\"修改spu\" @click=\"updateSpu(row)\"&gt;&lt;/HintButton&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!-- SpuForm子组件 --&gt; &lt;SpuForm v-show=\"scene==1\" @changeScene=\"changeScene\" ref=\"spu\"&gt;&lt;/SpuForm&gt; &lt;script&gt; import SpuForm from './SpuForm' // 修改Spu updateSpu(row){ this.scene = 1 // 通过$refs调用子组件SupForm身上的方法，让子组件向服务器发请求获取数据 this.$refs.spu.initSpuDate(row) }, // SpuForm取消按钮自定义事件回调 changeScene({scene,flag}){ // flag形参为了区分保存按钮是添加还是修改 // 切换结构（场景） this.scene = scene // 子组件通知父组件切换场景，需要再次获取SPU列表的数据进行展示 if(flag=='修改'){ this.getSpuList(this.page) }else{ this.getSpuList() } }, &lt;/script&gt; 子组件SpuForm相关代码 &lt;el-form-item&gt; &lt;el-button type=\"primary\" @click=\"addOrUpdateSpu\"&gt;保存&lt;/el-button&gt; &lt;el-button @click=\"cancel\"&gt;取消&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;script&gt; // 保存按钮的回调 async addOrUpdateSpu() { // 整理参数：需要整理照片墙的数据 // 携带参数，对于图片，需要携带imgName,imgUrl字段 // map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值 this.spu.spuImageList = this.spuImageList.map((item) =&gt; { return { imgName: item.name, imgUrl: (item.response &amp;&amp; item.response.data) || item.url, }; }); // 发请求 let result = await this.$API.spu.reqAddOrUpdateSpu(this.spu); if (result.code == 200) { // 提示 this.$message({ type: \"success\", message: \"保存成功\" }); // 通知父组件回到场景0，通过是否有id字段来判断用户当前是添加还是修改SPU this.$emit(\"changeScene\", {scene:0,flag:this.spu.id?'修改':'添加'}); } // 清除数据 // Object.assign：es6中新增的方法可以合并对象 // 组件实例this._data，可以操作data当中响应式数据 // this.$options可以获取配置对象，配置对象的data函数执行，返回的响应式数据是为空的 Object.assign(this._data,this.$options.data()) }, // 取消按钮 cancel(){ // 取消按钮的回调，添加父亲切换场景为0 $emit('changeScene', {scene:0,flag:''}) // 清理数据 // Object.assign：es6中新增的方法可以合并对象 // 组件实例this._data，可以操作data当中响应式数据 // this.$options可以获取配置对象，配置对象的data函数执行，返回的响应式数据是为空的 Object.assign(this._data,this.$options.data()) } &lt;/script&gt; SPU模块完成添加spu的保存与删除操作Spu父组件相关代码 &lt;el-button type=\"primary\" icon=\"el-icon-plus\" :disabled=\"!category3Id\" @click=\"addSpu\"&gt;添加SPU&lt;/el-button&gt; &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;el-popconfirm title=\"这是一段内容确定删除吗？\" @onConfirm=\"deleteSpu(row)\"&gt; &lt;HintButton type=\"danger\" icon=\"el-icon-delete\" size=\"mini\" title=\"删除spu\" slot=\"reference\"&gt;&lt;/HintButton&gt; &lt;/el-popconfirm&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;script&gt; // 添加Spu按钮的回调 addSpu(){ this.scene = 1 // 通过$refs调用子组件SupForm身上的方法，让子组件向服务器发请求获取数据 this.$refs.spu.addSpuDate(this.category3Id) }, // 删除Spu按钮 async deleteSpu(row){ let result = await this.$API.spu.reqDeleteSpu(row.id) if(result.code === 200){ this.$message({type:'success',message:\"删除成功\"}) this.getSpuList(this.records.length&gt;1 ? this.page : this.page-1) }else{ this.$message({type:'error',message:\"删除失败\"}) } } &lt;/script&gt; 子组件SpuForm相关代码 &lt;script&gt; // 点击添加Spu按钮的时候，发请求的函数 async addSpuDate(category3Id) { // 添加SPU的时候三级列表的id this.spu.category3Id = category3Id // 获取品牌信息 let tradeMarkResult = await this.$API.spu.reqTrademarkList(); if (tradeMarkResult.code === 200) { this.tradeMarkList = tradeMarkResult.data; } // 获取平台全部销售属性 let saleAttrResult = await this.$API.spu.reqBaseSaleAttrList(); if (saleAttrResult.code === 200) { this.saleAttrList = saleAttrResult.data; } }, &lt;/script&gt; Sku的展示、收集与保存操作书写相关请求的接口的函数 // 获取spu图片 /admin/product/spuImageList/{spuId} get export const reqSpuImageList = spuId =&gt; request({url:`/admin/product/spuImageList/${spuId}`,method:'get'}) // 获取平台属性 /admin/product/attrInfoList/{category1Id}/{category2Id}/{category3Id} get export const reqAttrList = (category1Id,category2Id,category3Id) =&gt; request({url:`/admin/product/attrInfoList/${category1Id}/${category2Id}/${category3Id}`,method:'get'}) // 获取spu销售属性 /admin/product/spuSaleAttrList/{spuId} get export const reqSpuSaleAttrList = spuId =&gt; request({url:`/admin/product/spuSaleAttrList/${spuId}`,method:'get'}) // 添加sku /admin/product/saveSkuInfo post export const reqSaveSkuInfo = data =&gt; request({url:'/admin/product/saveSkuInfo',method:'post',data}) Spu父组件相关代码 &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;HintButton type=\"success\" icon=\"el-icon-plus\" size=\"mini\" title=\"添加sku\" @click=\"addSku(row)\"&gt;&lt;/HintButton&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;SkuForm v-show=\"scene==2\" ref=\"sku\" @changeScenes=\"changeScenes\"&gt;&lt;/SkuForm&gt; &lt;script&gt; // 添加Sku按钮的回调 addSku(row){ // 切换场景 this.scene = 2 // 通过$refs调用子组件SkuForm身上的方法，让子组件向服务器发请求获取数据 this.$refs.sku.getSkuDate(this.category1Id,this.category2Id,row) }, // SkuForm取消按钮自定义事件回调 changeScenes(scene){ // 切换结构（场景） this.scene = scene } &lt;script&gt; SkuForm组件相关代码 &lt;template&gt; &lt;div&gt; &lt;el-form ref=\"form\" label-width=\"80px\"&gt; &lt;el-form-item label=\"SPU名称\"&gt;{{spu.spuName}}&lt;/el-form-item&gt; &lt;el-form-item label=\"SKU名称\"&gt; &lt;el-input placeholder=\"SKU名称\" v-model=\"skuInfo.skuName\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"价格(元)\"&gt; &lt;el-input placeholder=\"价格(元)\" type=\"number\" v-model=\"skuInfo.price\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"重量(千克)\"&gt; &lt;el-input placeholder=\"重量(千克)\" v-model=\"skuInfo.weight\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"规格描述\"&gt; &lt;el-input type=\"textarea\" placeholder=\"规格描述\" rows=\"4\" v-model=\"skuInfo.skuDesc\"&gt;&lt;/el-input&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"平台属性\"&gt; &lt;el-form :inline=\"true\" ref=\"form\" label-width=\"80px\"&gt; &lt;el-form-item :label=\"attr.attrName\" v-for=\"attr in attrInfoList\" :key=\"attr.id\"&gt; &lt;el-select placeholder=\"请选择\" v-model=\"attr.attrIdAndValueId\"&gt; &lt;el-option :label=\"attrValue.valueName\" :value=\"`${attr.id}:${attrValue.id}`\" v-for=\"attrValue in attr.attrValueList\" :key=\"attrValue.id\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"销售属性\"&gt; &lt;el-form :inline=\"true\" ref=\"form\" label-width=\"80\"&gt; &lt;el-form-item :label=\"saleAttr.saleAttrName\" v-for=\"saleAttr in spuSaveAttrList\" :key=\"saleAttr.id\"&gt; &lt;el-select placeholder=\"请选择\" v-model=\"saleAttr.attrIdAndValueId\"&gt; &lt;el-option :label=\"saleAttrValue.saleAttrValueName\" :value=\"`${saleAttr.id}:${saleAttrValue.id}`\" v-for=\"saleAttrValue in saleAttr.spuSaleAttrValueList\" :key=\"saleAttrValue.id\"&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/el-form-item&gt; &lt;el-form-item label=\"图片列表\"&gt; &lt;el-table style=\"width: 100%\" border :data=\"spuImageList\" @selection-change=\"handleSelectionChange\"&gt; &lt;el-table-column type=\"selection\" width=\"80\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"图片\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;img :src=\"row.imgUrl\" style=\"width:100px;height:100px;\"&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"imgName\" label=\"名称\" width=\"width\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;el-button type=\"primary\" v-if=\"row.isDefault == 0\" @click=\"changeDefault(row)\"&gt;设置默认&lt;/el-button&gt; &lt;el-button v-else&gt;默认&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-form-item&gt; &lt;el-form-item&gt; &lt;el-button type=\"primary\" @click=\"save\"&gt;保存&lt;/el-button&gt; &lt;el-button @click=\"cancel\"&gt;取消&lt;/el-button&gt; &lt;/el-form-item&gt; &lt;/el-form&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: \"SkuForm\", data() { return { // 存储图片的信息 spuImageList: [], // 存储销售属性 spuSaveAttrList: [], // 存储平台属性的数据 attrInfoList: [], // 收集sku信息 skuInfo: { // 第一大类收集的数据，父组件的数据 category3Id: 0, spuId: 0, tmId: 0, // 第二类，需要通过数据双向绑定收集 skuName: \"\", price: 0, weight: \"\", skuDesc: \"\", // 第三类，需要自己书写代码 // 平台属性 skuAttrValueList: [ // { // attrId: 0, // valueId: 0, // }, ], // 收集图片字段 skuDefaultImg: \"\", skuImageList: [ // { // imgName: \"string\", // imgUrl: \"string\", // isDefault: \"string\", // spuImgId: 0, // }, ], // 销售属性 skuSaleAttrValueList: [ // { // saleAttrId: 0, // saleAttrValueId: 0, // }, ], }, spu:{}, // 收集图片的数据字段，但是需要注意，收集的数据字段缺少isDefault字段，将来提交给服务器的时候，需要整理参数 imageList:[] }; }, methods: { // 获取SkuForm的数据 async getSkuDate(category1Id, category2Id, spu) { // 收集父组件给予的数据 this.skuInfo.category3Id = spu.category3Id this.skuInfo.spuId = spu.id this.skuInfo.tmId = spu.tmId this.spu = spu // 获取图片数据 let result1 = await this.$API.spu.reqSpuImageList(spu.id); if (result1.code === 200) { let imageList = result1.data imageList.forEach(item =&gt; { item.isDefault = 0 }) this.spuImageList = imageList } // 获取销售属性的数据 let result2 = await this.$API.spu.reqSpuSaleAttrList(spu.id); if (result2.code === 200) { this.spuSaveAttrList = result2.data; } // 存储平台属性的数据 let result3 = await this.$API.spu.reqAttrList( category1Id, category2Id, spu.category3Id ); if (result3.code === 200) { this.attrInfoList = result3.data; } }, // table表格复选框的事件 handleSelectionChange(selection){ // 获取到用户选中图片的信息数据，但是需要注意，当前收集的数据当中，缺少isDefault字段 this.imageList = selection }, // 排他操作 changeDefault(row){ // 图片列表的数据的isDefault字段变为0 this.spuImageList.forEach(item =&gt; { item.isDefault = 0 }) // 当前点击的那个图片的数据变为1 row.isDefault = 1 // 收集默认图片的地址 this.skuInfo.skuDefaultImg = row.imgUrl }, // 取消按钮的回调 cancel(){ // 触发自定义事件切换场景 this.$emit('changeScenes',0) // 清除数据 Object.assign(this._data,this.$options.data()) }, // 保存按钮的事件 async save(){ // 整理参数 // 整理平台属性 const {attrInfoList,skuInfo,spuSaveAttrList,imageList} = this // 将收集到的参数整理一下 attrIdAndValueId skuInfo.skuAttrValueList = attrInfoList.reduce((prev,item) =&gt; { if(item.attrIdAndValueId){ const [attrId,valueId] = item.attrIdAndValueId.split(\":\") prev.push({attrId,valueId}) } return prev },[]) // 整理销售属性 skuInfo.skuSaleAttrValueList = spuSaveAttrList.reduce((prev,item) =&gt; { if(item.attrIdAndValueId){ const [saleAttrId,saleAttrValueId] = item.attrIdAndValueId.split(\":\") prev.push({saleAttrId,saleAttrValueId}) } return prev },[]) // 整理图片的数据 skuInfo.skuImageList = imageList.map(item =&gt; { return { imgName:item.imgName, imgUrl:item.imgUrl, isDefault:item.isDefault, spuImgId:item.id, } }) // 发请求 let result = await this.$API.spu.reqSaveSkuInfo(skuInfo) if(result.code === 200){ this.$message({type:'success',message:\"添加成功\"}) // 触发自定义事件切换场景 this.$emit('changeScenes',0) } } }, }; &lt;/script&gt; &lt;style&gt; &lt;/style&gt; Sku列表的展示与loading效果 &lt;el-table-column prop=\"prop\" label=\"操作\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;HintButton type=\"info\" icon=\"el-icon-info\" size=\"mini\" title=\"查看当前spu全部sku列表\" @click=\"handler(row)\"&gt;&lt;/HintButton&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;!-- 查看Sku的对话框 @before-close方法：关闭前的回调，会暂停 Dialog 的关闭 --&gt; &lt;el-dialog :title=\"`${spu.spuName}的sku列表`\" :visible.sync=\"dialogTableVisible\" @before-close=\"close\"&gt; &lt;el-table :data=\"skuList\" border style=\"width: 100%;\" v-loading=\"loading\"&gt; &lt;el-table-column width=\"width\" prop=\"skuName\" label=\"名称\" &gt; &lt;/el-table-column&gt; &lt;el-table-column width=\"width\" prop=\"price\" label=\"价格\" &gt; &lt;/el-table-column&gt; &lt;el-table-column width=\"width\" prop=\"weight\" label=\"重量\" &gt; &lt;/el-table-column&gt; &lt;el-table-column width=\"width\" label=\"默认图片\" &gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;img :src=\"row.skuDefaultImg\" style=\"width:100px;height:100px;\"&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;/el-dialog&gt; &lt;script&gt; data(){ return { spu:{}, //存储所点击的sku信息 skuList:[], //存储sku列表的数据 loading:true, //对话框的加载效果 } } methods:{ // 查看Sku的按钮回调 async handler(spu){ // 显示sku列表的对话框 this.dialogTableVisible = true this.spu = spu let result = await this.$API.spu.reqSkuList(spu.id) if(result.code === 200){ this.skuList = result.data // 取消加载效果 this.loading = false } }, // 关闭sku对话框的回调 close(){ // 修改loading属性 this.loading = true // 清除sku列表的数据 this.skuList = [] // 关闭对话框 done() } } &lt;/script&gt; sku模块数据展示、上架与下架操作 import request from '@/utils/request' // sku列表接口 /admin/product/list/{page}/{limit} get export const reqSkuList = (page,limit) =&gt; request({url:`/admin/product/list/${page}/${limit}`,method:'get'}) // 上架 admin/product/onSale/{skuId} get export const reqSale = skuId =&gt; request({url:`admin/product/onSale/${skuId}`,method:'get'}) // 下架 admin/product/cancelSale/{skuId} get export const reqCancel = skuId =&gt; request({url:`admin/product/cancelSale/${skuId}`,method:'get'}) &lt;template&gt; &lt;div&gt; &lt;el-table style=\"width: 100%\" :data=\"records\" border &gt; &lt;el-table-column type=\"index\" label=\"序号\" width=\"80\" align=\"center\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"skuName\" label=\"名称\" width=\"width\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"skuDesc\" label=\"描述\" width=\"width\"&gt;&lt;/el-table-column&gt; &lt;el-table-column label=\"默认图片\" width=\"110\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;img :src=\"row.skuDefaultImg\" alt=\"\" style=\"width:80px;height:80px;\"&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"weight\" label=\"重量\" width=\"80\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"price\" label=\"价格\" width=\"80\"&gt;&lt;/el-table-column&gt; &lt;el-table-column prop=\"prop\" label=\"label\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;el-button type=\"success\" icon=\"el-icon-top\" size=\"mini\" v-if=\"row.isSale == 0\" @click=\"sale(row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"success\" icon=\"el-icon-bottom\" size=\"mini\" v-else @click=\"cancel(row)\"&gt;&lt;/el-button&gt; &lt;el-button type=\"primary\" icon=\"el-icon-edit\" size=\"mini\" @click=\"edit\"&gt;&lt;/el-button&gt; &lt;el-button type=\"info\" icon=\"el-icon-info\" size=\"mini\"&gt;&lt;/el-button&gt; &lt;el-button type=\"danger\" icon=\"el-icon-delete\" size=\"mini\"&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页器 --&gt; &lt;el-pagination style=\"text-align:center;margin:20px 0;\" @current-change=\"getSkuList\" @size-change=\"handleSizeChange\" :current-page=\"page\" :page-sizes=\"[3, 5, 10]\" :page-size=\"limit\" layout=\"prev, pager, next, jumper, -&gt;, sizes, total\" :total=\"total\"&gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Sku', data() { return { page:1, //代表当前第几页 limit:5, //代表当前页面有几条数据 records:[], //存储Sku列表的数据 total:0, //存储分页器一共展示的数据 } }, mounted() { // 获取sku列表数据的方法 this.getSkuList() }, methods: { // 获取sku列表数据 async getSkuList(pages = 1){ this.page = pages // 解构出默认参数 const {page,limit} = this let result = await this.$API.sku.reqSkuList(page,limit) if(result.code === 200){ this.total = result.data.total this.records = result.data.records } }, // 分页器修改每页展示数据条数 handleSizeChange(limit){ this.limit = limit this.getSkuList() }, // 上架按钮回调 async sale(row){ let result = await this.$API.sku.reqSale(row.id) if(result.code == 200){ row.isSale = 1 this.$message({type:'success',message:\"上架成功\"}) } }, // 下架按钮回调 async cancel(row){ let result = await this.$API.sku.reqCancel(row.id) if(result.code == 200){ row.isSale = 0 this.$message({type:'success',message:\"下架成功\"}) } }, // 编辑按钮的回调 edit(){ this.$message(\"正在开发中\") } }, } &lt;/script&gt; Sku详情查看 &lt;el-table-column prop=\"prop\" label=\"label\" width=\"width\"&gt; &lt;template slot-scope=\"{row,$index}\"&gt; &lt;el-button type=\"info\" icon=\"el-icon-info\" size=\"mini\" @click=\"getSkuInfo(row)\"&gt;&lt;/el-button&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-drawer :visible.sync=\"show\" :show-close=\"false\" size=\"50%\"&gt; &lt;el-row&gt; &lt;el-col :span=\"5\"&gt;名称&lt;/el-col&gt; &lt;el-col :span=\"16\"&gt;{{skuInfo.skuName}}&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=\"5\"&gt;描述&lt;/el-col&gt; &lt;el-col :span=\"16\"&gt;{{skuInfo.skuDesc}}&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=\"5\"&gt;价格&lt;/el-col&gt; &lt;el-col :span=\"16\"&gt;{{skuInfo.price}}元&lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=\"5\"&gt;平台属性&lt;/el-col&gt; &lt;el-col :span=\"16\"&gt; &lt;el-tag type=\"success\" v-for=\"attr in skuInfo.skuAttrValueList\" :key=\"attr.id\" style=\"margin-right:10px;\" size=\"mini\"&gt;{{attr.attrId}}-{{attr.valueId}}&lt;/el-tag&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;el-row&gt; &lt;el-col :span=\"5\"&gt;名称&lt;/el-col&gt; &lt;el-col :span=\"16\"&gt; &lt;el-carousel height=\"950px\"&gt; &lt;el-carousel-item v-for=\"item in skuInfo.skuImageList\" :key=\"item.id\"&gt; &lt;img :src=\"item.imgUrl\"&gt; &lt;/el-carousel-item&gt; &lt;/el-carousel&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/el-drawer&gt; &lt;script&gt; data() { return { skuInfo:{}, //存储sku信息 show:false, //控制抽屉效果的显示与隐藏 } }, // 获取Sku详情的方法 async getSkuInfo(Sku){ // 展示抽屉 this.show = true // 获取sku数据 let result = await this.$API.sku.reqSkuById(Sku.id) if(result.code === 200){ this.skuInfo = result.data } } &lt;/script&gt; &lt;style&gt; .el-carousel__item h3 { color: #475669; font-size: 14px; opacity: 0.75; line-height: 150px; margin: 0; } .el-carousel__item:nth-child(2n) { background-color: #99a9bf; } .el-carousel__item:nth-child(2n+1) { background-color: #d3dce6; } .el-carousel__button{ width: 10px; height: 10px; background: red; border-radius: 50%; } &lt;/style&gt; &lt;style scoped&gt; .el-row .el-col-5{ font-size: 18px; text-align: right; } .el-col{ margin: 10px; } &lt;/style&gt; 深度选择器1. scoped属性的作用：样式只对与当前的组件有用 对于某一个组件，如果style添加上scoped属性，给当前子组件的结构（HTML标签）中都添加上一个data-v-xxx自定义属性， 此时会发现vue是通过属性选择器，给需要添加的元素添加上样式例：h3[data-v-7ba5bd90] 2. 子组件的根标签（拥有父组件当中的自定义属性），如果子组件的根节点和父组件中书写的样式相同，也会添加上相应的样式 注意：如果父组件的样式（scoped）,而且还想影响到子组件的样式？像这种情况我们可以使用深度选择器。 深度选择器：可以实现样式穿透：原生CSS：&gt;&gt;&gt;less：/deep/scss：::v-deep 小案例 例如上一小节（Sku详情查看）中有一个修改el-carousel子组件的小圆点按钮的样式 .el-carousel__button{ width: 10px; height: 10px; background: red; border-radius: 50%; } //如果想让.el-carousel__button这个类放在&lt;style scoped&gt;&lt;/style&gt;中又同时生效的话，需要在类前面加上&gt;&gt;&gt; home首页//安装echarts库 npm install echarts@4.9.0 --save // 这里使用的数据是mock数据 import mockRequest from '@/utils/mockRequest' const state = { list:{} } const actions = { // 发请求获取首页的mock数据 async getData({commit}){ let result = await mockRequest.get('/home/list') if(result.code === 20000){ commit('GETDATA',result.data) } } } const mutations = { GETDATA(state,list){ state.list = list } } const getters = {} export default { state, actions, mutations, getters } &lt;template&gt; &lt;div&gt; &lt;Card&gt;&lt;/Card&gt; &lt;Sale&gt;&lt;/Sale&gt; &lt;Observe&gt;&lt;/Observe&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Card from './Card' import Sale from './Sale' import Observe from './Observe' export default { name: '', components:{Card,Sale,Observe}, mounted() { this.$store.dispatch('getData') }, } &lt;/script&gt; home首页Card模块 模块结构 &lt;template&gt; &lt;div&gt; &lt;el-row :gutter=\"10\"&gt; &lt;el-col :span=\"6\"&gt; &lt;el-card&gt; &lt;Detail title=\"总销售额\" :count=\"`￥ ${cardInfo.salesTotal}`\"&gt; &lt;template slot=\"charts\"&gt; &lt;span&gt;周同比&amp;nbsp;&amp;nbsp;{{cardInfo.salesGrowthLastMonth}}% &lt;svg v-if=\"cardInfo.salesGrowthLastMonth&gt;0\" t=\"1651156891402\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4703\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M851.2 358.4l-316.8-256c-12.8-9.6-28.8-9.6-41.6 0l-320 256c-9.6 9.6-16 22.4-9.6 35.2 6.4 12.8 16 22.4 32 22.4H352v224c0 19.2 12.8 32 32 32h256c19.2 0 32-12.8 32-32v-224h156.8c12.8 0 25.6-9.6 28.8-22.4 6.4-12.8 3.2-25.6-6.4-35.2zM640 864h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32zM640 736h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32z\" p-id=\"4704\" fill=\"#1afa29\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;svg v-else t=\"1651157386106\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"46663\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M842.272 584.032a16 16 0 0 0-10.816-4.192H675.84v-480a32 32 0 0 0-32-32h-256a32 32 0 0 0-32 32v480H200.224a16 16 0 0 0-11.808 26.816l315.616 344.32a16 16 0 0 0 22.624 0.96l0.96-0.96 315.648-344.32a16 16 0 0 0-0.96-22.624z\" p-id=\"46664\" fill=\"#d81e06\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/span&gt;&amp;nbsp;&amp;nbsp; &lt;span&gt;日同比&amp;nbsp;&amp;nbsp;{{cardInfo.salesGrowthLastDay}}% &lt;svg v-if=\"cardInfo.salesGrowthLastDay&gt;0\" t=\"1651156891402\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4703\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M851.2 358.4l-316.8-256c-12.8-9.6-28.8-9.6-41.6 0l-320 256c-9.6 9.6-16 22.4-9.6 35.2 6.4 12.8 16 22.4 32 22.4H352v224c0 19.2 12.8 32 32 32h256c19.2 0 32-12.8 32-32v-224h156.8c12.8 0 25.6-9.6 28.8-22.4 6.4-12.8 3.2-25.6-6.4-35.2zM640 864h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32zM640 736h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32z\" p-id=\"4704\" fill=\"#1afa29\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;svg v-else t=\"1651157386106\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"46663\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M842.272 584.032a16 16 0 0 0-10.816-4.192H675.84v-480a32 32 0 0 0-32-32h-256a32 32 0 0 0-32 32v480H200.224a16 16 0 0 0-11.808 26.816l315.616 344.32a16 16 0 0 0 22.624 0.96l0.96-0.96 315.648-344.32a16 16 0 0 0-0.96-22.624z\" p-id=\"46664\" fill=\"#d81e06\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/span&gt; &lt;/template&gt; &lt;template slot=\"footer\"&gt; &lt;span&gt;日销售额 ￥{{cardInfo.salesToday}}&lt;/span&gt; &lt;/template&gt; &lt;/Detail&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;el-card&gt; &lt;Detail title=\"访问量\" :count=\"cardInfo.visitTotal\"&gt; &lt;template slot=\"charts\"&gt; &lt;lineChart :data=\"cardInfo.visitTrend\"&gt;&lt;/lineChart&gt; &lt;/template&gt; &lt;template slot=\"footer\"&gt; &lt;span&gt;日访问量 {{cardInfo.visitToday}}&lt;/span&gt; &lt;/template&gt; &lt;/Detail&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;el-card&gt; &lt;Detail title=\"支付笔数\" :count=\"cardInfo.payTotal\"&gt; &lt;template slot=\"charts\"&gt; &lt;barChart :data=\"cardInfo.payTrend\"&gt;&lt;/barChart&gt; &lt;/template&gt; &lt;template slot=\"footer\"&gt; &lt;span&gt;转化率 {{cardInfo.payRate}}%&lt;/span&gt; &lt;/template&gt; &lt;/Detail&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;el-col :span=\"6\"&gt; &lt;el-card&gt; &lt;Detail title=\"运营活动效果\" :count=\"`${cardInfo.activityRate}%`\"&gt; &lt;template slot=\"charts\"&gt; &lt;progressChart :data=\"cardInfo.activityRate\"&gt;&lt;/progressChart&gt; &lt;/template&gt; &lt;template slot=\"footer\"&gt; &lt;span&gt;周同比&amp;nbsp;&amp;nbsp;{{cardInfo.activityGrowthLastMonth}}% &lt;svg v-if=\"cardInfo.activityGrowthLastMonth&gt;0\" t=\"1651156891402\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4703\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M851.2 358.4l-316.8-256c-12.8-9.6-28.8-9.6-41.6 0l-320 256c-9.6 9.6-16 22.4-9.6 35.2 6.4 12.8 16 22.4 32 22.4H352v224c0 19.2 12.8 32 32 32h256c19.2 0 32-12.8 32-32v-224h156.8c12.8 0 25.6-9.6 28.8-22.4 6.4-12.8 3.2-25.6-6.4-35.2zM640 864h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32zM640 736h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32z\" p-id=\"4704\" fill=\"#1afa29\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;svg v-else t=\"1651157386106\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"46663\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M842.272 584.032a16 16 0 0 0-10.816-4.192H675.84v-480a32 32 0 0 0-32-32h-256a32 32 0 0 0-32 32v480H200.224a16 16 0 0 0-11.808 26.816l315.616 344.32a16 16 0 0 0 22.624 0.96l0.96-0.96 315.648-344.32a16 16 0 0 0-0.96-22.624z\" p-id=\"46664\" fill=\"#d81e06\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/span&gt;&amp;nbsp;&amp;nbsp; &lt;span&gt;日同比&amp;nbsp;&amp;nbsp;{{cardInfo.activityGrowthLastDay}}% &lt;svg v-if=\"cardInfo.activityGrowthLastDay&gt;0\" t=\"1651156891402\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4703\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M851.2 358.4l-316.8-256c-12.8-9.6-28.8-9.6-41.6 0l-320 256c-9.6 9.6-16 22.4-9.6 35.2 6.4 12.8 16 22.4 32 22.4H352v224c0 19.2 12.8 32 32 32h256c19.2 0 32-12.8 32-32v-224h156.8c12.8 0 25.6-9.6 28.8-22.4 6.4-12.8 3.2-25.6-6.4-35.2zM640 864h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32zM640 736h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32z\" p-id=\"4704\" fill=\"#1afa29\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;svg v-else t=\"1651157386106\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"46663\" width=\"16\" height=\"16\"&gt;&lt;path d=\"M842.272 584.032a16 16 0 0 0-10.816-4.192H675.84v-480a32 32 0 0 0-32-32h-256a32 32 0 0 0-32 32v480H200.224a16 16 0 0 0-11.808 26.816l315.616 344.32a16 16 0 0 0 22.624 0.96l0.96-0.96 315.648-344.32a16 16 0 0 0-0.96-22.624z\" p-id=\"46664\" fill=\"#d81e06\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/span&gt; &lt;/template&gt; &lt;/Detail&gt; &lt;/el-card&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Detail from \"./Detail\"; import lineChart from \"./lineChart\" import barChart from \"./barChart\" import progressChart from \"./progressChart\" import {mapState} from 'vuex' export default { name: \"Card\", components: { Detail , lineChart , barChart , progressChart}, computed:{ ...mapState({ cardInfo:state=&gt;state.home.list }) }, }; &lt;/script&gt; &lt;template&gt; &lt;div&gt; &lt;div class=\"card-header\"&gt; &lt;span&gt;{{title}}&lt;/span&gt; &lt;svg t=\"1651154247089\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2063\" width=\"20\" height=\"20\"&gt;&lt;path d=\"M512 958.016C266.08 958.016 65.984 757.952 65.984 512 65.984 266.08 266.08 65.984 512 65.984c245.952 0 446.016 200.064 446.016 446.016C958.016 757.952 757.952 958.016 512 958.016zM512 129.984C301.344 129.984 129.984 301.344 129.984 512c0 210.624 171.36 382.016 382.016 382.016 210.624 0 382.016-171.36 382.016-382.016C894.016 301.344 722.624 129.984 512 129.984z\" p-id=\"2064\"&gt;&lt;/path&gt;&lt;path d=\"M512 304m-48 0a1.5 1.5 0 1 0 96 0 1.5 1.5 0 1 0-96 0Z\" p-id=\"2065\"&gt;&lt;/path&gt;&lt;path d=\"M512 768c-17.664 0-32-14.304-32-32l0-288c0-17.664 14.336-32 32-32s32 14.336 32 32l0 288C544 753.696 529.664 768 512 768z\" p-id=\"2066\"&gt;&lt;/path&gt;&lt;/svg&gt; &lt;/div&gt; &lt;div class=\"card-content\"&gt;{{count}}&lt;/div&gt; &lt;div class=\"card-charts\"&gt; &lt;slot name=\"charts\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class=\"card-footer\"&gt; &lt;slot name=\"footer\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Detail', props:['title','count'] } &lt;/script&gt; &lt;style scoped&gt; .card-header{ display: flex; justify-content: space-between; color: #797575; } .card-content{ font-size: 30px; padding: 10px 0; } .card-charts{ height: 50px; } .card-footer{ border-top: 1px solid #eee; padding-top: 10px; } &lt;/style&gt; &lt;template&gt; &lt;div class=\"charts\" ref=\"charts\"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as echarts from 'echarts' export default { name:'', props:['data'], data() { return { barCharts:null, //echarts实例 } }, mounted() { // 初始化echarts实例 this.barCharts = echarts.init(this.$refs.charts) // 配置数据 this.barCharts.setOption({ xAxis:{ // 隐藏X轴 show:false, // 类目轴，适用于离散的类目数据，均分 type:'category' }, yAxis:{ // 隐藏Y轴 show:false }, // 系列 series:[ { type:'bar', data:[], color:'#1976d2' } ], // 布局调试 grid:{ left:0, right:0, top:0, bottom:0 }, tooltip:{} }) }, watch:{ data(){ this.barCharts.setOption({ series:{ data:this.data, } }) } } } &lt;/script&gt; &lt;style scoped&gt; .charts { width: 100%; height: 100%; } &lt;/style&gt; &lt;template&gt; &lt;div class=\"charts\" ref=\"charts\"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as echarts from 'echarts' export default { name:'', props:['data'], data() { return { lineCharts:null, //echarts实例 } }, mounted() { // 初始化echarts实例 this.lineCharts = echarts.init(this.$refs.charts) // 配置数据 this.lineCharts.setOption({ xAxis:{ // 隐藏X轴 show:false, // 类目轴，适用于离散的类目数据。 type:'category' }, yAxis:{ // 隐藏Y轴 show:false }, // 系列 series:[ { type:'line', data:[10,7,33,12,48,9,29,10,44], // 平滑曲线显示 smooth:true, // 拐点的样式设置 itemStyle:{ opacity:0 }, // 线条的样式 lineStyle:{ color:'purple' }, // 填充颜色设置 areaStyle:{ // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比，如果 globalCoord 为 `true`，则该四个值是绝对的像素位置 color:{ type: 'linear', x: 0, y: 0, x2: 0, y2: 1, colorStops: [{ offset: 0, color: 'purple' // 0% 处的颜色 }, { offset: 1, color: '#fff' // 100% 处的颜色 }], global: false // 缺省为 false } } } ], // 布局调试 grid:{ left:0, right:0, top:0, bottom:0 } }) }, watch: { data(){ this.lineCharts.setOption({ series:{ data: this.data, }, }) } } } &lt;/script&gt; &lt;style scoped&gt; .charts { width: 100%; height: 100%; } &lt;/style&gt; &lt;template&gt; &lt;div class=\"charts\" ref=\"charts\"&gt;&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import * as echarts from 'echarts' export default { name:'', props:['data'], data() { return { progressCharts: null, //echarts实例 } }, mounted() { // 初始化echarts实例 this.progressCharts = echarts.init(this.$refs.charts) // 配置数据 this.progressCharts.setOption({ xAxis:{ // 隐藏X轴 show:false, // 最小值与最大值的设置 min:0, max:100 }, yAxis:{ // 隐藏Y轴 show:false, // 类目轴，适用于离散的类目数据(均分) type:'category' }, // 系列 series:[ { type:'bar', data:[], // 柱状图的宽度 barWidth:10, color: \"cyan\", // 背景颜色设置 showBackground:true, // 设置背景颜色 backgroundStyle:{ color:'#eee' }, // 文本标签 label:{ show:true, // 改变文本内容 formatter:'|', // 文本标签位置 position:'right' } } ], // 布局调试 grid:{ left:0, right:0, top:0, bottom:0 } }) }, watch:{ data(){ this.progressCharts.setOption({ series:{ data:[this.data], } }) } } } &lt;/script&gt; &lt;style scoped&gt; .charts { width: 100%; height: 100%; } &lt;/style&gt; home首页Sale模块 Day.js中文网 &lt;!-- 安装第三方库 --&gt; npm install --save dayjs &lt;template&gt; &lt;el-card class=\"box-card\" style=\"margin: 10px 0\"&gt; &lt;div slot=\"header\" class=\"clearfix\"&gt; &lt;!-- 头部左侧内容 @tab-click=\"handleClick\" --&gt; &lt;el-tabs class=\"tab\" v-model=\"activeName\"&gt; &lt;el-tab-pane label=\"销售额\" name=\"sale\"&gt;&lt;/el-tab-pane&gt; &lt;el-tab-pane label=\"访问量\" name=\"visited\"&gt;&lt;/el-tab-pane&gt; &lt;/el-tabs&gt; &lt;!-- 头部右侧内容 --&gt; &lt;div class=\"right\"&gt; &lt;span @click=\"setDay\"&gt;今日&lt;/span&gt; &lt;span @click=\"setWeek\"&gt;本周&lt;/span&gt; &lt;span @click=\"setMonth\"&gt;本月&lt;/span&gt; &lt;span @click=\"setYear\"&gt;本年&lt;/span&gt; &lt;el-date-picker v-model=\"date\" class=\"data\" type=\"daterange\" range-separator=\"-\" start-placeholder=\"开始日期\" end-placeholder=\"结束日期\" size=\"mini\" value-format=\"yyyy-MM-dd\" &gt; &lt;/el-date-picker&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 内容区 --&gt; &lt;div&gt; &lt;el-row :gutter=\"10\"&gt; &lt;!-- 内容区左侧 --&gt; &lt;el-col :span=\"18\"&gt; &lt;!-- 容器 --&gt; &lt;div class=\"charts\" ref=\"barCharts\"&gt;&lt;/div&gt; &lt;/el-col&gt; &lt;!-- 内容区右侧 --&gt; &lt;el-col :span=\"6\" class=\"right\"&gt; &lt;h3 style=\"margin: 0\"&gt;门店{{ title }}排名&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(sale,index) in saleList\" :key=\"index\"&gt; &lt;span :class=\"{rindex:sale.no&lt;=3}\"&gt;{{sale.no}}&lt;/span&gt; &lt;span&gt;{{sale.name}}&lt;/span&gt; &lt;span class=\"rvalue\"&gt;{{sale.money}}&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/template&gt; &lt;script&gt; import echarts from \"echarts\"; import dayjs from \"dayjs\"; import { mapState } from \"vuex\"; export default { name: \"\", data() { return { activeName: \"sale\", //标签页当前展示内容 barCharts: null, //echarts实例 date: [], //收集日历数据 }; }, mounted() { //初始化echarts实例 this.barCharts = echarts.init(this.$refs.barCharts); // 配置数据 this.barCharts.setOption({ title: { text: \"销售额趋势\", }, tooltip: { trigger: \"axis\", axisPointer: { type: \"shadow\", }, }, grid: { left: \"3%\", right: \"4%\", bottom: \"3%\", containLabel: true, }, xAxis: [ { type: \"category\", data: [], axisTick: { alignWithLabel: true, }, }, ], yAxis: [ { type: \"value\", }, ], series: [ { name: \"Direct\", type: \"bar\", barWidth: \"60%\", data: [], }, ], }); }, computed: { //计算属性-标题 title() { return this.activeName == \"sale\" ? \"销售额\" : \"访问量\"; }, ...mapState({ listData: (state) =&gt; state.home.list, }), // 销售排行榜数据 saleList(){ return this.activeName == \"sale\" ? this.listData.orderRank : this.listData.userRank; } }, //监听属性 watch: { title() { // 重新修改图标的配置数据 // 图标配置数据可以再次修改，如果有新的数值，新的数值，没有新的数值，还是用以前的 this.barCharts.setOption({ title: { text: this.title, }, xAxis: { data: this.title == \"销售额\" ? this.listData.orderFullYearAxis : this.listData.userFullYearAxis, }, series:{ data: this.title == \"销售额\" ? this.listData.orderFullYear : this.listData.userFullYear, color: this.title == \"销售额\" ? \"\" : \"yellowgreen\", }, }); }, listData() { this.barCharts.setOption({ xAxis:{ data: this.listData.orderFullYearAxis, }, series:{ data: this.listData.orderFullYear, }, }); }, }, methods: { //本天 setDay() { const day = dayjs().format(\"YYYY-MM-DD\"); this.date = [day, day]; }, // 本周 setWeek() { const start = dayjs().day(1).format(\"YYYY-MM-DD\"); const end = dayjs().day(7).format(\"YYYY-MM-DD\"); this.date = [start, end]; }, // 本月 setMonth() { const start = dayjs().startOf(\"month\").format(\"YYYY-MM-DD\"); const end = dayjs().endOf(\"month\").format(\"YYYY-MM-DD\"); this.date = [start, end]; }, // 本年 setYear() { const start = dayjs().startOf(\"year\").format(\"YYYY-MM-DD\"); const end = dayjs().endOf(\"year\").format(\"YYYY-MM-DD\"); this.date = [start, end]; }, }, }; &lt;/script&gt; &lt;style scoped&gt; .clearfix { position: relative; display: flex; justify-content: space-between; } .tab { width: 100%; } .right { position: absolute; right: 0; } .right span { margin: 0 10px; } .data { width: 215px; margin: 0 20px; } .charts { width: 100%; height: 300px; } &gt;&gt;&gt; .el-card__body { padding: 10px 20px 20px; } ul { list-style: none; width: 100%; height: 300px; padding: 0px; } ul li { height: 8%; margin-bottom: 10px; } ul li:nth-child(n + 4) span:nth-child(1) { margin-left: 15px; } .rindex { display: inline-block; width: 20px; height: 20px; border-radius: 50%; background: black; color: white; text-align: center; line-height: 20px; } .rvalue { float: right; } &gt;&gt;&gt; .el-card__header { border: none; } &lt;/style&gt; home首页Observe模块模块结构 &lt;template&gt; &lt;div&gt; &lt;el-row :gutter=\"10\"&gt; &lt;el-col :span=\"12\"&gt; &lt;Search&gt;&lt;/Search&gt; &lt;/el-col&gt; &lt;el-col :span=\"12\"&gt; &lt;Category&gt;&lt;/Category&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import Category from './Category' import Search from './Search' export default { name:'', components:{Category,Search} } &lt;/script&gt; &lt;template&gt; &lt;el-card&gt; &lt;div slot=\"header\"&gt; &lt;div class=\"category-header\"&gt; &lt;span&gt;销售额类别占比&lt;/span&gt; &lt;el-radio-group v-model=\"value\"&gt; &lt;el-radio-button label=\"全部渠道\"&gt;&lt;/el-radio-button&gt; &lt;el-radio-button label=\"线上\"&gt;&lt;/el-radio-button&gt; &lt;el-radio-button label=\"门店\"&gt;&lt;/el-radio-button&gt; &lt;/el-radio-group&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"charts\" ref=\"charts\"&gt;&lt;/div&gt; &lt;/el-card&gt; &lt;/template&gt; &lt;script&gt; import echarts from \"echarts\"; import {mapState} from \"vuex\" export default { name: \"\", data() { return { pieCharts:null, //echarts实例 value: \"全部渠道\", saleOnline:[], //线上数据 saleShop:[], //门店数据 saleAll:[] //全部渠道数据 }; }, mounted() { this.pieCharts = echarts.init(this.$refs.charts); this.pieCharts.setOption({ title:{ text:'', subtext:0, left:'center', top:'center', textStyle: { fontSize: 16 }, }, tooltip: { trigger: \"item\", }, series: [ { name: \"Access From\", type: \"pie\", radius: [\"40%\", \"70%\"], avoidLabelOverlap: false, itemStyle: { borderRadius: 10, borderColor: \"#fff\", borderWidth: 2, }, label: { show: true, position: \"outsize\", }, labelLine: { show: true, }, data: [], }, ], }); // 给echarts实例绑定鼠标事件 this.pieCharts.on('mouseover', params =&gt; { // 获取鼠标移上去的数据 const {name,value} = params // 重新设置标题 this.pieCharts.setOption({ title:{ text:name, subtext:value, }, }) }); }, computed:{ ...mapState({ saleData:state=&gt;state.home.list.saleRank }) }, watch:{ saleData(){ // 处理服务器数据：将两数组合并成数组对象 for(let i = 0; i &lt; this.saleData.online.name.length; i++){ let obj = {} obj.name = this.saleData.online.name[i] obj.value = this.saleData.online.value[i] let obj2 = {} obj2.name = this.saleData.shop.name[i] obj2.value = this.saleData.shop.value[i] this.saleOnline.push(obj) // 线上数据 this.saleShop.push(obj2) // 门店数据 // 全部渠道数据 let objAll = {} objAll.name = this.saleData.online.name[i] objAll.value = this.saleData.online.value[i] + this.saleData.shop.value[i] this.saleAll.push(objAll) } this.pieCharts.setOption({ title:{ text:this.saleAll[0].name, subtext:this.saleAll[0].value, }, series:{ data:this.saleAll } }) }, // 切换按钮，更新饼图数据 value(newValue){ let data = [] if(newValue==\"全部渠道\"){ data = this.saleAll }else if(newValue==\"线上\"){ data = this.saleOnline }else{ data = this.saleShop } this.pieCharts.setOption({ title:{ text:data[0].name, subtext:data[0].value, }, series:{ data } }) } } }; &lt;/script&gt; &lt;style scoped&gt; .category-header { display: flex; justify-content: space-between; align-items: center; } .charts { width: 100%; height: 315px; } &lt;/style&gt; &lt;template&gt; &lt;el-card&gt; &lt;div slot=\"header\" class=\"clearfix\"&gt; &lt;div class=\"search-header\"&gt; &lt;span&gt;线上热门搜索&lt;/span&gt; &lt;el-dropdown&gt; &lt;span&gt; &lt;i class=\"el-icon-more\" style=\"cursor: pointer\"&gt;&lt;/i&gt; &lt;/span&gt; &lt;el-dropdown-menu slot=\"dropdown\"&gt; &lt;el-dropdown-item&gt;黄金糕&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;狮子头&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;螺蛳粉&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;双皮奶&lt;/el-dropdown-item&gt; &lt;el-dropdown-item&gt;蚵仔煎&lt;/el-dropdown-item&gt; &lt;/el-dropdown-menu&gt; &lt;/el-dropdown&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;el-row :gutter=\"10\"&gt; &lt;el-col :span=\"12\"&gt; &lt;lineCharts header=\"搜索用户数\" title=\"12321\" content=\"17.1\"&gt;&lt;/lineCharts&gt; &lt;/el-col&gt; &lt;el-col :span=\"12\"&gt; &lt;lineCharts header=\"人均搜索数\" title=\"2.7\" content=\"26.2\"&gt;&lt;/lineCharts&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;!-- table --&gt; &lt;el-table :data=\"records\" style=\"width: 100%;margin-top:20px;\" border &gt; &lt;el-table-column type=\"index\" label=\"排名\" width=\"80\" align=\"center\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"word\" label=\"搜索关键字\" width=\"180\"&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"user\" label=\"用户数\" sortable&gt; &lt;/el-table-column&gt; &lt;el-table-column prop=\"count\" label=\"周涨幅\" sortable&gt; &lt;/el-table-column&gt; &lt;/el-table&gt; &lt;!-- 分页器 --&gt; &lt;el-pagination :page-size=\"limit\" :current-page=\"page\" :total=\"total\" layout=\"prev, pager, next\" style=\"text-align:center;margin-top:20px;\" @current-change=\"handleCurrentChange\" &gt; &lt;/el-pagination&gt; &lt;/div&gt; &lt;/el-card&gt; &lt;/template&gt; &lt;script&gt; import lineCharts from \"./lineCharts\"; import {mapState} from 'vuex' export default { name: \"\", data() { return { records:[], //存储表格当前页数据 total:0, //表格数据总条数 page:1, //当前页 limit:2, //每页展示数据条数 }; }, components: { lineCharts }, computed:{ ...mapState({ tableData:state=&gt; state.home.list }) }, watch:{ tableData(){ this.total = this.tableData.searchWord.length-1 this.records = this.tableData.searchWord.slice(0,2) } }, methods: { // 切换当前页展示相应数据 handleCurrentChange(page){ this.page = page this.records = this.tableData.searchWord.slice((page-1)*2,(page-1)*2+2) //1 0,2 2,3 4,4 6 } }, }; &lt;/script&gt; &lt;style&gt; .search-header { display: flex; justify-content: space-between; } &lt;/style&gt; &lt;template&gt; &lt;div&gt; &lt;div class=\"header\"&gt; &lt;span class=\"search-header\"&gt;{{ header }}&lt;/span&gt; &lt;svg t=\"1651154247089\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"2063\" width=\"20\" height=\"20\"&gt; &lt;path d=\"M512 958.016C266.08 958.016 65.984 757.952 65.984 512 65.984 266.08 266.08 65.984 512 65.984c245.952 0 446.016 200.064 446.016 446.016C958.016 757.952 757.952 958.016 512 958.016zM512 129.984C301.344 129.984 129.984 301.344 129.984 512c0 210.624 171.36 382.016 382.016 382.016 210.624 0 382.016-171.36 382.016-382.016C894.016 301.344 722.624 129.984 512 129.984z\" p-id=\"2064\" &gt;&lt;/path&gt; &lt;path d=\"M512 304m-48 0a1.5 1.5 0 1 0 96 0 1.5 1.5 0 1 0-96 0Z\" p-id=\"2065\"&gt;&lt;/path&gt; &lt;path d=\"M512 768c-17.664 0-32-14.304-32-32l0-288c0-17.664 14.336-32 32-32s32 14.336 32 32l0 288C544 753.696 529.664 768 512 768z\" p-id=\"2066\"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/div&gt; &lt;div class=\"main\"&gt; &lt;span class=\"main-title\"&gt;{{ title }}&lt;/span&gt; &lt;span class=\"main-content\"&gt;{{ content }}&lt;/span&gt; &lt;svg v-if=\"header == '搜索用户数'\" t=\"1651156891402\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"4703\" width=\"16\" height=\"16\"&gt; &lt;path d=\"M851.2 358.4l-316.8-256c-12.8-9.6-28.8-9.6-41.6 0l-320 256c-9.6 9.6-16 22.4-9.6 35.2 6.4 12.8 16 22.4 32 22.4H352v224c0 19.2 12.8 32 32 32h256c19.2 0 32-12.8 32-32v-224h156.8c12.8 0 25.6-9.6 28.8-22.4 6.4-12.8 3.2-25.6-6.4-35.2zM640 864h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32zM640 736h-256c-19.2 0-32 12.8-32 32s12.8 32 32 32h256c19.2 0 32-12.8 32-32s-12.8-32-32-32z\" p-id=\"4704\" fill=\"#1afa29\"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;svg v-else t=\"1651157386106\" class=\"icon\" viewBox=\"0 0 1024 1024\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" p-id=\"46663\" width=\"16\" height=\"16\"&gt; &lt;path d=\"M842.272 584.032a16 16 0 0 0-10.816-4.192H675.84v-480a32 32 0 0 0-32-32h-256a32 32 0 0 0-32 32v480H200.224a16 16 0 0 0-11.808 26.816l315.616 344.32a16 16 0 0 0 22.624 0.96l0.96-0.96 315.648-344.32a16 16 0 0 0-0.96-22.624z\" p-id=\"46664\" fill=\"#d81e06\"&gt;&lt;/path&gt; &lt;/svg&gt; &lt;/div&gt; &lt;div class=\"footer\"&gt; &lt;div ref=\"charts\" class=\"charts\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import echarts from \"echarts\"; export default { name: \"\", props: [\"header\", \"title\", \"content\"], mounted() { // 初始化echarts实例 const lineCharts = echarts.init(this.$refs.charts); // 配置数据 lineCharts.setOption({ xAxis: { // 隐藏X轴 show: false, // 类目轴，适用于离散的类目数据。 type: \"category\", }, yAxis: { // 隐藏Y轴 show: false, }, // 系列 series: [ { type: \"line\", data: [10, 7, 33, 12, 48, 9, 29, 10, 44], // 平滑曲线显示 smooth: true, // 拐点的样式设置 itemStyle: { opacity: 0, }, // 线条的样式 lineStyle: { color: \"blue\", }, // 填充颜色设置 areaStyle: { // 线性渐变，前四个参数分别是 x0, y0, x2, y2, 范围从 0 - 1，相当于在图形包围盒中的百分比，如果 globalCoord 为 `true`，则该四个值是绝对的像素位置 color: { type: \"linear\", x: 0, y: 0, x2: 0, y2: 1, colorStops: [ { offset: 0, color: \"skyblue\", // 0% 处的颜色 }, { offset: 1, color: \"#fff\", // 100% 处的颜色 }, ], global: false, // 缺省为 false }, }, }, ], // 布局调试 grid: { left: 0, right: 0, top: 0, bottom: 0, }, }); }, }; &lt;/script&gt; &lt;style scoped&gt; .header { display: flex; align-items: center; } .search-header { margin-right: 20px; } .main { margin: 10px 0px; } .main-title { margin-right: 30px; } .main-content { margin-right: 10px; } .charts { width: 100%; height: 50px; } &lt;/style&gt; 权限管理模块的菜单权限菜单权限：不同的用户（角色），能操作、能观看的菜单是不同的。 如何实现菜单的权限？不同的用户所能操作|查看菜单不一样的？起始不同的用户（角色），登录的时候会向服务器发请求，服务器会把用户相应的菜单的权限的信息，返回给我们我们可以根据服务器返回的数据（信息），可以动态的设置路由，可以根据不同的用户展示不同的菜单。 路由相关代码 //引入Vue|Vue-router import Vue from 'vue' import Router from 'vue-router' //使用路由插件 Vue.use(Router) /* 引入最外层骨架的一级路由组件*/ import Layout from '@/layout' //路由的配置：为什么不同用户登录我们的项目，菜单（路由）都是一样的？ //因为咱们的路由‘死的’，不管你是谁，你能看见的，操作的菜单都是一样的 //需要把项目中的路由进行拆分 //常量路由:就是不关用户是什么角色，都可以看见的路由 //什么角色（超级管理员，普通员工）：登录、404、首页 export const constantRoutes = [ { path: '/login', component: () =&gt; import('@/views/login/index'), hidden: true }, { path: '/404', component: () =&gt; import('@/views/404'), hidden: true }, { path: '/', component: Layout, redirect: '/dashboard', children: [{ path: 'dashboard', name: 'Dashboard', component: () =&gt; import('@/views/dashboard/index'), meta: { title: '首页', icon: 'dashboard' } }] }, ] //异步理由:不同的用户（角色），需要过滤筛选出的路由，称之为异步路由 //有的用户可以看见测试管理、有的看不见 export const asyncRoutes = [ { name: 'Acl', path: '/acl', component: Layout, redirect: '/acl/user/list', meta: { title: '权限管理', icon: 'el-icon-lock' }, children: [ { name: 'User', path: 'user/list', component: () =&gt; import('@/views/acl/user/list'), meta: { title: '用户管理', }, }, { name: 'Role', path: 'role/list', component: () =&gt; import('@/views/acl/role/list'), meta: { title: '角色管理', }, }, { name: 'RoleAuth', path: 'role/auth/:id', component: () =&gt; import('@/views/acl/role/roleAuth'), meta: { activeMenu: '/acl/role/list', title: '角色授权', }, hidden: true, }, { name: 'Permission', path: 'permission/list', component: () =&gt; import('@/views/acl/permission/list'), meta: { title: '菜单管理', }, }, ] }, { path: '/product', component: Layout, name: 'Product', meta: { title: '商品管理', icon: 'el-icon-goods' }, children: [ { path: 'trademark', name: 'TradeMark', component: () =&gt; import('@/views/product/tradeMark'), meta: { title: '品牌管理' } }, { path: 'attr', name: 'Attr', component: () =&gt; import('@/views/product/Attr'), meta: { title: '平台属性管理' } }, { path: 'spu', name: 'Spu', component: () =&gt; import('@/views/product/Spu'), meta: { title: 'Spu管理' } }, { path: 'sku', name: 'Sku', component: () =&gt; import('@/views/product/Sku'), meta: { title: 'Sku管理' } }, ] }, { path: '/test', component: Layout, name: 'Test', meta: { title: '测试管理', icon: 'el-icon-goods' }, children: [ { path: 'test1', name: 'Test1', component: () =&gt; import('@/views/Test/Test1'), meta: { title: '测试管理1' } }, { path: 'test2', name: 'Test2', component: () =&gt; import('@/views/Test/Test2'), meta: { title: '测试管理2' } }, ] }, ]; //任意路由：当路径出现错误的时候重定向404 export const anyRoutes ={ path: '*', redirect: '/404', hidden: true }; const createRouter = () =&gt; new Router({ // mode: 'history', // require service support scrollBehavior: () =&gt; ({ y: 0 }), //因为注册的路由是‘死的’，‘活的’路由如果根据不同用户（角色）可以展示不同菜单 routes: constantRoutes }) const router = createRouter() export function resetRouter() { const newRouter = createRouter() router.matcher = newRouter.matcher // reset router } export default router Vuex相关代码 // 引入登录|退出登录|获取用户信息的接口函数 import { login, logout, getInfo } from '@/api/user' // 获取token|设置token|删除token的函数 import { getToken, setToken, removeToken } from '@/utils/auth' // 路由模块当中重置路由的方法 import { asyncRoutes, resetRouter, anyRoutes, constantRoutes } from '@/router' import router from '@/router' import cloneDeep from 'lodash/cloneDeep' const getDefaultState = () =&gt; { return { // 获取token token: getToken(), // 存储用户名 name: '', // 存储用户头像 avatar: '', // 菜单权限信息【根据不同的角色，返回的标记信息，数组里面的元素是字符串】 routes:[], // 按钮权限信息 buttons:[], // 角色信息 roles:[], // 项目中已有的异步路由，与服务器返回的标记信息进行对比最终需要展示的路由 resultAsyncRoutes:[], // 用户最终需要展示的全部路由 resultAllRoutes:[] } } const state = getDefaultState() // 唯一修改state的地方 const mutations = { // 重置state RESET_STATE: (state) =&gt; { Object.assign(state, getDefaultState()) }, // 存储token SET_TOKEN: (state, token) =&gt; { state.token = token }, // 存储用户信息 SET_USERINFO: (state,userInfo)=&gt;{ // 用户名 state.name = userInfo.name // 用户头像 state.avatar = userInfo.avatar // 菜单权限标记 state.routes = userInfo.routes // 按钮权限标记 state.buttons = userInfo.buttons // 角色 state.roles = userInfo.roles }, // 最终计算出的异步路由 SET_RESULTASYNCROUTES:(state,asyncRoutes)=&gt;{ // vuex保存当前用户的异步路由，注意，一个用户需要展示完成路由：常量、异步、任意路由 state.resultAsyncRoutes = asyncRoutes // 计算出当前用户需要展示所有路由 state.resultAllRoutes = constantRoutes.concat(state.resultAsyncRoutes,anyRoutes) // 给路由器添加新的路由 router.addRoutes(state.resultAllRoutes) } } const actions = { // 这里在处理登录业务 async login({ commit }, userInfo) { const { username, password } = userInfo let result = await login({username:username.trim(),password:password}) // 注意：当前登录请求现在使用mock数据 if(result.code===20000){ commit('SET_TOKEN', result.data.token) setToken(result.data.token) return 'ok' }else{ return Promise.reject(new Error('failed')) } }, // 获取用户信息 async getInfo({ commit, state }) { // 获取用户信息：返回数据包含用户名name、用户头像avatar、 // routes[返回的标志：不同的用户应该展示哪些菜单的标记]、roles（用户角色信息）、button【按钮的信息，按钮权限用的标记】 let result = await getInfo(state.token) if(result.code == 20000){ // 存储用户全部信息 commit('SET_USERINFO',result.data) commit('SET_RESULTASYNCROUTES',computedAsyncRoutes(cloneDeep(asyncRoutes),result.data.routes)) return 'ok' }else{ return Promise.reject(new Error('failed')) } }, } // 定义一个函数：两个数组进行对比，对比出当前用户到底显示哪些路由 const computedAsyncRoutes = (asyncRoutes,routes) =&gt; { // 过滤出当前用户【超级管理|普通员工】需要展示的异步路由 return asyncRoutes.filter(item =&gt; { if(routes.indexOf(item.name)!=-1){ // 递归：asyncRoutes是多级路由 if(item.children &amp;&amp; item.children.length){ // 给当前过滤出的路由添加过滤出的子路由，children字段为数组，用于存放过滤出的子路由 item.children = computedAsyncRoutes(item.children,routes) } return true } }) } export default { namespaced: true, state, mutations, actions } 权限管理模块的按钮权限不同的用户（角色），有的用户的是可见按钮、当然有的用户不可见。 &lt;template&gt; &lt;div&gt; &lt;el-button type=\"primary\" v-show=\"$store.state.user.buttons.indexOf('btn.Add1')!=-1\"&gt;添加按钮1&lt;/el-button&gt; &lt;el-button type=\"primary\" v-show=\"$store.state.user.buttons.indexOf('btn.Add2')!=-1\"&gt;添加按钮2&lt;/el-button&gt; &lt;/div&gt; &lt;/template&gt;","categories":[{"name":"项目实战","slug":"项目实战","permalink":"https://serein.icu/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"}]},{"title":"Promise学习笔记","slug":"Promise系统学习笔记","date":"2022-03-28T09:30:00.000Z","updated":"2022-03-29T01:03:41.779Z","comments":true,"path":"posts/6.html","link":"","permalink":"https://serein.icu/posts/6.html","excerpt":"","text":"Promise的理解与使用 概念: ​ Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。 通俗讲，Promise是一个许诺、承诺,是对未来事情的承诺，承诺不一定能完成，但是无论是否能完成都会有一个结果。 Pending 正在做。。。 Resolved 完成这个承诺 Rejected 这个承诺没有完成，失败了 ​ Promise 用来预定一个不一定能完成的任务，要么成功，要么失败 ​ 在具体的程序中具体的体现，通常用来封装一个异步任务，提供承诺结果 Promise 是异步编程的一种解决方案，主要用来解决回调地狱的问题，可以有效的减少回调嵌套。真正解决需要配合async/await 特点: 对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。 缺点: 无法取消Promise，一旦新建它就会立即执行，无法中途取消。和一般的对象不一样，无需调用。 如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。 当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成） Promise是什么?理解 抽象表达: Promise 是一门新的技术(ES6 规范) Promise 是 JS 中进行异步编程的新解决方案 备注：旧方案是单纯使用回调函数 具体表达: 从语法上来说: Promise 是一个构造函数 从功能上来说: promise 对象用来封装一个异步操作并可以获取其成功/ 失败的结果值 promise 的状态promise 的状态 实例对象中的一个属性 『PromiseState』 pending 未决定的 resolved / fullfilled 成功 rejected 失败 promise 的状态改变 pending 变为 resolved pending 变为 rejected 说明: 只有这 2 种, 且一个 promise 对象只能改变一次 无论变为成功还是失败, 都会有一个结果数据 成功的结果数据一般称为 value, 失败的结果数据一般称为 reason promise的基本流程 promise的基本使用使用 promise 封装基于定时器的异步&lt;script&gt; function doDelay(time) { // 1. 创建 promise 对象(pending 状态), 指定执行器函数 return new Promise((resolve, reject) =&gt; { // 2. 在执行器函数中启动异步任务 console.log('启动异步任务') setTimeout(() =&gt; { console.log('延迟任务开始执行...') const time = Date.now() // 假设: 时间为奇数代表成功, 为偶数代表失败 if (time % 2 === 1) { // 成功了 // 3. 1. 如果成功了, 调用 resolve()并传入成功的 value resolve('成功的数据 ' + time) } else { // 失败了 // 3.2. 如果失败了, 调用 reject()并传入失败的 reason reject('失败的数据 ' + time) } }, time) }) } const promise = doDelay(2000) promise.then(// promise 指定成功或失败的回调函数来获取成功的 vlaue 或失败的 reason value =&gt; {// 成功的回调函数 onResolved, 得到成功的 vlaue console.log('成功的 value: ', value) }, reason =&gt; { // 失败的回调函数 onRejected, 得到失败的 reason console.log('失败的 reason: ', reason) }, ) &lt;/script&gt; 使用 promise 封装 ajax 异步请求&lt;script&gt; /*可复用的发 ajax 请求的函数: xhr + promise */ function promiseAjax(url) { return new Promise((resolve, reject) =&gt; { const xhr = new XMLHttpRequest() xhr.onreadystatechange = () =&gt; { if (xhr.readyState !== 4) return const {status, response} = xhr // 请求成功, 调用 resolve(value) if (status &gt;= 200 &amp;&amp; status &lt; 300) { resolve(JSON.parse(response)) } else { // 请求失败, 调用 reject(reason) reject(new Error('请求失败: status: ' + status)) } } xhr.open(\"GET\", url) xhr.send() }) } promiseAjax('https://api.apiopen.top2/getJoke?page=1&amp;count=2&amp;type=video').then( data =&gt; { console.log('显示成功数据', data) }, error =&gt; { alert(error.message) }) &lt;/script&gt; fs模块使用Promiseconst fs = require('fs'); //回调函数 形式---------------------------------------------------- fs.readFile('./resource/content.txt', (err, data) =&gt; { // 如果出错 则抛出错误 if(err) throw err; //输出文件内容 console.log(data.toString()); }); //Promise 形式----------------------------------------------------------- /** * 封装一个函数 mineReadFile 读取文件内容 * 参数: path 文件路径 * 返回: promise 对象 */ function mineReadFile(path){ return new Promise((resolve, reject) =&gt; { //读取文件 require('fs').readFile(path, (err, data) =&gt;{ //判断 if(err) reject(err); //成功 resolve(data); }); }); } mineReadFile('./resource/content.txt').then( value=&gt;{ //输出文件内容 console.log(value.toString()); }, reason=&gt;{ console.log(reason); }); 异常穿透 可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch 在每个.then()中我可以将数据再次传出给下一个then() mineReadFile('./11.txt').then(result=&gt;{ console.log(result.toString()) return result },err=&gt;console.log(err)) .then(data=&gt;console.log(data,\"2222222\")) .catch(err=&gt;console.log(\"这是catch的\")) util.promisify方法 可以将函数直接变成promise的封装方式,不用再去手动封装 //引入 util 模块 const util = require('util'); //引入 fs 模块 const fs = require('fs'); //返回一个新的函数 let mineReadFile = util.promisify(fs.readFile); mineReadFile('./resource/content.txt').then(value =&gt; { console.log(value.toString()); }); 为什么要用Promise?指定回调函数的方式更加灵活 旧的: 必须在启动异步任务前指定 promise: 启动异步任务 =&gt; 返回promie对象 =&gt; 给promise对象绑定回调函 数(甚至可以在异步任务结束后指定/多个) 支持链式调用, 可以解决回调地狱问题什么是回调地狱 回调函数嵌套调用, 外部回调函数异步执行的结果是嵌套的回调执行的条件 回调地狱的缺点? 不便于阅读 不便于异常处理 解决方案? promise 链式调用, 用来解决回调地狱问题，但是只是简单的改变格式，并没有彻底解决上面的问题真正要解决上述问题，一定要利用promise再加上await和async关键字实现异步传同步 4、终极解决方案? promise +async/await 3、Promise中的常用 API 概述 此处列举几个最常用的API的概述,如果想看详细描述的可以继续往下看下方的 Promise方法的具体使用 描述 Ⅰ- Promise 构造函数: Promise (excutor) {} (1) executor 函数: 执行器 (resolve, reject) =&gt; {} (2) resolve 函数: 内部定义成功时我们调用的函数 value =&gt; {} (3) reject 函数: 内部定义失败时我们调用的函数 reason =&gt; {} 说明: executor 会在 Promise 内部立即同步调用,异步操作在执行器中执行,换话说Promise支持同步也支持异步操作 Ⅱ-Promise.prototype.then 方法: (onResolved, onRejected) =&gt; {} (1) onResolved 函数: 成功的回调函数 (value) =&gt; {} (2) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: 指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调 返回一个新的 promise 对象 Ⅲ-Promise.prototype.catch 方法: (onRejected) =&gt; {} (1) onRejected 函数: 失败的回调函数 (reason) =&gt; {} 说明: then()的语法糖, 相当于: then(undefined, onRejected) (2) 异常穿透使用:当运行到最后,没被处理的所有异常错误都会进入这个方法的回调函数中 Ⅳ-Promise.resolve 方法: (value) =&gt; {} (1) value: 成功的数据或 promise 对象 说明: 返回一个成功/失败的 promise 对象,直接改变promise状态 let p3 = Promise.reject(new Promise((resolve, reject) =&gt; { resolve('OK'); })); console.log(p3); Ⅴ-Promise.reject 方法: (reason) =&gt; {} (1) reason: 失败的原因 说明: 返回一个失败的 promise 对象,直接改变promise状态,代码示例同上 Ⅵ-Promise.all 方法: (promises) =&gt; {} promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 只有所有的 promise 都成功才成功, 只要有一 个失败了就直接失败 let p1 = new Promise((resolve, reject) =&gt; { resolve('成功'); }) let p2 = Promise.reject('错误错误错误'); let p3 = Promise.resolve('也是成功') const result = Promise.all([p1, p2, p3]); console.log(result); Ⅶ-Promise.race 方法: (promises) =&gt; {} (1) promises: 包含 n 个 promise 的数组 说明: 返回一个新的 promise, 第一个完成的 promise 的结果状态就是最终的结果状态, 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve('OK'); }, 1000); }) let p2 = Promise.resolve('Success'); let p3 = Promise.resolve('Oh Yeah'); //调用 const result = Promise.race([p1, p2, p3]); console.log(result); 4、Promise的几个关键问题Ⅰ-如何改变 promise 的状态? (1) resolve(value): 如果当前是 pending 就会变为 resolved (2) reject(reason): 如果当前是 pending 就会变为 rejected (3) 抛出异常: 如果当前是 pending 就会变为 rejected Ⅱ-一个 promise 指定多个成功/失败回调函数, 都会调用吗? 当 promise 改变为对应状态时都会调用,改变状态后,多个回调函数都会调用,并不会自动停止 &gt;let p = new Promise((resolve, reject) =&gt; { resolve('OK');}); ///指定回调 - 1 p.then(value =&gt; { console.log(value); }); //指定回调 - 2 p.then(value =&gt; { alert(value);}); Ⅲ- 改变 promise 状态和指定回调函数谁先谁后? (1) 都有可能, 正常情况下是先指定回调再改变状态, 但也可以先改状态再指定回调 ​ 先指定回调再改变状态(异步):先指定回调–&gt; 再改变状态 –&gt;改变状态后才进入异步队列执行回调函数 ​ 先改状态再指定回调(同步):改变状态 –&gt;指定回调 并马上执行回调 (2) 如何先改状态再指定回调? –&gt;注意:指定并不是执行 ​ ① 在执行器中直接调用 resolve()/reject() –&gt;即,不使用定时器等方法,执行器内直接同步操作 ​ ② 延迟更长时间才调用 then() –&gt;即,在.then()这个方法外再包一层例如延时器这种方法 (3) 什么时候才能得到数据? ​ ① 如果先指定的回调, 那当状态发生改变时, 回调函数就会调用, 得到数据 ​ ② 如果先改变的状态, 那当指定回调时, 回调函数就会调用, 得到数据 &gt;let p = new Promise((resolve, reject) =&gt; { //异步写法,这样写会先指定回调,再改变状态 setTimeout(() =&gt; {resolve('OK'); }, 1000); //这是同步写法,这样写会先改变状态,再指定回调 resolve('OK'); &gt;}); &gt;p.then(value =&gt; {console.log(value);}, reason =&gt; {}) (4) 个人理解–结合源码 ​ 源码中,promise的状态是通过一个默认为padding的变量进行判断,所以当你resolve/reject延时(异步导致当then加载时,状态还未修改)后,这时直接进行p.then()会发现,目前状态还是进行中,所以只是这样导致只有同步操作才能成功. ​ 所以promise将传入的回调函数拷贝到promise对象实例上,然后在resolve/reject的执行过程中再进行调用,达到异步的目的 ​ 具体代码实现看下方自定义promise Ⅳ-promise.then()返回的新 promise 的结果状态由什么决定? (1) 简单表达: 由 then()指定的回调函数执行的结果决定 (2) 详细表达: ​ ① 如果抛出异常, 新 promise 变为 rejected, reason 为抛出的异常 ​ ② 如果返回的是非 promise 的任意值, 新 promise 变为 resolved, value 为返回的值 ​ ③ 如果返回的是另一个新 promise, 此 promise 的结果就会成为新 promise 的结果 &gt;let p = new Promise((resolve, reject) =&gt; { resolve('ok'); &gt;}); &gt;//执行 then 方法 &gt;let result = p.then(value =&gt; { console.log(value); // 1. 抛出错误 ,变为 rejected throw '出了问题'; // 2. 返回结果是非 Promise 类型的对象,新 promise 变为 resolved return 521; // 3. 返回结果是 Promise 对象,此 promise 的结果就会成为新 promise 的结果 return new Promise((resolve, reject) =&gt; { // resolve('success'); reject('error'); }); &gt;}, reason =&gt; { console.warn(reason); &gt;}); Ⅴ- promise 如何串连多个操作任务? (1) promise 的 then()返回一个新的 promise, 可以开成 then()的链式调用 (2) 通过 then 的链式调用串连多个同步/异步任务,这样就能用then()将多个同步或异步操作串联成一个同步队列 &gt;&lt;script&gt; &gt;let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {resolve('OK'); }, 1000); }); &gt;p.then(value =&gt; {return new Promise((resolve, reject) =&gt; { resolve(\"success\"); });}) &gt;.then(value =&gt; {console.log(value);}) &gt;.then(value =&gt; { console.log(value);}) &gt;&lt;/script&gt; Ⅵ-promise 异常传透? 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 &gt;getJSON('./hong.json') .then(function(posts) { throw new Error('抛出异常') }) .then(res=&gt;console.log(res),e=&gt;console.log('被then的错误回调捕获',e) ) .catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('错误捕获: ', error); }); &gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常 &gt;/******************** 利用异常穿透 ****************************************/ &gt;getJSON('./hong.json') .then(function(posts) { throw new Error('抛出异常') }) .then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后 .catch(function(error) { console.log('错误捕获: ', error); }); &gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch Ⅶ- 中断 promise 链? 在关键问题2中,可以得知,当promise状态改变时,他的链式调用都会生效,那如果我们有这个一个实际需求:我们有5个then(),但其中有条件判断,如当我符合或者不符合第三个then条件时,要直接中断链式调用,不再走下面的then,该如何? (1) 当使用 promise 的 then 链式调用时, 在中间中断, 不再调用后面的回调函数 (2) 办法: 在回调函数中返回一个 pendding 状态的promise 对象 &gt;&lt;script&gt; &gt;let p = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; { resolve('OK');}, 1000);}); &gt;p.then(value =&gt; {return new Promise(() =&gt; {});})//有且只有这一个方式 &gt;.then(value =&gt; { console.log(222);}) &gt;.then(value =&gt; { console.log(333);}) &gt;.catch(reason =&gt; {console.warn(reason);}); &gt;&lt;/script&gt; 5、 Promise的实际应用 举两个栗子 Ⅰ - 加载图片 我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 &gt;const preloadImage = function (path) { return new Promise(function (resolve, reject) { const image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); &gt;}; Ⅱ - Generator 函数与 Promise 的结合 使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 &gt;function getFoo () { return new Promise(function (resolve, reject){ resolve('foo'); }); &gt;} &gt;const g = function* () { try { const foo = yield getFoo(); console.log(foo); } catch (e) { console.log(e); } &gt;}; &gt;function run (generator) { const it = generator(); function go(result) { if (result.done) return result.value; return result.value.then(function (value) { return go(it.next(value)); }, function (error) { return go(it.throw(error)); }); } go(it.next()); &gt;} &gt;run(g); 上面代码的 Generator 函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 二、Promise API 用法详解 ES6 规定，Promise对象是一个构造函数，用来生成Promise实例。 此部分是对于 Promise API 用法的详解 ,尽量详细地列举其常见用法,所以篇幅较长 Ⅰ - 基本用法① 举个创造 Promise 实例的栗子 下面代码创造了一个Promise实例。 const promise = new Promise(function(resolve, reject) { if (/* 异步操作成功 */) resolve(value); //将该 Promise 修改为成功且返回 else reject(error); //将该 Promise 修改为失败且返回 }); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 ② 使用 [ then ] 方法分别指定 成功/失败 的回调 Promise实例生成以后，可以用 [ then() ] 方法分别指定resolved状态和rejected状态的回调函数。 &gt;promise.then(function(value) { &gt;// 当promise状态返回为resolve 时会执行的回调函数 &gt;}, function(error) { &gt;// 当promise状态返回为rejected 时会执行的回调函数 &gt;}); [ then ] 方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 ③ 举个 Promise 对象的简单栗子 下面是一个Promise对象的简单例子。 setTimeout的第三个参数是给第一个函数的参数，而且是先于第一个参数(即回调函数)执行的 &gt;function timeout(ms) { //声明一个方法, 传入的 参数ms 为延时器时间 return new Promise((resolve, reject) =&gt; { //这行代码实际效果: 当 [ms] 毫秒后 执行 resolve('努力学习的汪') setTimeout(resolve, ms, '努力学习的汪'); }); &gt;} &gt;timeout(1000).then((value) =&gt; { console.log(value) }); &gt;//打印结果 : 努力学习的汪 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为resolved，就会触发then方法绑定的回调函数。 ④ Promise 新建后就会立即执行 &gt;let promise = new Promise(function(resolve, reject) { &gt;console.log('Promise'); &gt;resolve(); &gt;}); &gt;promise.then(function() { &gt;console.log('resolved.'); &gt;}); &gt;console.log('Hi!'); &gt;// Promise &gt;// Hi! &gt;// resolved //可以发现,明明then是在 Hi 前面,却最后打印 上面代码中，Promise 新建后立即执行，所以首先输出的是Promise。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以resolved最后输出。 实际上,这个运行结果相关知识点是 [ 宏任务与微任务 ] ,单独梳理在下方.这里可以先初步理解为: JS是单线程的,至上往下运行,在声明 Promise 时实际上已经执行到了内部方法 为何 resolve() 运行后没有立即打印? JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 ⑤ 举个异步加载图片的栗子 &gt;function loadImageAsync(url) { &gt;return new Promise(function(resolve, reject) { &gt;const image = new Image(); &gt;image.onload = function() { console.log('图片加载成功') resolve(image); &gt;}; &gt;image.onerror = function() { reject(new Error(`无法从 ${url} 中加载图片` )); &gt;}; &gt;image.src = url; &gt;}); &gt;} &gt;loadImageAsync('正确的url') //打印图片加载成功 &gt;loadImageAsync('错误的url') //抛出异常 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 ⑥ 举个用Promise对象实现的 Ajax 操作的栗子 Ajax知识点不懂的同学要去补一下: 这里可以看本人梳理的ajax笔记 –&gt; 点我跳转 &gt;const getJSON = function(url) { &gt;const promise = new Promise(function(resolve, reject){ &gt;const handler = function() { if (this.readyState !== 4) return; //当readyState 为4 时直接返回,不修改 promise 状态 if (this.status === 200) resolve(this.response); //返回状态为 200 时将状态修改为成功,且将响应内容返回 else reject(new Error(this.statusText)); //失败时抛出异常 &gt;}; &gt;const client = new XMLHttpRequest(); //实例化xml实例 &gt;client.open(\"GET\", url); //下面这几行都是对xml实例进行配置,不懂的同学要去补一下ajax知识点 &gt;client.onreadystatechange = handler; &gt;client.responseType = \"json\"; &gt;client.setRequestHeader(\"Accept\", \"application/json\"); &gt;client.send(); &gt;}); &gt;return promise; &gt;}; &gt;getJSON(\"./hong.json\").then(function(json) { &gt;console.log('Contents: ' , json); &gt;}, function(error) { &gt;console.error('出错了', error); &gt;}); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 小贴士:此处可能有同学想尝试却发现读取本地文件会有跨域问题,这边教一下你们 ⑦ resolve() 的参数可以是另一个 Promise 实例 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个 Promise 实例，比如像下面这样。 &gt;const p1 = new Promise(function (resolve, reject) {}); &gt;const p2 = new Promise(function (resolve, reject) { resolve(p1) }) 上面代码中，p1和p2都是 Promise 的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是resolved或者rejected，那么p2的回调函数将会立刻执行。 &gt;const p1 = new Promise(function (resolve, reject) { &gt;setTimeout(() =&gt; reject(new Error('p1的状态改为错误')), 0) &gt;}) &gt;const p2 = new Promise(function (resolve, reject) { &gt;setTimeout(() =&gt; resolve(p1), 3000) //将p1 传给p2 &gt;}) &gt;p2.then(result =&gt; console.log(result),result=&gt;console.log('失败')) &gt;.catch(error =&gt; console.log('catch异常捕获:'+error)) &gt;//首先报错 &gt;//运行三秒后打印: 失败 上面代码运行后执行效果: 首先马上会打印一个报错 : “Uncaught (in promise) Error: p1的状态改为错误” (红色报错) 然后等3秒后再打印: ‘失败’ 注意: 如果 p2.then() 中没有写 reject 回调函数(第二个参数),则会被 catch 捕获,变为catch异常捕获:Error: p1的状态改为错误 解释: 首先前面说过,promise定义时就会立即执行,所以刚开始就运行了 p1 的reject(),所以直接控制台报错了 resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态 总结来说,promise返回promise这种嵌套形式,将由最内层的promise决定外层的状态 ⑧ 调用resolve或reject并不会终结 Promise 的参数函数的执行 调用resolve或reject并不会终结 Promise 的参数函数的执行。 &gt;new Promise((resolve, reject) =&gt; { &gt;resolve(1); &gt;console.log(2); &gt;}).then(r =&gt; { &gt;console.log(r); &gt;}); &gt;// 2 &gt;// 1 上面代码中，调用resolve(1)以后，后面的console.log(2)还是会执行，并且会首先打印出来。这是因为立即 resolved 的 Promise 是在本轮事件循环的末尾执行，总是晚于本轮循环的同步任务。 ⑨ 建议在修改状态函数前加return 一般来说，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而不应该直接写在resolve或reject的后面。所以，最好在它们前面加上return语句，这样就不会有意外。 &gt;new Promise((resolve, reject) =&gt; { &gt;return resolve(1); &gt;// 后面的语句不会执行 &gt;console.log(2); &gt;}) 有同学可能就会问了,不加感觉也没啥事啊,反正我在这个函数体内就是要做这些操作,放在 resolve/reject前后好像都不影响啊! 这里我给举个实际场景 a) 不加 return 导致的错误场景举🌰 一般来说,错误发生在 Promise 内,是不会传到外部的,只会在 Promise 内部消化,详见下方API详解部分的 [②Promise.prototype.catch()](#② Promise.prototype.catch()) &gt;const promise = new Promise(function (resolve, reject) { &gt;resolve('成功了'); //如果你加了 return , 函数执行到此步就停止了 &gt;setTimeout(function () { throw new Error('错误错误!!!!!') }, 0) &gt;}); &gt;promise.then(function (value) { console.log(value) }); &gt;// ok &gt;// Uncaught Error: 错误错误!!!! 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误。到了那个时候，Promise 的运行已经结束了，所以这个错误是在 Promise 函数体外抛出的，会冒泡到最外层，成了未捕获的错误。 Ⅱ - API 用法详解 此处将对于所有API进行详细剖析,参照资料为 阮一峰的ES6日志 ① Promise.prototype.then() Promise 实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。 a) then方法返回的是一个新的Promise实例 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 &gt;getJSON(\"./hong.json\").then(function(json) { &gt;return json.name; &gt;}).then(function(name) { &gt;console.log(`My name is ${name}` ) &gt;}); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 b) 采用链式的then, 会等待前一个Promise状态发生改变才会被调用 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 &gt;getJSON(\"./hong.json\") &gt;.then(function(json) { return getJSON(json.name)}) &gt;.then( function (name) { console.log(\"resolved: My name is \", name)}, function (err){ console.log(\"rejected: \", err)} ); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为resolved，就调用第一个回调函数，如果状态变为rejected，就调用第二个回调函数。 c) 使用箭头函数简写 如果采用箭头函数，上面的代码可以写得更简洁 (实际代码中基本都是这样写了) &gt;getJSON(\"./hong.json\") &gt;.then(json =&gt; getJSON(json.name) ) &gt;.then( name =&gt; console.log(\"resolved: My name is \", name), err =&gt; console.log(\"rejected: \", err) ); ② Promise.prototype.catch() Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。 a) 基本用法 &gt;getJSON('./hong.json') &gt;.then(function(posts) {}) &gt;.catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('发生错误！', error); }); 上面代码中，getJSON()方法返回一个 Promise 对象 如果该对象状态变为resolved，则会调用then()方法指定的回调函数； 如果异步操作抛出错误，状态就会变为rejected，就会调用catch()方法指定的回调函数，处理这个错误 另外，then()方法指定的回调函数，如果运行中抛出错误，也会被catch()方法捕获。 被 catch 方法捕获的前提是前方的 then() 方法中没有对 rejected 进行捕获处理(即没有写reject回调函数) &gt;p.then((val) =&gt; console.log('指定成功回调:', val)) &gt;.catch((err) =&gt; console.log('在catch中进行 rejected 的处理', err)); &gt;// 等同于 &gt;p.then((val) =&gt; console.log('指定成功回调:', val)) &gt;.then(null, (err) =&gt; console.log(\"等同于另起一个then,只指定 rejected 的处理\", err)); b) reject()方法的作用，等同于抛出错误 &gt;const promise = new Promise(function(resolve, reject) { &gt;throw new Error('直接抛出错误'); &gt;}); &gt;promise.catch(function(error) { &gt;console.log('异常捕获: ',error); &gt;}); &gt;//异常捕获: Error: 直接抛出错误 上面代码中，promise抛出一个错误，就被catch()方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 &gt;/****************** 写法一 ***************************************/ &gt;const promise = new Promise(function(resolve, reject) { &gt;try { &gt;throw new Error('直接抛出错误'); &gt;} catch(e) { console.log('进入catch,然后再用 reject(e)抛出 ') reject(e) &gt;} &gt;}); &gt;promise.catch(function(error) { &gt;console.log(error); &gt;}); &gt;//进入catch,然后再用 reject(e)抛出 &gt;//Error: 直接抛出错误 &gt;/****************** 写法二 ***************************************/ &gt;const promise1 = new Promise(function(resolve, reject) { &gt;reject(new Error('使用 reject() 抛出错误')); &gt;}); &gt;promise1.catch(function(error) { &gt;console.log(error); &gt;}); &gt;//Error: 使用 reject() 抛出错误 比较上面两种写法，可以发现reject()方法的作用，等同于抛出错误,所以不必用try..catch()去承接后再去抛出了 c) 如果 Promise 状态已经被修改，再抛出错误是无效的 &gt;const promise = new Promise(function(resolve, reject) { &gt;resolve('成功了'); //换成 reject('成功了') 结果也是一样的 &gt;throw new Error('成功后扔抛出异常'); &gt;}); &gt;promise &gt;.then(function(value) { console.log(value) }) &gt;.catch(function(error) { console.log(error) }); &gt;// 成功了 上面代码中，Promise 在resolve/reject语句后面，再抛出错误，不会被捕获，等于没有抛出。因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了(前面有说过) d) Promise 对象的错误具有 “冒泡” 性质 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 &gt;getJSON('./hong.json') //第一个promise &gt;.then(function(post) { //第二个promise return getJSON(post.commentURL) }) &gt;.then(function(comments) { //第三个promise }) &gt;.catch(function(error) { // 处理前面三个Promise产生的错误 }); 上面代码中，一共有三个 Promise 对象(then返回的仍可能是一个Promise对象)：一个由getJSON()产生，两个由then()产生。它们之中任何一个抛出的错误，都会被最后一个catch()捕获。 也是因为这个特性,有了 异常穿透问题 e) 异常穿透问题 当使用 promise 的 then 链式调用时, 可以在最后指定失败的回调 前面任何操作出了异常, 都会传到最后失败的回调中处理 &gt;getJSON('./hong.json') .then(function(posts) { throw new Error('抛出异常') }) .then(res=&gt;console.log(res),e=&gt;console.log('被then的错误回调捕获',e) ) .catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log('错误捕获: ', error); }); &gt;//执行结果: 被then的错误回调捕获 Error: 抛出异常 &gt;/******************** 利用异常穿透 ****************************************/ &gt;getJSON('./hong.json') .then(function(posts) { throw new Error('抛出异常') }) .then(res=&gt;console.log(res) ) //此处差异,不指定 reject 回调,利用异常穿透传到最后 .catch(function(error) { console.log('错误捕获: ', error); }); &gt;//执行结果: 错误捕获: Error: 抛出异常 注:可以在每个then()的第二个回调函数中进行err处理,也可以利用异常穿透特性,到最后用catch去承接统一处理,两者一起用时,前者会生效(因为err已经将其处理,就不会再往下穿透)而走不到后面的catch f) 建议使用 catch() 进行异常处理 一般来说，不要在then()方法里面定义 Reject 状态的回调函数（即then的第二个参数），总是使用catch方法。 &gt;// bad &gt;promise &gt;.then( &gt;data=&gt; console.log('成功',data), &gt;err=&gt;console.log('失败了',err) ); &gt;/********* 好的写法 ********************/ &gt;promise &gt;.then( data=&gt; console.log('成功',data)) //只指定成功回调 &gt;.catch( err=&gt;console.log('失败了',err)); 上面代码中，第二种写法要好于第一种写法: 理由是第二种写法可以捕获前面then方法执行中的错误 也更接近同步的写法（try/catch） 因此, 建议总是使用catch()方法，而不使用then()方法的第二个参数。 g) 与传统 try/catch 代码块的差异 跟传统的try/catch代码块不同的是，如果没有使用catch()方法指定错误处理的回调函数，Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。 &gt;const someAsyncThing = function() { &gt;return new Promise(function(resolve, reject) { &gt;// 下面一行会报错，因为hong 没有声明 &gt;resolve( hong ); &gt;}); &gt;}; &gt;//Promise 的 then() 处理,但不处理异常 &gt;someAsyncThing().then(function() { console.log('只指定成功回调,不处理异常错误') }); &gt;setTimeout(() =&gt; { console.log('努力学习的汪') }, 2000); &gt;// Uncaught (in promise) ReferenceError: hong is not defined &gt;// 努力学习的汪 上面代码中，someAsyncThing()函数产生的 Promise 对象，内部有语法错误。 浏览器运行到这一行，会打印出错误提示Uncaught (in promise) ReferenceError: hong is not defined 但是不会退出进程、终止脚本执行, 2 秒之后还是会输出努力学习的汪。 这就是说，Promise 内部的错误不会影响到 Promise 外部的代码，通俗的说法就是“Promise 会吃掉错误”。 h) catch()方法后还能跟 then() 方法 一般总是建议，Promise 对象后面要跟catch()方法，这样可以处理 Promise 内部发生的错误。catch()方法返回的还是一个 Promise 对象，因此后面还可以接着调用then()方法。 &gt;const someAsyncThing = function() { &gt;return new Promise(function(resolve, reject) { &gt;// 下面一行会报错，因为 hong 没有声明 &gt;resolve( hong ); &gt;}); &gt;}; &gt;someAsyncThing() &gt;.catch(function(error) { console.log('捉到错误咯:', error)}) &gt;.then(function() { console.log('错误捕获后我还要浪') }); &gt;//捉到错误咯: ReferenceError: hong is not defined &gt;//错误捕获后我还要浪 上面代码运行完catch()方法指定的回调函数，会接着运行后面那个then()方法指定的回调函数。 如果没有报错，则会跳过catch()方法。 &gt;Promise.resolve('硬是成功了') &gt;.catch(function(error) { console.log('捉错误', error) }) &gt;.then(v =&gt; console.log('catch后面的then: ',v) ); &gt;//catch后面的then: 硬是成功了 上面的代码因为没有报错，跳过了catch()方法，直接执行后面的then()方法。此时，要是then()方法里面报错，就与前面的catch()无关了。 i) catch()方法之中，还能再抛出错误 catch()方法之中，还能再抛出错误。 &gt;const someAsyncThing = function() { &gt;return new Promise(function(resolve, reject) { &gt;// 下面一行会报错，因为 hong 没有声明 &gt;resolve( hong ); &gt;}); &gt;}; &gt;someAsyncThing() &gt;.then(() =&gt; someOtherAsyncThing()) &gt;.catch(function(error) { console.log('ctach:', error); // 下面一行会报错，因为 sum 没有声明 sum ++; }) &gt;.then(function() { console.log('捕获后的then()')}); &gt;// ctach: [ReferenceError: hong is not defined] &gt;// Uncaught (in promise) ReferenceError: sum is not defined 上面代码中，catch()方法抛出一个错误，因为后面没有别的catch()方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 &gt;someAsyncThing().then(function() { &gt;return someOtherAsyncThing(); &gt;}).catch(function(error) { &gt;console.log('catch: ', error); &gt;// 下面一行会报错，因为 sum 没有声明 &gt;sum ++; &gt;}).catch(function(error) { &gt;console.log('catch()后的catch: ', error); &gt;}); &gt;//catch: ReferenceError: hong is not defined &gt;//catch()后的catch: ReferenceError: sum is not defined 上面代码中，第二个catch()方法用来捕获前一个catch()方法抛出的错误。 ③ Promise.prototype.finally() finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 &gt;promise &gt;.then(result =&gt; {···}) &gt;.catch(error =&gt; {···}) &gt;.finally(() =&gt; {···}); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 finally方法的回调函数不接受任何参数， 这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。 这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 a) finally本质上是then方法的特例 &gt;promise &gt;.finally(() =&gt; {}); &gt;// 等同于 &gt;promise &gt;.then( &gt;result =&gt; result , &gt;error =&gt; throw error &gt;); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 b) 它的实现 它的实现也很简单。 &gt;Promise.prototype.finally = function (callback) { &gt;let P = this.constructor; &gt;return this.then( &gt;value =&gt; P.resolve(callback()).then(() =&gt; value), &gt;reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }) &gt;); &gt;}; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值(传入什么即传出什么) &gt;// resolve 的值是 undefined &gt;Promise.resolve(2).then(() =&gt; {}, () =&gt; {}) &gt;// resolve 的值是 2 &gt;Promise.resolve(2).finally(() =&gt; {}) &gt;// reject 的值是 undefined &gt;Promise.reject(3).then(() =&gt; {}, () =&gt; {}) &gt;// reject 的值是 3 &gt;Promise.reject(3).finally(() =&gt; {}) ④ Promise.all() Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。 &gt;const p = Promise.all([p1, p2, p3]); Promise.all()方法接受一个数组作为参数， p1、p2、p3都是 Promise 实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 另外，Promise.all()方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例。 a) 返回的状态由什么决定? p的状态由p1、p2、p3决定，分成两种情况。 只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。&gt;// 生成一个Promise对象的数组 &gt;const promises = ['hong', 1, 2, 3, 4, 5].map(item { &gt;return getJSON( item+'.json'); &gt;}); &gt;Promise.all(promises).then(function (posts) { &gt;// ... &gt;}).catch(function(reason){ &gt;// ... &gt;}); 上面代码中，promises是包含 6 个 Promise 实例的数组，只有这 6 个实例的状态 都 变成fulfilled，或者**其中有一个变为rejected**，才会调用Promise.all方法后面的回调函数。 下面是另一个例子&gt;const databasePromise = connectDatabase(); //假设定义了一个异步方法,此方法能拿到你需要的所有数据 &gt;const booksPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部书本信息 &gt;.then(findAllBooks); &gt;const userPromise = databasePromise //定义一个方法,在 databasePromise() 执行后寻找其内部当前用户信息 &gt;.then(getCurrentUser); &gt;Promise.all([ &gt;booksPromise, &gt;userPromise &gt;]) &gt;.then(([books, user]) =&gt; pickTopRecommendations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommendations这个回调函数。 b) 如果参数中的Promise实例定义了自己的catch方法 ? 注意，如果作为参数的 Promise 实例，自己定义了catch方法，那么它一旦被rejected，并不会触发Promise.all()的catch方法。 &gt;//定义一个状态将为成功的的promise &gt;const p1 = new Promise((resolve, reject) =&gt; { resolve('hello')}) &gt;.then(result =&gt; result) &gt;.catch(e =&gt; e); &gt;//定义一个将抛出错误的promise &gt;const p2 = new Promise((resolve, reject) =&gt; { throw new Error('报错了') }) &gt;.then(result =&gt; result) &gt;.catch(e =&gt;{ &gt;console.log('p2自己的catch捕获: ', e) &gt;return e; //异常获取后原样返回,不做修改 &gt;}); &gt;//调用 Promise.all 方法 &gt;Promise.all([p1, p2]) &gt;.then(result =&gt; console.log(' Promise.all 方法中的成功回调: ', result)) &gt;.catch(e =&gt; console.log(\" Promise.all 方法中的catch\", e)); &gt;//p2自己的catch捕获: Error: 报错了 &gt;// Promise.all 方法中的成功回调: (2) ['hello', Error: 报错了] 上面代码中， p1会resolved，p2首先会rejected 但是p2有自己的catch方法，该方法返回的是一个新的 Promise 实例，p2指向的实际上是这个实例。 该实例执行完catch方法后，也会变成resolved，导致Promise.all()方法参数里面的两个实例都会resolved 因此会调用then方法指定的回调函数，而不会调用catch方法指定的回调函数 c) 如果参数中的Promise实例 没有 定义自己的catch方法 ? 如果p2没有自己的catch方法，就会调用Promise.all()的catch方法。 &gt;//定义一个状态将为成功的的promise &gt;const p1 = new Promise((resolve, reject) =&gt; { resolve('hello')}) &gt;.then(result =&gt; result) &gt;//定义一个将抛出错误的promise &gt;const p2 = new Promise((resolve, reject) =&gt; { throw new Error('报错了') }) &gt;.then(result =&gt; result) &gt;//调用 Promise.all 方法 &gt;Promise.all([p1, p2]) &gt;.then(result =&gt; console.log(' Promise.all 方法中的成功回调: ', result)) &gt;.catch(e =&gt; console.log(\" Promise.all 方法中的catch\", e)); &gt;// Promise.all 方法中的catch Error: 报错了 ⑤ Promise.race() Promise.race()方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。 &gt;const p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race()方法的参数与Promise.all()方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve()方法，将参数转为 Promise 实例，再进一步处理。 a) 举个简单的🌰 如p1延时,开启了异步,内部正常是同步进行,所以p2&gt;p3&gt;p1,结果是P2 &gt;let p1 = new Promise((resolve, reject) =&gt; { &gt;setTimeout(() =&gt; { &gt;resolve('OK'); &gt;}, 1000); &gt;}) &gt;let p2 = Promise.resolve('Success'); &gt;let p3 = Promise.resolve('Oh Yeah'); &gt;//调用 &gt;const result = Promise.race([p1, p2, p3]); &gt;console.log(result); b) 举个应用实🌰 下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为reject，否则变为resolve。 &gt;const p = Promise.race([ &gt;fetch('https://gitee.com/hongjilin'), &gt;new Promise(function (resolve, reject) { &gt;setTimeout(() =&gt; reject(new Error('请求超时!!!!')), 5000) &gt;}) &gt;]); &gt;p &gt;.then(console.log) &gt;.catch(console.error); 上面代码中，如果 5 秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 是不是很好用又简单 ⑥ Promise.allSettled() Promise.allSettled()方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。 只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。 该方法由 ES2020 引入。 a) 举个简单的🌰 &gt;const promises = [ &gt;fetch('https://gitee.com/hongjilin'), &gt;fetch('https://github.com/Hongjilin'), &gt;fetch('./hong.json'), &gt;]; &gt;loading = true; //请求前将 loading 改为true ; 页面出现滚动加载图标蒙层 &gt;await Promise.allSettled(promises); &gt;loading = false; 上面代码对服务器发出三个请求，等到三个请求都结束，不管请求成功还是失败，加载的滚动图标就会消失。 b) 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected 该方法返回的新的 Promise 实例，一旦结束，状态总是fulfilled，不会变成rejected。状态变成fulfilled后，Promise 的监听函数接收到的参数是一个数组，每个成员对应一个传入Promise.allSettled()的 Promise 实例。 &gt;const resolved = Promise.resolve('返回成功状态的promise'); &gt;const rejected = Promise.reject('返回失败状态的promise'); &gt;const allSettledPromise = Promise.allSettled([resolved, rejected]); &gt;// Promise.allSettled 得到的新实例状态只会是 `fulfilled` &gt;allSettledPromise.then(function (results) { &gt;console.log(results); //注意,这是 `fulfilled` 的回调函数,只有其状态为成功才能进到这里 &gt;}); &gt;/* &gt;[ { \"status\": \"fulfilled\", \"value\": \"返回成功状态的promise\" }, { \"status\": \"rejected\", \"reason\": \"返回失败状态的promise\" } &gt;] &gt;*/ Promise.allSettled()的返回值allSettledPromise，状态只可能变成fulfilled(注意,是 allSettledPromise 的状态,而不是内部的promise实例) 它的监听函数接收到的参数是数组results。该数组的每个成员都是一个对象，对应的是传入Promise.allSettled()的 Promise 实例。 每个对象都有status属性，该属性的值只可能是字符串fulfilled或字符串rejected。 fulfilled时，对象有value属性，rejected时有reason属性，对应两种状态的返回值。 c) 举个返回值用法的🌰 &gt;const promises = [ fetch('./hong.json'), fetch('https://gitee.com/hongjilin') ]; &gt;const results = await Promise.allSettled(promises); &gt;// 过滤出成功的请求 &gt;const successfulPromises = results.filter(item =&gt; item.status === 'fulfilled'); &gt;// 过滤出失败的请求，并取得它们的失败原因 &gt;const errors = results &gt;.filter(p =&gt; p.status === 'rejected') &gt;.map(p =&gt; p.reason); 有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。 &gt;const urls = [ 'https://gitee.com/hongjilin' ,'https://github.com/Hongjilin']; &gt;const requests = urls.map(x =&gt; fetch(x)); &gt;//举例用 Promise.all 尝试实现,很明显,难以实现 &gt;try { &gt;await Promise.all(requests); &gt;console.log('所有请求都成功。'); &gt;} catch { &gt;console.log('至少一个请求失败，其他请求可能还没结束。'); &gt;} 上面代码中，Promise.all()无法确定所有请求都结束。想要达到这个目的，写起来很麻烦，有了Promise.allSettled()，这就很容易了 ⑦ Promise.any() ES2021 引入了Promise.any()方法。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成fulfilled状态，包装实例就会变成fulfilled状态；如果所有参数实例都变成rejected状态，包装实例就会变成rejected状态。 a) 与 Promise.race() 方法的区别 Promise.any()跟Promise.race()方法很像，只有一点不同，就是不会因为某个 Promise 变成rejected状态而结束。 &gt;const promises = [ &gt;fetch('https://gitee.com/hongjilin').then(() =&gt; 'a'), &gt;fetch('https://github.com/Hongjilin').then(() =&gt; 'b'), &gt;fetch('./hong.json').then(() =&gt; 'c'), &gt;]; &gt;try { &gt;const first = await Promise.any(promises); &gt;console.log(first); &gt;} catch (error) { &gt;console.log(error); &gt;} 上面代码中，Promise.any()方法的参数数组包含三个 Promise 操作。其中只要有一个变成fulfilled，Promise.any()返回的 Promise 对象就变成fulfilled。如果所有三个操作都变成rejected，那么await命令就会抛出错误。 b) Promise.any() 抛出的错误 Promise.any()抛出的错误，不是一个一般的错误，而是一个 AggregateError 实例。它相当于一个数组，每个成员对应一个被rejected的操作所抛出的错误。下面是 AggregateError 的实现示例。 &gt;new AggregateError() extends Array -&gt; AggregateError &gt;const err = new AggregateError(); &gt;err.push(new Error(\"first error\")); &gt;err.push(new Error(\"second error\")); &gt;throw err; 捕捉错误时，如果不用try...catch结构和 await 命令，可以像下面这样写。 &gt;Promise.any(promises).then( &gt;(first) =&gt; { &gt;// Any of the promises was fulfilled. &gt;}, &gt;(error) =&gt; { &gt;// All of the promises were rejected. &gt;} &gt;); c) 再举个🌰 下面是一个例子。 &gt;const resolved = Promise.resolve('成功'); &gt;const rejected = Promise.reject('失败了'); &gt;const alsoRejected = Promise.reject('太失败了'); &gt;Promise.any([resolved, rejected, alsoRejected]).then(function (result) { &gt;console.log(result); // 成功 &gt;}); &gt;Promise.any([rejected, alsoRejected]).catch(function (results) { &gt;console.log(results); //AggregateError: All promises were rejected &gt;}); 三个Promise中有一个为成功,则总的结果就是成功,三个中全部失败,才会变成失败 ⑧ Promise.resolve() 有时需要将现有对象转为 Promise 对象，Promise.resolve()方法就起到这个作用。 &gt;const jsPromise = Promise.resolve($.ajax('https://gitee.com/hongjilin')); 上面代码将 jQuery 生成的deferred对象，转为一个新的 Promise 对象。 Promise.resolve()等价于下面的写法。 &gt;Promise.resolve('努力学习的汪') &gt;// 等价于 &gt;new Promise(resolve =&gt; resolve('努力学习的汪')) Promise.resolve()方法的参数分成四种情况 a) 参数是一个 Promise 实例 如果参数是 Promise 实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 b) 参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 &gt;let thenable = { then: function(resolve, reject) { resolve('成功'); } &gt;}; Promise.resolve()方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then()方法。 &gt;let thenable = { then: function(resolve, reject) { resolve('成功') } &gt;}; &gt;let p1 = Promise.resolve(thenable); &gt;p1.then(function (value) { console.log(value); // '成功' &gt;}); 上面代码中，thenable对象的then()方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then()方法指定的回调函数，输出 **’成功’**。 c) 参数不是具有then()方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then()方法的对象，则Promise.resolve()方法返回一个新的 Promise 对象，状态为resolved。 &gt;const p = Promise.resolve('努力学习的汪'); &gt;p.then(function (s) { &gt;console.log(s) &gt;}); &gt;// 努力学习的汪 上面代码生成一个新的 Promise 对象的实例p。 由于字符串 努力学习的汪 不属于异步操作（判断方法是字符串对象不具有 then 方法） 返回 Promise 实例的状态从一生成就是resolved，所以回调函数会立即执行 Promise.resolve()方法的参数会同时传给回调函数作为其参数 d) 不带有任何参数 Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。 所以，如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。 &gt;const p = Promise.resolve(); &gt;p.then(function () {}); 上面代码的变量p就是一个 Promise 对象。 需要注意的是，立即resolve()的 Promise 对象，是在本轮“事件循环”（event loop）的结束时执行，而不是在下一轮“事件循环”的开始时 –&gt; 不懂的同学请看 JavaScript笔记中的#4事件循环模型event-loop机制 ,本人在此有进行详细的解析 &gt;setTimeout(function () { &gt;console.log('three'); //这里是新的一轮事件循环 &gt;}, 0); &gt;Promise.resolve().then(function () { &gt;console.log('two'); //本轮同步代码结束后,新一轮事件循环前,就执行 &gt;}); &gt;console.log('one'); &gt;// one &gt;// two &gt;// three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log('one')则是立即执行，因此最先输出。 ⑨ Promise.reject() Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 &gt;const p = Promise.reject('出错了'); &gt;// 等同于 &gt;const p = new Promise((resolve, reject) =&gt; reject('出错了')) &gt;p.then(null, function (s) { &gt;console.log(s) &gt;}); &gt;// 出错了 上面代码生成一个 Promise 对象的实例p，状态为rejected，回调函数会立即执行。 Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。 &gt;Promise.reject('出错了') &gt;.catch(e =&gt; { &gt;console.log(e === '出错了') &gt;}) &gt;// true 上面代码中，Promise.reject()方法的参数是一个字符串，后面catch()方法的参数e就是这个字符串。 ⑩ Promise.try() 实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 &gt;Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 &gt;const f = () =&gt; console.log('now'); &gt;Promise.resolve().then(f); &gt;console.log('next'); &gt;// next &gt;// now 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？ a) 写法一 : 用async函数来写 该知识点如果不懂的可以继续往下看,这是ES6的另外一块知识点内容 &gt;const f = () =&gt; console.log('now'); &gt;(async () =&gt; f())(); &gt;console.log('next'); &gt;// now &gt;// next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 &gt;(async () =&gt; f())() &gt;.then(...) 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 &gt;(async () =&gt; f())() &gt;.then(...) &gt;.catch(...) b) 写法二 : 使用new Promise() &gt;const f = () =&gt; console.log('now'); &gt;( () =&gt; new Promise( resolve =&gt; resolve(f()) ) &gt;)(); &gt;console.log('next'); &gt;// now &gt;// next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 c) Promise.try的引出 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 &gt;const f = () =&gt; console.log('now'); &gt;Promise.try(f); &gt;console.log('next'); &gt;// now &gt;// next 事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 &gt;function getUsername(userId) { return database.users.get({id: userId}) .then(function(user) { return user.name; }); &gt;} 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 &gt;database.users.get({id: userId}) &gt;.then(...) &gt;.catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 &gt;try { database.users.get({id: userId}) .then(...) .catch(...) &gt;} catch (e) { // ... &gt;} 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 &gt;Promise.try(() =&gt; database.users.get({id: userId})) .then(...) .catch(...) 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。 三、自定义Promise手写 下方的Promise.prototype.then与Promise.resolve为什么一个挂载在prototype而另一个挂载在实例对象上? 解:原因是分别为静态方法与实例方法 –&gt;上面的需要new实例化的时候自动继承实例prototype上的方法和属性,所以用实例对象.then()来调用,而下面的Promise.resolve是静态方法,不用new,是可以直接Promise.resolve()调用 此部分可以跳过不看,类似手撕源码 Ⅰ-Promise的实例方法实现1 - 初始结构搭建 html引入,该章节后续html大部分重复 除非必要,否则不再放上来 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Promise-封装 | 1 - 初始结构搭建&lt;/title&gt; &lt;script src=\"./promise.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; let p = new Promise((resolve, reject) =&gt; { resolve('OK'); }); p.then(value =&gt; { console.log(value); }, reason=&gt;{ console.warn(reason); }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; promise.js –&gt;使用原生写法,最后会改为class写法 function Promise(executor){} //添加 then 方法 Promise.prototype.then = function(onResolved, onRejected){} 2 - resolve 与 reject构建与基础实现 使用const self = this;保存this执行,使function中可以取得当前实例 ps:可以不使用该方法保存,但是下方function需要改为箭头函数,否则function默认指向是window 之后代码默认使用self保存this,箭头函数方式将在最后改为class写法时使用 默认设置 PromiseState = 'pending'以及 PromiseResult = null,这就是promise状态基础 //声明构造函数 function Promise(executor) { //添加属性 this.PromiseState = 'pending'; this.PromiseResult = null; //保存实例对象的 this 的值 /* 此处可以不写,但是下面function方法需要改为箭头函数,否则function默认指向是window */ const self = this; //resolve 函数 function resolve(data) {-------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = 'fulfilled'; // resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; } //reject 函数 function reject(data) {---------------------------------------------- //1. 修改对象的状态 (promiseState) self.PromiseState = 'rejected'; // //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; } //同步调用『执行器函数』 executor(resolve, reject); } //添加 then 方法 Promise.prototype.then = function (onResolved, onRejected) {} 3 - throw 抛出异常改变状态 在2的基础上进行修改:将执行器放入try-catch()中 在catch中使用reject()修改 promise 对象状态为『失败』 try { //同步调用『执行器函数』 executor(resolve, reject); } catch (e) { //修改 promise 对象状态为『失败』 reject(e); } 4 - 状态只能修改一次 基于2 3代码中resolve和reject方法进修改 在成功与失败函数中添加判断 if(self.PromiseState !== 'pending') return;,如果进入函数时状态不为pending直接退出,这样就能做到状态只能从pending改至其他状态且做到只能改一次 html调用-------------------------------------------------------- let p = new Promise((resolve, reject) =&gt; { reject(\"error\"); resolve('OK'); //抛出异常 // throw \"error\"; }); console.log(p); promise.js修改-------------------------------------------------------- //resolve 函数 function resolve(data){ //判断状态 if(self.PromiseState !== 'pending') return; //1. 修改对象的状态 (promiseState) self.PromiseState = 'fulfilled';// resolved //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; } //reject 函数 function reject(data){ //判断状态 if(self.PromiseState !== 'pending') return; //1. 修改对象的状态 (promiseState) self.PromiseState = 'rejected';// //2. 设置对象结果值 (promiseResult) self.PromiseResult = data; } 5 - then 方法执行回调基础实现 修改Promise.prototype.then方法 传入then(成功回调,失败回调),当调用then后,会判断当前this.PromiseState的状态,当其为成功时调用成功回调,失败时调用失败回调 html调用------------------------------------------------------------ let p = new Promise((resolve, reject) =&gt; { // resolve('OK');// reject(\"Error\"); throw \"ERROR\"; }); p.then( value =&gt; {console.log(value); }, reason =&gt; {console.warn(reason);} ) promise.js修改与实现----------------------------------------------------- //添加 then 方法 Promise.prototype.then = function (onResolved, onRejected) { //调用回调函数 PromiseState if (this.PromiseState === 'fulfilled') {onResolved(this.PromiseResult);} if (this.PromiseState === 'rejected') {onRejected(this.PromiseResult);} } 6 - 异步任务 then 方法实现 此处对于5有四处修改,下面上js代码 当我运行异步代码后,我的执行器内部代码还未返回(因为用了定时器,里面的代码进入了异步队列),所以当我下面的.then()运行时:我的p为pending状态,所以根本不会执行resolve与reject方法 解:添加判断pending状态,将当前回调函数保存到实例对象(存到实例上是为了更方便)中,这样后续改变状态时候才调用得到 为什么要将回调保存到实例上而不是直接调用? 理由:因为我的回调函数需要在我的promise状态改变后(成功或者失败),再根据状态选择运行哪个函数所以当你调用then()时却检测到状态为pending,说明这时候的promise在异步队列 不能直接运行成功或者失败函数 解决:因为resolve与reject方法与then()不在同一个作用域中,并不能共享then(成功回调,失败回调)的参数,所以在判断状态为pending时将回调保存到实例对象上.然后将回调函数的调用放在resolve()与reject()中 这样当我代码运行到异步队列的resolve()或reject()时,就可以在这个函数中运行回调函数,实现异步then 此处的then仍有瑕疵,需要继续完善 html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {reject(\"error\"); /* resolve('OK');*/}, 1000); }); p.then(value =&gt; {console.log(value);},reason =&gt; { console.warn(reason);}); console.log(p); promise.js修改与实现----------------------------------------------------- //声明构造函数 function Promise(executor) { this.PromiseState = 'pending'; this.PromiseResult = null; // 声明属性 this.callback = {}; -----------新添加1 const self = this; //resolve 函数 function resolve(data) { //判断状态 if (self.PromiseState !== 'pending') return; self.PromiseState = 'fulfilled'; self.PromiseResult = data; //调用成功的回调函数 加判断的原因是防止无回调报错 if (self.callback.onResolved) { self.callback.onResolved(data); } ------------新添加2 最重要 } //reject 函数 function reject(data) { if (self.PromiseState !== 'pending') return; self.PromiseState = 'rejected'; self.PromiseResult = data; //执行回调 if (self.callback.onResolved) { self.callback.onResolved(data);} ------------新添加3 } try {executor(resolve, reject);} catch (e) {reject(e);} } //添加 then 方法 Promise.prototype.then = function (onResolved, onRejected) { //调用回调函数 PromiseState if (this.PromiseState === 'fulfilled') {onResolved(this.PromiseResult);} if (this.PromiseState === 'rejected') { onRejected(this.PromiseResult);} //判断 pending 状态 if (this.PromiseState === 'pending') { ------------新添加4 //保存回调函数 this.callback = { onResolved: onResolved, onRejected: onRejected } } } 7 - 指定多个回调 基于6代码进行修改 只展示修改部分代码 6中保存回调函数的方式有BUG,如果我有多个.then(),后面加载的回调函数会覆盖之前的回调函数,导致最后回调函数有且只有最后一个 解:使用数组的方式进行存储回调函数,调用时也是用数组循环取出 此处的then仍有瑕疵,需要继续完善 html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; {setTimeout(() =&gt; {reject('No');}, 1000);}); p.then(value =&gt; { console.log(value);}, reason=&gt;{console.warn(reason);}); p.then(value =&gt; { alert(value);}, reason=&gt;{ alert(reason);}); console.log(p); promise.js修改与实现----------------------------------------------------- Promise.prototype.then = function (onResolved, onRejected) { //resolve 函数 function resolve(data){ ..... //调用成功的回调函数 // if (self.callback.onResolved) { self.callback.onResolved(data); } self.callbacks.forEach(item =&gt; { --------修改1 item.onResolved(data); }); } //reject 函数 function reject(data){ ...... //执行失败的回调 // if (self.callback.onResolved) { self.callback.onResolved(data);} self.callbacks.forEach(item =&gt; { ------修改2 item.onRejected(data); }); } //添加 then 方法 Promise.prototype.then = function(onResolved, onRejected){ ........ //判断 pending 状态 if(this.PromiseState === 'pending'){ //保存回调函数 // this.callback = { onResolved: onResolved, onRejected: onRejected } this.callbacks.push({ --------修改3 onResolved: onResolved, onRejected: onRejected }); } } 8 - 同步任务 then 返回结果 在之前的then运行结果中得知,我们使用 [ then ] 后的返回结果是其回调函数的返回结果,而我们需要的返回结果是一个新的promise对象 解:所以我们在then中return new Promise(),使其得到的是一个新的promise对象 在为解决问题1后产生一个新问题:新的promise对象因为没有用rejerect与resolve方法,导致返回的状态一直是pending 解:在新的promise中判断运行回调函数后的返回值是什么,然后根据其不同类型给其赋予不同状态 ​ Ⅰ-if(result instanceof Promise):返回值一个新的②promise对象(因为是新的promise的回调函数返回值,称②promise对象),在返回值(因为是promise对象)的.then()回调函数中使用rejerect与resolve方法,将其自身的状态赋予外层的promise, ​ 即 回调函数中的promise 赋值 给then返回值 , 所以 最终返回状态==回调函数中的新promise状态 ​ Ⅱ-如果返回值是一个非promise对象,返回状态设置为成功 ​ Ⅲ-如果返回值是一个异常,返回状态设置为失败 html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; {resolve('OK');}); //执行 then 方法 const res = p.then( value =&gt; { throw \"FAIL\";}, reason =&gt; { console.warn(reason);}); console.log(res); promise.js修改与实现----------------------------------------------------- //添加 then 方法 Promise.prototype.then = function(onResolved, onRejected){ return new Promise((resolve, reject) =&gt; { //调用回调函数 PromiseState // if(this.PromiseState === 'fulfilled'){ onResolved(this.PromiseResult);} 未修改时代码 if(this.PromiseState === 'fulfilled'){ -------修改1 try{ //获取回调函数的执行结果 let result = onResolved(this.PromiseResult); //判断 if(result instanceof Promise){//如果是 Promise 类型的对象,我就将下一个promise结果赋予外层 result.then(v =&gt; { resolve(v); },r=&gt;{reject(r);}) }else{resolve(result);} //如果返回的不是promise对象,都将其赋予成功状态 }catch(e){ rejerect(e); //如果出错了,则返回失败状态 } } if(this.PromiseState === 'rejected'){ onRejected(this.PromiseResult);}------此部分修改与修改1一样 //判断 pending 状态 if(this.PromiseState === 'pending'){ this.callbacks.push({ onResolved: onResolved, onRejected: onRejected}); } }) } 9 - 异步任务 then 返回结果 异步任务是修改if(this.PromiseState === 'pending')后面的值,原因参考6,下面代码只举例这部分修改 因为我们需要增加then状态修改,所以在我们保存回调函数这一步我们可以对于回调函数进行加工,添加判断其回调函数的返回值的代码块再存入实例的回调函数中 Ⅰ-声明一个新的函数:其内部功能-&gt;先运行onResolved回调函数,再将其返回值取出,进行判断其返回值(这个过程同8) Ⅱ-加工后存入实例回调函数数组,之后在resolve与reject方法中调用即可(同6) html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {reject(\"Error\");}, 1000)}); // resolve('OK'); //执行 then 方法 const res = p.then(value =&gt; { // return 'oh Yeah'; //如果有返回,根据其返回值得到相应的状态:字符串为成功,抛出为错误 throw 'error'; }, reason =&gt; { console.warn(reason, \"xx\"); //如果只是打印没返回,则实际上时返回一个undefined, //在我们封装js中,undefined会判定为非promise对象,所以状态为成功,结果为undefined return \"sss\" // throw 'error'; }); console.log(res); promise.js修改与实现----------------------------------------------------- //判断 pending 状态 if (this.PromiseState === 'pending') { //保存回调函数 this.callbacks.push({ onResolved: function () { try { //执行成功回调函数 let result = onResolved(self.PromiseResult); //判断 其结果 if (result instanceof Promise) { result.then( v =&gt; { resolve(v);}, r =&gt; {reject(r);} ) } else {resolve(result);} } catch (e) {reject(e);} }, onRejected: function () { try { //执行成功回调函数 let result = onRejected(self.PromiseResult); //判断 if (result instanceof Promise) { result.then( v =&gt; {resolve(v); }, r =&gt; {reject(r);} ) } else {resolve(result);} } catch (e) { reject(e); } } }); } 10- then方法代码优化 在8、9、10中可以看出,其判断与改变返回结果状态的代码块是基本重复的,所以可以将其抽出 //添加 then 方法 Promise.prototype.then = function (onResolved, onRejected) { const self = this; return new Promise((resolve, reject) =&gt; { 封装函数---------------------------------------------------------------------------- function callback(type) { try { //获取回调函数的执行结果 let result = type(self.PromiseResult); //判断 if (result instanceof Promise) { //如果是 Promise 类型的对象 result.then(v =&gt; { resolve(v); }, r =&gt; { reject(r); }) } else { //结果的对象状态为『成功』 resolve(result); } } catch (e) { reject(e); } } ----------------------------------------------------------------------------------- //调用回调函数 PromiseState if (this.PromiseState === 'fulfilled') { callback(onResolved); } if (this.PromiseState === 'rejected') { callback(onRejected); } //判断 pending 状态 if (this.PromiseState === 'pending') { //保存回调函数 this.callbacks.push({ onResolved: function () { callback(onResolved); }, onRejected: function () { callback(onRejected); } }); } }) } 11 - catch 方法与异常穿透与值传递 异常穿透:添加catch 方法 ,并且需要进行回调函数为undefined的处理 当我then()中只传一个回调或者不传回调函数时,运行代码会报错,因为运行时调用的回调函数是undefined 解:进行回调函数判断,当其为空时,基于默认回调函数内容:直接往外抛出这样下方的then() or catch()就可以承接到异常或者值 html调用------------------------------------------------------------ //实例化对象 let p = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {resolve('OK'); }, 1000); }); //值传递 p.then() .then(value =&gt; {console.log(222);}) .then(value =&gt; {console.log(333);}) .catch(reason =&gt; {console.warn(reason);}); promise.js修改与实现----------------------------------------------------- //添加 then 方法 Promise.prototype.then = function (onResolved, onRejected) { ... -----------修改1 if (typeof onRejected !== 'function') {onRejected = reason =&gt; { throw reason;}} if (typeof onResolved !== 'function') { onResolved = value =&gt; value;} .... } //添加 catch 方法 Promise.prototype.catch = function(onRejected){ ---------------异常穿透 修改2 return this.then(undefined, onRejected); } Ⅱ-Promise的静态方法实现1 - Promise.resolve 封装 判断传入的参数是否为promise对象: Ⅰ-如果为promise:将其状态与结果赋值给外层promise对象 Ⅱ-如果为非promise:状态设置为成功 html调用------------------------------------------------------------ const p = Promise.resolve('OK'); const p2 = Promise.resolve(new Promise((resolve, reject) =&gt; { reject(\"error\");// resolve('Success'); })); const p3 = Promise.resolve(Promise.resolve('Oh Yeah')); console.log(p3); promise.js修改与实现----------------------------------------------------- //添加 resolve 方法 Promise.resolve = function(value){ //返回promise对象 return new Promise((resolve, reject) =&gt; { if(value instanceof Promise){ value.then( v=&gt;{resolve(v);}, r=&gt;{reject(r);} )}else{resolve(value); }//状态设置为成功 }); } 2 - Promise.resolve 封装 不同于resolve,这个方法只要把传入参数再次传出去,并将状态改为失败即可 html调用------------------------------------------------------------ //Promise.reject const p = Promise.reject('Error'); const p2 = Promise.reject(new Promise((resolve, reject) =&gt; { resolve('OK'); })); console.log(p); console.log(p2); promise.js修改与实现----------------------------------------------------- //添加 reject 方法 Promise.reject = function (reason) { return new Promise((resolve, reject) =&gt; { reject(reason); }); } 3 - Promise.all 封装 遍历传入的promise数组,每当遍历结果是成功,则用计数器记录,当计数器等同于数组长度,则全部成功,这时候可以返回成功状态 如果当数组中任意一个promise的执行结果是reject,直接中断,返回状态为失败 html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {resolve('OK'); }, 1000) }) let p2 = Promise.reject('Success'); let p3 = Promise.resolve('Oh Yeah'); //调用 all 方法 let result = Promise.all([p1, p2, p3]); console.log(result); promise.js修改与实现----------------------------------------------------- //添加 all 方法 Promise.all = function (promises) { //返回结果为promise对象 return new Promise((resolve, reject) =&gt; { //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) { promises[i].then(v =&gt; { //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) {resolve(arr);}//修改状态 }, r =&gt; { reject(r); }); } }); } 4 - Promise.race 封装 直接谁先执行就返回谁的运行结果即可 html调用------------------------------------------------------------ let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; {resolve('OK');}); }); let p2 = Promise.reject('Success'); let p3 = Promise.resolve('Oh Yeah'); //调用 race 方法 let result = Promise.race([p1, p2, p3]); console.log(result); promise.js修改与实现----------------------------------------------------- //添加 race 方法 Promise.race = function (promises) { return new Promise((resolve, reject) =&gt; { for (let i = 0; i &lt; promises.length; i++) { promises[i].then(v =&gt; { //修改返回对象的状态为 『成功』 resolve(v); }, r =&gt; { //修改返回对象的状态为 『失败』 reject(r); }) } }); } Ⅲ-其他优化1 - 回调函数『异步执行』 如果我们运行下面代码,正确顺序是: 111 –&gt; 333 –&gt;444 let p1 = new Promise((resolve, reject) =&gt; { reject('OK'); console.log(111); }); p1.then(value =&gt; { console.log(222); }, reason =&gt; { console.log(444); }); console.log(333); 但当我们运行之前封装的 Promise 代码时,结果却是:111 –&gt; 444 –&gt; 333 我们需要将我们的then方法变成异步方法 我们只要在以下四处地方的回调函数调用外层包裹一层定时器(不一定是定时器,开启异步即可),即可做到异步操作 function resolve(data){ setTimeout(() =&gt; { self.callbacks.forEach(item =&gt; { item.onResolved(data); }); });--修改1 } //reject 函数 function reject(data){ setTimeout(() =&gt; { self.callbacks.forEach(item =&gt; { item.onRejected(data); }); });---修改2 } &gt;//添加 then 方法 &gt;Promise.prototype.then = function(onResolved, onRejected){ return new Promise((resolve, reject) =&gt; { //调用回调函数 PromiseState /* 修改前代码 if (this.PromiseState === 'fulfilled') { callback(onResolved); } if (this.PromiseState === 'rejected') { callback(onRejected); */ if(this.PromiseState === 'fulfilled'){setTimeout(() =&gt; { callback(onResolved);});} -----修改3 if(this.PromiseState === 'rejected'){ setTimeout(() =&gt; { callback(onRejected);}); ---修改4 } } 相关原理参照js事件循环机制、宏任务与微任务 2- class改写promise 其中将self=this保存this指向方式改为箭头函数表示(在上面示例中也有效果) 将其改为class写法 下面为promisedemo.js代码 &gt;class Promise { //构造方法 constructor(executor) { //添加属性 this.PromiseState = 'pending'; this.PromiseResult = null; //声明属性 this.callbacks = []; //保存实例对象的 this 的值 //resolve 函数 let resolve = (data) =&gt; { //判断状态 if (this.PromiseState !== 'pending') return; //1. 修改对象的状态 (promiseState) this.PromiseState = 'fulfilled'; // resolved //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //调用成功的回调函数 setTimeout(() =&gt; { this.callbacks.forEach(item =&gt; { item.onResolved(data); }); }); } //reject 函数 let reject = (data) =&gt; { //判断状态 if (this.PromiseState !== 'pending') return; //1. 修改对象的状态 (promiseState) this.PromiseState = 'rejected'; // //2. 设置对象结果值 (promiseResult) this.PromiseResult = data; //执行失败的回调 setTimeout(() =&gt; { this.callbacks.forEach(item =&gt; { item.onRejected(data); }); }); } try { //同步调用『执行器函数』 executor(resolve, reject); } catch (e) { //修改 promise 对象状态为『失败』 reject(e); } } //then 方法封装 then(onResolved, onRejected) { //判断回调函数参数 if (typeof onRejected !== 'function') { onRejected = reason =&gt; { throw reason; } } if (typeof onResolved !== 'function') { onResolved = value =&gt; value; //value =&gt; { return value}; } return new Promise((resolve, reject) =&gt; { //封装函数 let callback = (type) =&gt; { try { //获取回调函数的执行结果 let result = type(this.PromiseResult); //判断 if (result instanceof Promise) { //如果是 Promise 类型的对象 result.then(v =&gt; { resolve(v); }, r =&gt; { reject(r); }) } else { //结果的对象状态为『成功』 resolve(result); } } catch (e) { reject(e); } } //调用回调函数 PromiseState if (this.PromiseState === 'fulfilled') { setTimeout(() =&gt; { callback(onResolved); }); } if (this.PromiseState === 'rejected') { setTimeout(() =&gt; { callback(onRejected); }); } //判断 pending 状态 if (this.PromiseState === 'pending') { //保存回调函数 this.callbacks.push({ onResolved: function () { callback(onResolved); }, onRejected: function () { callback(onRejected); } }); } }) } //catch 方法 catch (onRejected) { return this.then(undefined, onRejected); } //添加 resolve 方法 static resolve(value) { //返回promise对象 return new Promise((resolve, reject) =&gt; { if (value instanceof Promise) { value.then(v =&gt; { resolve(v); }, r =&gt; { reject(r); }) } else { //状态设置为成功 resolve(value); } }); } //添加 reject 方法 static reject(reason) { return new Promise((resolve, reject) =&gt; { reject(reason); }); } //添加 all 方法 static all(promises) { //返回结果为promise对象 return new Promise((resolve, reject) =&gt; { //声明变量 let count = 0; let arr = []; //遍历 for (let i = 0; i &lt; promises.length; i++) { // promises[i].then(v =&gt; { //得知对象的状态是成功 //每个promise对象 都成功 count++; //将当前promise对象成功的结果 存入到数组中 arr[i] = v; //判断 if (count === promises.length) { //修改状态 resolve(arr); } }, r =&gt; { reject(r); }); } }); } //添加 race 方法 static race(promises) { return new Promise((resolve, reject) =&gt; { for (let i = 0; i &lt; promises.length; i++) { promises[i].then(v =&gt; { //修改返回对象的状态为 『成功』 resolve(v); }, r =&gt; { //修改返回对象的状态为 『失败』 reject(r); }) } }); } &gt;} html文件调用 &gt;&lt;!DOCTYPE html&gt; &gt;&lt;html lang=\"en\"&gt; &gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;class版本封装&lt;/title&gt; &lt;script src=\"./promisedemo.js\"&gt;&lt;/script&gt; &gt;&lt;/head&gt; &gt;&lt;body&gt; &lt;script&gt; let p1 = new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { // resolve(\"OK\"); reject(\"Erosssr\"); }) }); p1.then(value =&gt; { console.log(value); }, reason =&gt; { console.warn(reason); }); console.log(Promise.resolve('OK')); &lt;/script&gt; &gt;&lt;/body&gt; &gt;&lt;/html&gt; 三、Promise+ async + await 1)Promise==&gt;异步2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 4)mdn文档 async await Ⅰ-async函数 函数的返回值为 promise 对象 promise 对象的结果由 async 函数执行的返回值决定 Ⅱ-await表达式 await 右侧的表达式一般为 promise 对象, 但也可以是其它的值 如果表达式是 promise 对象, await 返回的是 promise 成功的值 如果表达式是其它值, 直接将此值作为 await 的返回值 Ⅲ-注意 await 必须写在 async 函数中, 但 async 函数中可以没有 await 如果 await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理 Ⅳ-自己对某些问题理解解答1、如何在Promise外部使用Promise的结果 用到的本章节知识: 1、axios本质上就是一个promise,所以下面用定时器+Promise模拟axios,效果一样,可以将new Promise(resolve =&gt; {setTimeout(function() { resolve(\"promise普通结果\"); }, 1000); })等价于axios({}) 2、resolve() 与reject()是修改Promise状态并往外抛出的,一个Promise只能改变一次状态,所以一个primise中只能调用一次 3、 上一步抛出后可以在下面 的.then()中获取到 Ⅰ-如果没有用.then(),则值会抛往Promise外部 Ⅱ-如果声明了.then(),则值会被.then()接住,放到里面处理,如果需要再次抛出–某些业务场景需要 ,然后在下一个then()或者外部使用, 则可以 .then(v=&gt;return v) —前提这个链式调用前曾使用过resolve() 与reject()才用return,不然就用这两个resolve() 与reject() &gt;//讲解时写的简单demo &gt;let resolveCommon = ()=&gt; { let result=\"普通promise初始值\" result=new Promise(resolve =&gt; {setTimeout(function() { resolve(\"promise普通结果\"); }, 1000); }) console.log(result) //打印结果: Promise { &lt;pending&gt; } &gt;}; &gt;let resolveAsync=async ()=&gt; { let result=\"await+async的promise初始值\" result=await new Promise(resolve =&gt; { setTimeout(function() { resolve(\"这是async+await结果\"); }, 1000);}) console.log(result) //打印结果: 这是async+await结果 这里就是正确的值,你可以在下一步进行正常使用,也可以用在下一步的promise中 //------------------------------------------------------ //在第二个promise中调用使用 let result2=\"\" result2= await new Promise(resolve =&gt; { setTimeout(function() { resolve(result+\"+经过第二个promise加工\"); }, 1000);}) .then(v=&gt;{ console.log(\"第二个promise的then()中打印并返回:\",v) return v+\",经过then()加工返回\" }) console.log(\"最终结果:第二个promise外部结果打印,\",result2) //--------------------------------------------- &gt;}; &gt;resolveCommon() //调用普通promise函数 &gt;resolveAsync() //调用await+async &gt;/** 运行结果 1.resolveCommon() 运行结果: Promise { &lt;pending&gt; } 2.resolveAsync() 运行结果: 这是async+await结果 第二个promise的then()中打印并返回: 这是async+await结果+经过第二个promise加工 最终结果:第二个promise外部结果打印, 这是async+await结果+经过第二个promise加工,经过then()加工返回 &gt;*/ 原因解析: new Promise()是一个异步任务,会加到异步队列中,而正常运行比如console.log()是同步运行的(即从上往下运行),会加到同步队列 所以 Promise()通常是会在同一等级的同步任务之后才得到结果的 所以你得到的是一个挂起的 Promise { } 对象 而await则是让跟在后面的异步任务转为同步任务(效果如此,就通俗来讲,具体概念需要自学),所以result就能得到一个已经修改状态为成功或者失败的值 所以下面的任务就可以使用到这个值 为什么这些操作要放在同一个async fn()=&gt;{} 中? 1)Promise==&gt;异步 2)await==&gt;异步转同步 await 可以理解为是 async wait 的简写。await 必须出现在 async 函数内部，不能单独使用。 await 后面可以跟任何的JS 表达式。虽然说 await 可以等很多类型的东西，但是它最主要的意图是用来等待 Promise 对象的状态被 resolved。如果await的是 promise对象会造成异步函数停止执行并且等待 promise 的解决,如果等的是正常的表达式则立即执行 3)async==&gt;同步转异步 方法体内部的某个表达式使用await修饰，那么这个方法体所属方法必须要用async修饰所以使用awit方法会自动升级为异步方法 四、宏任务与微任务Ⅰ-说明 原理图: 说明: JS中用来存储待执行回调函数的队列包含2个不同特定的列队 宏队列:用来保存待执行的宏任务(回调),比如:定时器回调/ajax回调/dom事件回调 微队列:用来保存待执行的微任务(回调),比如:Promise的回调/muntation回调 JS执行时会区别这2个队列: JS执行引擎首先必须执行所有的初始化同步任务代码 每次准备取出第一个宏任务执行前,都要将所有的微任务一个一个取出来执行 同步任务 –&gt; 微任务 –&gt; 宏任务 Ⅱ-代码与示例 你需要一些栗子来帮助验证自己的想法是否正确,尽量先不看结果去自己思考下打印结果顺序 1、代码示例:a) 首先给出注释的栗子举一个 此处会给出每个打印放入什么队列,加深你的印象 setTimeout(() =&gt; { console.log('timeout callback1（）')//立即放入宏队列 Promise.resolve(3).then( value =&gt; { console.log('Promise onResolved3()', value)//当这个宏任务执行后 立马放入微队列,所以这个微任务执行完后下个宏任务才能执行 } ) }, 0) setTimeout(() =&gt; { console.log('timeout callback2（）') //立即放入宏队列, }, 0) Promise.resolve(1).then( value =&gt; { console.log('Promise onResolved1()', value)//立即放入微队列 setTimeout(() =&gt; { console.log('timeout callback3（）', value) //立即放入宏任务 }, 0) } ) Promise.resolve(2).then( value =&gt; { console.log('Promise onResolved2()', value)//立即放入微队列 } ) console.log('同步代码') //同步代码立即执行 结果放在下方,就怕你不小心瞄到 b) 尝试自己思考下 尝试自己脑海中用自己理解 ‘运行’ 一下, 然后把结果写下来,再去下面结果做对比 &gt;setTimeout(() =&gt; console.log('代码开始执行'),0) &gt;new Promise((resolve,reject) =&gt; { console.log('开始for循环'); for(let i=0;i&lt;10000;i++){ i == 99 &amp;&amp; resolve() } &gt;}).then(() =&gt; console.log('执行then函数')) &gt;console.log('代码执行结束'); 2、示例结果:a) 第一个栗子的结果 '同步代码', 'Promise onResolved1()', 'Promise onResolved2()', 'timeout callback1（）', 'Promise onResolved3()', 'timeout callback2（）', 'timeout callback3（）' b) 第二个栗子的结果 PS: 可以忽略undefined这个打印结果, 因为这会加重我们对于宏任务与微任务的理解负担. 当然人都是会好奇的,没有打破砂锅问到底的精神呢也当不了一个好程序员,那我就在下方额外给出解释 五、对浏览器console控制台输出undefined的分析Ⅰ- 出现场景 Ⅱ - 尝试输入其他内容进行分析 那么做个合理推测: 应该是在控制台输入的内容,它的 返回值 会显示出来,这让我们不禁想到JS的 [ eval() ] Ⅲ - eval（string） 其作用是将 接收的 string 字符串作为参数，对其进行JavaScript 表达式或语句 计算，返回得到的值； 如果是没有返回值的表达式或语句，则会返回 undefined ； 如果没有合法的表达式和语句，则会抛出 SyntaxError 异常 。 于是我们可以猜测Console控制台的实质 就是 调用了eval（）函数 Ⅳ - 验证一下 大家都是聪明人,看到这个结果应该就不用我组织语言来解释了吧 Ⅴ - 分析其在宏任务与微任务的打印顺序 首先看图: 可以看到 [ undefined ] 实在微任务完成后,宏任务执行前 打印","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://serein.icu/categories/JavaScript/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"https://serein.icu/tags/Promise/"}]},{"title":"ES6学习笔记","slug":"PDF01","date":"2022-03-18T13:00:00.000Z","updated":"2022-03-19T02:49:58.947Z","comments":true,"path":"posts/5.html","link":"","permalink":"https://serein.icu/posts/5.html","excerpt":"","text":"简介ES6， 全称 ECMAScript 6.0 ，是 JavaScript 的下一个版本标准，2015.06 发版。 主要是为了解决 ES5 的先天不足，比如 JavaScript 里并没有类的概念，但是目前浏览器的 JavaScript 是 ES5 版本，大多数高版本的浏览器也支持 ES6，不过只实现了 ES6 的部分特性和功能。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://serein.icu/categories/JavaScript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://serein.icu/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://serein.icu/tags/ES6/"}]},{"title":"Vue3快速上手","slug":"04-Vue3快速上手","date":"2022-03-14T06:00:00.000Z","updated":"2022-03-16T09:38:53.675Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://serein.icu/posts/4.html","excerpt":"","text":"Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 2.Vue3带来了什么1.性能的提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54% …… 2.源码的升级 使用Proxy代替defineProperty实现响应式 重写虚拟DOM的实现和Tree-Shaking …… 3.拥抱TypeScript Vue3可以更好的支持TypeScript 4.新的特性 Composition API（组合API） setup配置 ref与reactive watch与watchEffect provide与inject …… 新的内置组件 Fragment Teleport Suspense 其他改变 新的生命周期钩子 data 选项应始终被声明为一个函数 移除keyCode支持作为 v-on 的修饰符 …… 创建Vue3.0工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create ## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 创建 vue create vue_test ## 启动 cd vue_test npm run serve 2.使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite？—— 新一代前端构建工具。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载（HMR）。 真正的按需编译，不再等待整个应用编译完成。 传统构建 与 vite构建对比图 ## 创建工程 npm init vite-app &lt;project-name&gt; ## 进入工程目录 cd &lt;project-name&gt; ## 安装依赖 npm install ## 运行 npm run dev 常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html 1.拉开序幕的setup 理解：Vue3.0中一个新的配置项，值为一个函数。 setup是所有Composition API（组合API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解） 注意点： 尽量不要与Vue2.x配置混用 Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。 但在setup中不能访问到Vue2.x配置（data、methos、computed…）。 如果有重名, setup优先。 setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） 2.ref函数 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。 JS中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;{{xxx}}&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。 3.reactive函数 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） reactive定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 4.Vue3.0中的响应式原理vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 Object.defineProperty(data, 'count', { get () {}, set () {} }) 存在问题： 新增属性、删除属性, 界面不会更新。 直接通过下标修改数组, 界面不会自动更新。 Vue3.0的响应式 实现原理: 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 通过Reflect（反射）: 对源对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect new Proxy(data, { // 拦截读取属性值 get (target, prop) { return Reflect.get(target, prop) }, // 拦截设置属性值或添加新属性 set (target, prop, value) { return Reflect.set(target, prop, value) }, // 拦截删除属性 deleteProperty (target, prop) { return Reflect.deleteProperty(target, prop) } }) proxy.name = 'tom' 5.reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 6.setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。 slots: 收到的插槽内容, 相当于 this.$slots。 emit: 分发自定义事件的函数, 相当于 this.$emit。 7.计算属性与监视1.computed函数 与Vue2.x中computed配置功能一致 写法 import {computed} from 'vue' setup(){ ... //计算属性——简写 let fullName = computed(()=&gt;{ return person.firstName + '-' + person.lastName }) //计算属性——完整 let fullName = computed({ get(){ return person.firstName + '-' + person.lastName }, set(value){ const nameArr = value.split('-') person.firstName = nameArr[0] person.lastName = nameArr[1] } }) } 2.watch函数 与Vue2.x中watch配置功能一致 两个小“坑”： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 //情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=&gt;{ console.log('sum变化了',newValue,oldValue) },{immediate:true}) //情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=&gt;{ console.log('sum或msg变化了',newValue,oldValue) }) /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */ watch(person,(newValue,oldValue)=&gt;{ console.log('person变化了',newValue,oldValue) },{immediate:true,deep:false}) //此处的deep配置不再奏效 //情况四：监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.job,(newValue,oldValue)=&gt;{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //情况五：监视reactive定义的响应式数据中的某些属性 watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //特殊情况 watch(()=&gt;person.job,(newValue,oldValue)=&gt;{ console.log('person的job变化了',newValue,oldValue) },{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 3.watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。 //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(()=&gt;{ const x1 = sum.value const x2 = person.age console.log('watchEffect配置的回调执行了') }) 8.生命周期 Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名： beforeDestroy改名为 beforeUnmount destroyed改名为 unmounted Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下： beforeCreate===&gt;setup() created=======&gt;setup() beforeMount ===&gt;onBeforeMount mounted=======&gt;onMounted beforeUpdate===&gt;onBeforeUpdate updated =======&gt;onUpdated beforeUnmount&nbsp;==&gt;onBeforeUnmount unmounted =====&gt;onUnmounted 9.自定义hook函数 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。 10.toRef 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。 语法：const name = toRef(person,'name') 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person) 其它 Composition API1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。 2.readonly 与 shallowReadonly readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据被修改时。 3.toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： &lt;template&gt; &lt;input type=\"text\" v-model=\"keyword\"&gt; &lt;h3&gt;{{keyword}}&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; import {ref,customRef} from 'vue' export default { name:'Demo', setup(){ // let keyword = ref('hello') //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay){ let timer //通过customRef去实现自定义 return customRef((track,trigger)=&gt;{ return{ get(){ track() //告诉Vue这个value值是需要被“追踪”的 return value }, set(newValue){ clearTimeout(timer) timer = setTimeout(()=&gt;{ value = newValue trigger() //告诉Vue去更新界面 },delay) } } }) } let keyword = myRef('hello',500) //使用程序员自定义的ref return { keyword } } } &lt;/script&gt; 5.provide 与 inject 作用：实现祖与后代组件间通信 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中： setup(){ ...... let car = reactive({name:'奔驰',price:'40万'}) provide('car',car) ...... } 后代组件中： setup(props,context){ ...... const car = inject('car') return {car} ...... } 6.响应式数据的判断 isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 Composition API 的优势1.Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 新的组件1.Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 2.Teleport 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 &lt;teleport to=\"移动位置\"&gt; &lt;div v-if=\"isShow\" class=\"mask\"&gt; &lt;div class=\"dialog\"&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;button @click=\"isShow = false\"&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt; 3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 import {defineAsyncComponent} from 'vue' const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue')) 使用Suspense包裹组件，并配置好default 与 fallback &lt;template&gt; &lt;div class=\"app\"&gt; &lt;h3&gt;我是App组件&lt;/h3&gt; &lt;Suspense&gt; &lt;template v-slot:default&gt; &lt;Child/&gt; &lt;/template&gt; &lt;template v-slot:fallback&gt; &lt;h3&gt;加载中.....&lt;/h3&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;/template&gt; 其他1.全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 //注册全局组件 Vue.component('MyButton', { data: () =&gt; ({ count: 0 }), template: '&lt;button @click=\"count++\"&gt;Clicked {{ count }} times.&lt;/button&gt;' }) //注册全局指令 Vue.directive('focus', { inserted: el =&gt; el.focus() } Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 .v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; } Vue3.x写法 .v-enter-from, .v-leave-to { opacity: 0; } .v-leave-from, .v-enter-to { opacity: 1; } 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 &lt;my-component v-on:close=\"handleComponentEvent\" v-on:click=\"handleNativeClickEvent\" /&gt; 子组件中声明自定义事件 &lt;script&gt; export default { emits: ['close'] } &lt;/script&gt; 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 ……","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"}]},{"title":"Vue2进阶知识","slug":"03-Vue2进阶知识","date":"2022-03-14T04:00:00.000Z","updated":"2022-03-29T03:28:16.642Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://serein.icu/posts/3.html","excerpt":"","text":"进阶知识篇脚手架文件结构 ├── node_modules ├── public │ ├── favicon.ico: 页签图标 │ └── index.html: 主页面 ├── src │ ├── assets: 存放静态资源 │ │ └── logo.png │ │── component: 存放组件 │ │ └── HelloWorld.vue │ │── App.vue: 汇总所有组件 │ │── main.js: 入口文件 ├── .gitignore: git版本管制忽略的配置 ├── babel.config.js: babel的配置文件 ├── package.json: 应用包配置文件 ├── README.md: 应用描述文件 ├── package-lock.json：包版本控制文件 关于不同版本的Vue vue.js与vue.runtime.xxx.js的区别： vue.js是完整版的Vue，包含：核心功能 + 模板解析器。 vue.runtime.xxx.js是运行版的Vue，只包含：核心功能；没有模板解析器。 因为vue.runtime.xxx.js没有模板解析器，所以不能使用template这个配置项，需要使用render函数接收到的createElement函数去指定具体内容。 vue.config.js配置文件 使用vue inspect &gt; output.js可以查看到Vue脚手架的默认配置。 使用vue.config.js可以对脚手架进行个性化定制，详情见：https://cli.vuejs.org/zh ref属性 被用来给元素或子组件注册引用信息（id的替代者） 应用在html标签上获取的是真实DOM元素，应用在组件标签上是组件实例对象（vc） 使用方式： 打标识：&lt;h1 ref=\"xxx\"&gt;.....&lt;/h1&gt; 或 &lt;School ref=\"xxx\"&gt;&lt;/School&gt; 获取：this.$refs.xxx props配置项 功能：让组件接收外部传过来的数据 传递数据：&lt;Demo name=\"xxx\"/&gt; 接收数据： 第一种方式（只接收）：props:['name'] 第二种方式（限制类型）：props:{name:String} 第三种方式（限制类型、限制必要性、指定默认值）： props:{ name:{ type:String, //类型 required:true, //必要性 default:'老王' //默认值 } } 备注：props是只读的，Vue底层会监测你对props的修改，如果进行了修改，就会发出警告，若业务需求确实需要修改，那么请复制props的内容到data中一份，然后去修改data中的数据。 mixin(混入) 功能：可以把多个组件共用的配置提取成一个混入对象 使用方式： 第一步定义混合： { data(){....}, methods:{....} .... } 第二步使用混入： ​ 全局混入：Vue.mixin(xxx) ​ 局部混入：mixins:['xxx'] 插件 功能：用于增强Vue 本质：包含install方法的一个对象，install的第一个参数是Vue，第二个以后的参数是插件使用者传递的数据。 定义插件： 对象.install = function (Vue, options) { // 1. 添加全局过滤器 Vue.filter(....) // 2. 添加全局指令 Vue.directive(....) // 3. 配置全局混入(合) Vue.mixin(....) // 4. 添加实例方法 Vue.prototype.$myMethod = function () {...} Vue.prototype.$myProperty = xxxx } 使用插件：Vue.use() scoped样式 作用：让样式在局部生效，防止冲突。 写法：&lt;style scoped&gt; 总结TodoList案例 组件化编码流程： ​ (1).拆分静态组件：组件要按照功能点拆分，命名不要与html元素冲突。 ​ (2).实现动态组件：考虑好数据的存放位置，数据是一个组件在用，还是一些组件在用： ​ 1).一个组件在用：放在组件自身即可。 ​ 2). 一些组件在用：放在他们共同的父组件上（状态提升）。 ​ (3).实现交互：从绑定事件开始。 props适用于： ​ (1).父组件 ==&gt; 子组件 通信 ​ (2).子组件 ==&gt; 父组件 通信（要求父先给子一个函数） 使用v-model时要切记：v-model绑定的值不能是props传过来的值，因为props是不可以修改的！ props传过来的若是对象类型的值，修改对象中的属性时Vue不会报错，但不推荐这样做。 webStorage 存储内容大小一般支持5MB左右（不同浏览器可能还不一样） 浏览器端通过 Window.sessionStorage 和 Window.localStorage 属性来实现本地存储机制。 相关API： xxxxxStorage.setItem('key', 'value'); 该方法接受一个键和值作为参数，会把键值对添加到存储中，如果键名存在，则更新其对应的值。 xxxxxStorage.getItem('person'); ​ 该方法接受一个键名作为参数，返回键名对应的值。 xxxxxStorage.removeItem('key'); ​ 该方法接受一个键名作为参数，并把该键名从存储中删除。 xxxxxStorage.clear() ​ 该方法会清空存储中的所有数据。 备注： SessionStorage存储的内容会随着浏览器窗口关闭而消失。 LocalStorage存储的内容，需要手动清除才会消失。 xxxxxStorage.getItem(xxx)如果xxx对应的value获取不到，那么getItem的返回值是null。 JSON.parse(null)的结果依然是null。 组件的自定义事件 一种组件间通信的方式，适用于：子组件 ===&gt; 父组件 使用场景：A是父组件，B是子组件，B想给A传数据，那么就要在A中给B绑定自定义事件（事件的回调在A中）。 绑定自定义事件： 第一种方式，在父组件中：&lt;Demo @atguigu=\"test\"/&gt; 或 &lt;Demo v-on:atguigu=\"test\"/&gt; 第二种方式，在父组件中： &lt;Demo ref=\"demo\"/&gt; ...... mounted(){ this.$refs.xxx.$on('atguigu',this.test) } 若想让自定义事件只能触发一次，可以使用once修饰符，或$once方法。 触发自定义事件：this.$emit('atguigu',数据) 解绑自定义事件this.$off('atguigu') 组件上也可以绑定原生DOM事件，需要使用native修饰符。 注意：通过this.$refs.xxx.$on('atguigu',回调)绑定自定义事件时，回调要么配置在methods中，要么用箭头函数，否则this指向会出问题！ 全局事件总线（GlobalEventBus） 一种组件间通信的方式，适用于任意组件间通信。 安装全局事件总线： new Vue({ ...... beforeCreate() { Vue.prototype.$bus = this //安装全局事件总线，$bus就是当前应用的vm }, ...... }) 使用事件总线： 接收数据：A组件想接收数据，则在A组件中给$bus绑定自定义事件，事件的回调留在A组件自身。 methods(){ demo(data){......} } ...... mounted() { this.$bus.$on('xxxx',this.demo) } 提供数据：this.$bus.$emit('xxxx',数据) 最好在beforeDestroy钩子中，用$off去解绑当前组件所用到的事件。 消息订阅与发布（pubsub） 一种组件间通信的方式，适用于任意组件间通信。 使用步骤： 安装pubsub：npm i pubsub-js 引入: import pubsub from 'pubsub-js' 接收数据：A组件想接收数据，则在A组件中订阅消息，订阅的回调留在A组件自身。 methods(){ demo(data){......} } ...... mounted() { this.pid = pubsub.subscribe('xxx',this.demo) //订阅消息 } 提供数据：pubsub.publish('xxx',数据) 最好在beforeDestroy钩子中，用PubSub.unsubscribe(pid)去取消订阅。 nextTick 语法：this.$nextTick(回调函数) 作用：在下一次 DOM 更新结束后执行其指定的回调。 什么时候用：当改变数据后，要基于更新后的新DOM进行某些操作时，要在nextTick所指定的回调函数中执行。 Vue封装的过度与动画 作用：在插入、更新或移除 DOM元素时，在合适的时候给元素添加样式类名。 图示： 写法： 准备好样式： 元素进入的样式： v-enter：进入的起点 v-enter-active：进入过程中 v-enter-to：进入的终点 元素离开的样式： v-leave：离开的起点 v-leave-active：离开过程中 v-leave-to：离开的终点 使用&lt;transition&gt;包裹要过度的元素，并配置name属性： &lt;transition name=\"hello\"&gt; &lt;h1 v-show=\"isShow\"&gt;你好啊！&lt;/h1&gt; &lt;/transition&gt; 备注：若有多个元素需要过度，则需要使用：&lt;transition-group&gt;，且每个元素都要指定key值。 vue脚手架配置代理方法一​ 在vue.config.js中添加如下配置： devServer:{ proxy:\"http://localhost:5000\" } 说明： 优点：配置简单，请求资源时直接发给前端（8080）即可。 缺点：不能配置多个代理，不能灵活的控制请求是否走代理。 工作方式：若按照上述配置代理，当请求了前端不存在的资源时，那么该请求会转发给服务器 （优先匹配前端资源） 方法二​ 编写vue.config.js配置具体代理规则： module.exports = { devServer: { proxy: { '/api1': {// 匹配所有以 '/api1'开头的请求路径 target: 'http://localhost:5000',// 代理目标的基础路径 changeOrigin: true, pathRewrite: {'^/api1': ''} }, '/api2': {// 匹配所有以 '/api2'开头的请求路径 target: 'http://localhost:5001',// 代理目标的基础路径 changeOrigin: true, pathRewrite: {'^/api2': ''} } } } } /* changeOrigin设置为true时，服务器收到的请求头中的host为：localhost:5000 changeOrigin设置为false时，服务器收到的请求头中的host为：localhost:8080 changeOrigin默认值为true */ 说明： 优点：可以配置多个代理，且可以灵活的控制请求是否走代理。 缺点：配置略微繁琐，请求资源时必须加前缀。 插槽 作用：让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于 父组件 ===&gt; 子组件 。 分类：默认插槽、具名插槽、作用域插槽 使用方式： 默认插槽： 父组件中： &lt;Category&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/Category&gt; 子组件中： &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 具名插槽： 父组件中： &lt;Category&gt; &lt;template slot=\"center\"&gt; &lt;div&gt;html结构1&lt;/div&gt; &lt;/template&gt; &lt;template v-slot:footer&gt; &lt;div&gt;html结构2&lt;/div&gt; &lt;/template&gt; &lt;/Category&gt; 子组件中： &lt;template&gt; &lt;div&gt; &lt;!-- 定义插槽 --&gt; &lt;slot name=\"center\"&gt;插槽默认内容...&lt;/slot&gt; &lt;slot name=\"footer\"&gt;插槽默认内容...&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; 作用域插槽： 理解：数据在组件的自身，但根据数据生成的结构需要组件的使用者来决定。（games数据在Category组件中，但使用数据所遍历出来的结构由App组件决定） 具体编码： 父组件中： &lt;Category&gt; &lt;template scope=\"scopeData\"&gt; &lt;!-- 生成的是ul列表 --&gt; &lt;ul&gt; &lt;li v-for=\"g in scopeData.games\" :key=\"g\"&gt;{{g}}&lt;/li&gt; &lt;/ul&gt; &lt;/template&gt; &lt;/Category&gt; &lt;Category&gt; &lt;template slot-scope=\"scopeData\"&gt; &lt;!-- 生成的是h4标题 --&gt; &lt;h4 v-for=\"g in scopeData.games\" :key=\"g\"&gt;{{g}}&lt;/h4&gt; &lt;/template&gt; &lt;/Category&gt; 子组件中： &lt;template&gt; &lt;div&gt; &lt;slot :games=\"games\"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Category', props:['title'], //数据在子组件自身 data() { return { games:['红色警戒','穿越火线','劲舞团','超级玛丽'] } }, } &lt;/script&gt; Vuex1.概念​ 在Vue中实现集中式状态（数据）管理的一个Vue插件，对vue应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。 2.何时使用？​ 多个组件需要共享数据时 3.搭建vuex环境 创建文件：src/store/index.js //引入Vue核心库 import Vue from 'vue' //引入Vuex import Vuex from 'vuex' //应用Vuex插件 Vue.use(Vuex) //准备actions对象——响应组件中用户的动作 const actions = {} //准备mutations对象——修改state中的数据 const mutations = {} //准备state对象——保存具体的数据 const state = {} //创建并暴露store export default new Vuex.Store({ actions, mutations, state }) 在main.js中创建vm时传入store配置项 ...... //引入store import store from './store' ...... //创建vm new Vue({ el:'#app', render: h =&gt; h(App), store }) 4.基本使用 初始化数据、配置actions、配置mutations，操作文件store.js //引入Vue核心库 import Vue from 'vue' //引入Vuex import Vuex from 'vuex' //引用Vuex Vue.use(Vuex) const actions = { //响应组件中加的动作 jia(context,value){ // console.log('actions中的jia被调用了',miniStore,value) context.commit('JIA',value) }, } const mutations = { //执行加 JIA(state,value){ // console.log('mutations中的JIA被调用了',state,value) state.sum += value } } //初始化数据 const state = { sum:0 } //创建并暴露store export default new Vuex.Store({ actions, mutations, state, }) 组件中读取vuex中的数据：$store.state.sum 组件中修改vuex中的数据：$store.dispatch('action中的方法名',数据) 或 $store.commit('mutations中的方法名',数据) 备注：若没有网络请求或其他业务逻辑，组件中也可以越过actions，即不写dispatch，直接编写commit 5.getters的使用 概念：当state中的数据需要经过加工后再使用时，可以使用getters加工。 在store.js中追加getters配置 ...... const getters = { bigSum(state){ return state.sum * 10 } } //创建并暴露store export default new Vuex.Store({ ...... getters }) 组件中读取数据：$store.getters.bigSum 6.四个map方法的使用 mapState方法：用于帮助我们映射state中的数据为计算属性 computed: { //借助mapState生成计算属性：sum、school、subject（对象写法） ...mapState({sum:'sum',school:'school',subject:'subject'}), //借助mapState生成计算属性：sum、school、subject（数组写法） ...mapState(['sum','school','subject']), }, mapGetters方法：用于帮助我们映射getters中的数据为计算属性 computed: { //借助mapGetters生成计算属性：bigSum（对象写法） ...mapGetters({bigSum:'bigSum'}), //借助mapGetters生成计算属性：bigSum（数组写法） ...mapGetters(['bigSum']) }, mapActions方法：用于帮助我们生成与actions对话的方法，即：包含$store.dispatch(xxx)的函数 methods:{ //靠mapActions生成：incrementOdd、incrementWait（对象形式） ...mapActions({incrementOdd:'jiaOdd',incrementWait:'jiaWait'}) //靠mapActions生成：incrementOdd、incrementWait（数组形式） ...mapActions(['jiaOdd','jiaWait']) } mapMutations方法：用于帮助我们生成与mutations对话的方法，即：包含$store.commit(xxx)的函数 methods:{ //靠mapActions生成：increment、decrement（对象形式） ...mapMutations({increment:'JIA',decrement:'JIAN'}), //靠mapMutations生成：JIA、JIAN（对象形式） ...mapMutations(['JIA','JIAN']), } 备注：mapActions与mapMutations使用时，若需要传递参数需要：在模板中绑定事件时传递好参数，否则参数是事件对象。 7.模块化+命名空间 目的：让代码更好维护，让多种数据分类更加明确。 修改store.js const countAbout = { namespaced:true,//开启命名空间 state:{x:1}, mutations: { ... }, actions: { ... }, getters: { bigSum(state){ return state.sum * 10 } } } const personAbout = { namespaced:true,//开启命名空间 state:{ ... }, mutations: { ... }, actions: { ... } } const store = new Vuex.Store({ modules: { countAbout, personAbout } }) 开启命名空间后，组件中读取state数据： //方式一：自己直接读取 this.$store.state.personAbout.list //方式二：借助mapState读取： ...mapState('countAbout',['sum','school','subject']), 开启命名空间后，组件中读取getters数据： //方式一：自己直接读取 this.$store.getters['personAbout/firstPersonName'] //方式二：借助mapGetters读取： ...mapGetters('countAbout',['bigSum']) 开启命名空间后，组件中调用dispatch //方式一：自己直接dispatch this.$store.dispatch('personAbout/addPersonWang',person) //方式二：借助mapActions： ...mapActions('countAbout',{incrementOdd:'jiaOdd',incrementWait:'jiaWait'}) 开启命名空间后，组件中调用commit //方式一：自己直接commit this.$store.commit('personAbout/ADD_PERSON',person) //方式二：借助mapMutations： ...mapMutations('countAbout',{increment:'JIA',decrement:'JIAN'}), 路由 理解： 一个路由（route）就是一组映射关系（key - value），多个路由需要路由器（router）进行管理。 前端路由：key是路径，value是组件。 1.基本使用 安装vue-router，命令：npm i vue-router 应用插件：Vue.use(VueRouter) 编写router配置项: //引入VueRouter import VueRouter from 'vue-router' //引入Luyou 组件 import About from '../components/About' import Home from '../components/Home' //创建router实例对象，去管理一组一组的路由规则 const router = new VueRouter({ routes:[ { path:'/about', component:About }, { path:'/home', component:Home } ] }) //暴露router export default router 实现切换（active-class可配置高亮样式） &lt;router-link active-class=\"active\" to=\"/about\"&gt;About&lt;/router-link&gt; 指定展示位置 &lt;router-view&gt;&lt;/router-view&gt; 2.几个注意点 路由组件通常存放在views或pages文件夹，一般组件通常存放在components文件夹。 通过切换，“隐藏”了的路由组件，默认是被销毁掉的，需要的时候再去挂载。 每个组件都有自己的$route属性，里面存储着自己的路由信息。 整个应用只有一个router，可以通过组件的$router属性获取到。 3.多级路由（多级路由） 配置路由规则，使用children配置项： routes:[ { path:'/about', component:About, }, { path:'/home', component:Home, children:[ //通过children配置子级路由 { path:'news', //此处一定不要写：/news component:News }, { path:'message',//此处一定不要写：/message component:Message } ] } ] 跳转（要写完整路径）： &lt;router-link to=\"/home/news\"&gt;News&lt;/router-link&gt; 4.路由的query参数 传递参数 &lt;!-- 跳转并携带query参数，to的字符串写法 --&gt; &lt;router-link :to=\"/home/message/detail?id=666&amp;title=你好\"&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带query参数，to的对象写法 --&gt; &lt;router-link :to=\"{ path:'/home/message/detail', query:{ id:666, title:'你好' } }\" &gt;跳转&lt;/router-link&gt; 接收参数： $route.query.id $route.query.title 5.命名路由 作用：可以简化路由的跳转。 如何使用 给路由命名： { path:'/demo', component:Demo, children:[ { path:'test', component:Test, children:[ { name:'hello' //给路由命名 path:'welcome', component:Hello, } ] } ] } 简化跳转： &lt;!--简化前，需要写完整的路径 --&gt; &lt;router-link to=\"/demo/test/welcome\"&gt;跳转&lt;/router-link&gt; &lt;!--简化后，直接通过名字跳转 --&gt; &lt;router-link :to=\"{name:'hello'}\"&gt;跳转&lt;/router-link&gt; &lt;!--简化写法配合传递参数 --&gt; &lt;router-link :to=\"{ name:'hello', query:{ id:666, title:'你好' } }\" &gt;跳转&lt;/router-link&gt; 6.路由的params参数 配置路由，声明接收params参数 { path:'/home', component:Home, children:[ { path:'news', component:News }, { component:Message, children:[ { name:'xiangqing', path:'detail/:id/:title', //使用占位符声明接收params参数 component:Detail } ] } ] } 传递参数 &lt;!-- 跳转并携带params参数，to的字符串写法 --&gt; &lt;router-link :to=\"/home/message/detail/666/你好\"&gt;跳转&lt;/router-link&gt; &lt;!-- 跳转并携带params参数，to的对象写法 --&gt; &lt;router-link :to=\"{ name:'xiangqing', params:{ id:666, title:'你好' } }\" &gt;跳转&lt;/router-link&gt; 特别注意：路由携带params参数时，若使用to的对象写法，则不能使用path配置项，必须使用name配置！ 接收参数： $route.params.id $route.params.title 7.路由的props配置​ 作用：让路由组件更方便的收到参数 { name:'xiangqing', path:'detail/:id', component:Detail, //第一种写法：props值为对象，该对象中所有的key-value的组合最终都会通过props传给Detail组件 // props:{a:900} //第二种写法：props值为布尔值，布尔值为true，则把路由收到的所有params参数通过props传给Detail组件 // props:true //第三种写法：props值为函数，该函数返回的对象中每一组key-value都会通过props传给Detail组件 props(route){ return { id:route.query.id, title:route.query.title } } } 8.&lt;router-link&gt;的replace属性 作用：控制路由跳转时操作浏览器历史记录的模式 浏览器的历史记录有两种写入方式：分别为push和replace，push是追加历史记录，replace是替换当前记录。路由跳转时候默认为push 如何开启replace模式：&lt;router-link replace .......&gt;News&lt;/router-link&gt; 9.编程式路由导航 作用：不借助&lt;router-link&gt; 实现路由跳转，让路由跳转更加灵活 具体编码： //$router的两个API this.$router.push({ name:'xiangqing', params:{ id:xxx, title:xxx } }) this.$router.replace({ name:'xiangqing', params:{ id:xxx, title:xxx } }) this.$router.forward() //前进 this.$router.back() //后退 this.$router.go() //可前进也可后退 10.缓存路由组件 作用：让不展示的路由组件保持挂载，不被销毁。 具体编码： &lt;keep-alive include=\"News\"&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/keep-alive&gt; 11.两个新的生命周期钩子 作用：路由组件所独有的两个钩子，用于捕获路由组件的激活状态。 具体名字： activated路由组件被激活时触发。 deactivated路由组件失活时触发。 12.路由守卫 作用：对路由进行权限控制 分类：全局守卫、独享守卫、组件内守卫 全局守卫: //全局前置守卫：初始化时执行、每次路由切换前执行 router.beforeEach((to,from,next)=&gt;{ console.log('beforeEach',to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制 if(localStorage.getItem('school') === 'atguigu'){ //权限控制的具体规则 next() //放行 }else{ alert('暂无权限查看') // next({name:'guanyu'}) } }else{ next() //放行 } }) //全局后置守卫：初始化时执行、每次路由切换后执行 router.afterEach((to,from)=&gt;{ console.log('afterEach',to,from) if(to.meta.title){ document.title = to.meta.title //修改网页的title }else{ document.title = 'vue_test' } }) 独享守卫: beforeEnter(to,from,next){ console.log('beforeEnter',to,from) if(to.meta.isAuth){ //判断当前路由是否需要进行权限控制 if(localStorage.getItem('school') === 'atguigu'){ next() }else{ alert('暂无权限查看') // next({name:'guanyu'}) } }else{ next() } } 组件内守卫： //进入守卫：通过路由规则，进入该组件时被调用 beforeRouteEnter (to, from, next) { }, //离开守卫：通过路由规则，离开该组件时被调用 beforeRouteLeave (to, from, next) { } 13.路由器的两种工作模式 对于一个url来说，什么是hash值？—— #及其后面的内容就是hash值。 hash值不会包含在 HTTP 请求中，即：hash值不会带给服务器。 hash模式： 地址中永远带着#号，不美观 。 若以后将地址通过第三方手机app分享，若app校验严格，则地址会被标记为不合法。 兼容性较好。 history模式： 地址干净，美观 。 兼容性和hash模式相比略差。 应用部署上线时需要后端人员支持，解决刷新页面服务端404的问题。","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"}]},{"title":"Vue2基础知识","slug":"02-Vue2基础知识","date":"2022-03-14T01:00:00.000Z","updated":"2022-03-14T02:38:12.449Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://serein.icu/posts/2.html","excerpt":"","text":"基础知识篇初识Vue 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象； root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法； root容器里的代码被称为【Vue模板】； Vue实例和容器是一一对应的； 真实开发中只有一个Vue实例，并且会配合着组件一起使用； 中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性； 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新； 注意区分：js表达式 和 js代码(语句) 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方： a a+b demo(1) x === y ? 'a' : 'b' js代码(语句) if(){} for(){} Vue模板语法Vue模板语法有两大类： 插值语法： 功能：用于解析标签体内容。 写法：，xxx是js表达式，且可以直接读取到data中的所有属性。 指令语法： 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。 举例：v-bind:href=”xxx” 或 简写为 :href=”xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性。 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。 &lt;!-- 准备好一个容器--&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，{{name}}&lt;/h3&gt; &lt;hr/&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=\"school.url.toUpperCase()\" x=\"hello\"&gt;点我去{{school.name}}学习1&lt;/a&gt; &lt;a :href=\"school.url\" x=\"hello\"&gt;点我去{{school.name}}学习2&lt;/a&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'Serein', school:{ name:\"Serein'blog\", url:'https://www.serein.icu', } } }) &lt;/script&gt; 数据绑定Vue中有2种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面。 双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。 备注：1. 双向绑定一般都应用在表单类元素上（如：input、select等）2. v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。 &lt;div id=\"root\"&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt;&lt;br/&gt; --&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=\"text\" :value=\"name\"&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=\"text\" v-model=\"name\"&gt;&lt;br/&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=\"name\"&gt;你好啊&lt;/h2&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'Serein' } }) &lt;/script&gt; el与data的两种写法1. el有2种写法： new Vue时候配置el属性。 先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。 2. data有2种写法： 对象式 函数式 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。 3. 一个重要的原则： 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。 &lt;div id=\"root\"&gt; &lt;h1&gt;你好，{{name}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //el的两种写法 const v = new Vue({ //el:'#root', //第一种写法 data:{ name:'Serein' } }) console.log(v) v.$mount('#root') //第二种写法 //data的两种写法 new Vue({ el:'#root', //data的第一种写法：对象式 data:{ name:'Serein' } //data的第二种写法：函数式 data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'Serein' } } }) &lt;/script&gt; MVVM模型1. M：模型(Model) ：data中的数据 2. V：视图(View) ：模板代码 3. VM：视图模型(ViewModel)：Vue实例 观察发现： - data中所有的属性，最后都出现在了vm身上。 - vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。 &lt;div id=\"root\"&gt; &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt; &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt; &lt;h1&gt;测试一下1：{{1+1}}&lt;/h1&gt; &lt;h1&gt;测试一下2：{{$options}}&lt;/h1&gt; &lt;h1&gt;测试一下3：{{$emit}}&lt;/h1&gt; &lt;h1&gt;测试一下4：{{_c}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 const vm = new Vue({ el:'#root', data:{ name:'Serein', address:\"Serein's blog\", } }) console.log(vm) &lt;/script&gt; 数据代理1. 回顾Object.defineProperty&lt;script type=\"text/javascript\" &gt; let number = 18 let person = { name:'张三', sex:'男', } Object.defineProperty(person,'age',{ // value:18, enumerable:true, //控制属性是否可以枚举，默认值是false writable:true, //控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get(){ console.log('有人读取age属性了') return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value){ console.log('有人修改了age属性，且值是',value) number = value } }) console.log(Object.keys(person)) //枚举person对象属性 console.log(person) &lt;/script&gt; 2. 何为数据代理&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt; &lt;script type=\"text/javascript\" &gt; let obj = {x:100} let obj2 = {y:200} Object.defineProperty(obj2,'x',{ get(){ return obj.x }, set(value){ obj.x = value } }) &lt;/script&gt; 3.Vue中的数据代理1. Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写） 2. Vue中数据代理的好处：更加方便的操作data中的数据 3. 基本原理：通过Object.defineProperty()把data对象中所有属性添加到vm上。为每一个添加到vm上的属性，都指定一个getter/setter。在getter/setter内部去操作（读/写）data中对应的属性。 &lt;div id=\"root\"&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', address:\"Serein's blog\" } }) &lt;/script&gt; 事件处理1. 事件的基本使用 使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名； 事件的回调需要配置在methods对象中，最终会在vm上； methods中配置的函数，不要用箭头函数！否则this就不是vm了； methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象； @click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参； &lt;div id=\"root\"&gt; &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt; &lt;!-- &lt;button v-on:click=\"showInfo\"&gt;点我提示信息&lt;/button&gt; --&gt; &lt;button @click=\"showInfo1\"&gt;点我提示信息1（不传参）&lt;/button&gt; &lt;button @click=\"showInfo2($event,66)\"&gt;点我提示信息2（传参）&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', }, methods:{ showInfo1(event){ console.log(event.target.innerText) //获取按钮的文字数据 console.log(this) //此处的this是vm alert('同学你好！') }, showInfo2(event,number){ console.log(event,number) console.log(event.target.innerText) console.log(this) //此处的this是vm alert('同学你好！！') } } }) &lt;/script&gt; 2. 事件修饰符 prevent：阻止默认事件（常用）； stop：阻止事件冒泡（常用）； once：事件只触发一次（常用）； capture：使用事件的捕获模式； self：只有event.target是当前操作的元素时才触发事件； passive：事件的默认行为立即执行，无需等待事件回调执行完毕；（一般移动端使用它） 注意：passive和prevent冲突，不能同时绑定在一个监听器上。 事件冒泡： 即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点 理解：想象气泡从水底开始往上升，由深到浅，升到最上面。在上升的过程中，气泡会经过不同深度层次的水。 相对应地：这个气泡就相当于我们这里的事件，而水则相当于我们的整个dom树；事件从dom 树的底层 层层往上传递，直至传递到dom的根节点。 事件捕获： 与事件冒泡完全相反 网景公司提出的事件流叫事件捕获流 事件捕获流的思想是不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件 懵懵懂懂的小伙伴，请看图解: &lt;div id=\"root\"&gt; &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt; &lt;!-- 阻止默认事件（常用） --&gt; &lt;a href=\"https://www.serein.icu/\" @click.prevent=\"showInfo\"&gt;点我提示信息&lt;/a&gt; &lt;!-- 阻止事件冒泡（常用） --&gt; &lt;div class=\"demo1\" @click=\"showInfo\"&gt; &lt;button @click.stop=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;!-- 修饰符可以连续写 --&gt; &lt;!-- &lt;a href=\"https://www.serein.icu/\" @click.prevent.stop=\"showInfo\"&gt;点我提示信息&lt;/a&gt; --&gt; &lt;/div&gt; &lt;!-- 事件只触发一次（常用） --&gt; &lt;button @click.once=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;!-- 使用事件的捕获模式 --&gt; &lt;div class=\"box1\" @click.capture=\"showMsg(1)\"&gt; div1 &lt;div class=\"box2\" @click=\"showMsg(2)\"&gt; div2 &lt;/div&gt; &lt;/div&gt; &lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt; &lt;div class=\"demo1\" @click.self=\"showInfo\"&gt; &lt;button @click=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;/div&gt; &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt; //wheel(scroll) 滚动鼠标滚轮(滚动条)触发事件 &lt;ul @wheel.passive=\"demo\" class=\"list\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein' }, methods:{ showInfo(e){ alert('同学你好！') console.log(e.target) }, showMsg(msg){ console.log(msg) }, demo(){ for (let i = 0; i &lt; 100000; i++) { console.log('#') } console.log('累坏了') } } }) &lt;/script&gt; 3. 键盘事件1. Vue中常用的按键别名： 回车 =&gt; enter 删除 =&gt; delete (捕获“删除”和“退格”键) 退出 =&gt; esc 空格 =&gt; space 换行 =&gt; tab (特殊，必须配合keydown去使用) 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right 2. Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名） 3. 系统修饰键（用法特殊）：ctrl、alt、shift、meta 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。 配合keydown使用：正常触发事件。 4. 也可以使用keyCode去指定具体的按键（不推荐，Vue3已弃用） 5. Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名(Vue3已弃用) 计算属性computed 定义：要用的属性不存在，要通过已有属性计算得来。 原理：底层借助了Objcet.defineproperty方法提供的getter和setter。 get函数什么时候执行？ 初次读取时会执行一次。 当依赖的数据发生改变时会被再次调用。 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。 备注： 计算属性最终会出现在vm上，直接读取使用即可。 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。 &lt;div id=\"root\"&gt; 姓：&lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;br/&gt;&lt;br/&gt; 名：&lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;br/&gt;&lt;br/&gt; 全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br/&gt;&lt;br/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', }, computed:{ //完整写法 fullName:{ //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值 //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。 get(){ console.log('get被调用了') console.log(this) //此处的this是vm return this.firstName + '-' + this.lastName }, //set什么时候调用? 当fullName被修改时。 set(value){ console.log('set',value) const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] } } //简写 fullName(){ console.log('get被调用了') return this.firstName + '-' + this.lastName } } }) &lt;/script&gt; 监视属性watch 当被监视的属性变化时, 回调函数自动调用, 进行相关操作 监视的属性必须存在，才能进行监视！！ 监视的两种写法： new Vue时传入watch配置 通过vm.$watch监视 深度监视 Vue中的watch默认不监测对象内部值的改变（一层）。 配置deep:true可以监测对象内部值改变（多层）。 备注： Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！ 使用watch时根据数据的具体结构，决定是否采用深度监视。 &lt;div id=\"root\"&gt; &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt; &lt;button @click=\"changeWeather\"&gt;切换天气&lt;/button&gt; &lt;hr/&gt; &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt; &lt;button @click=\"numbers.a++\"&gt;点我让a+1&lt;/button&gt; &lt;h3&gt;b的值是:{{numbers.b}}&lt;/h3&gt; &lt;button @click=\"numbers.b++\"&gt;点我让b+1&lt;/button&gt; &lt;button @click=\"numbers = {a:666,b:888}\"&gt;彻底替换掉numbers&lt;/button&gt; {{numbers.c.d.e}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ isHot:true, numbers:{ a:1, b:1, c:{ d:{ e:100 } } } }, computed:{ info(){ return this.isHot ? '炎热' : '凉爽' } }, methods: { changeWeather(){ this.isHot = !this.isHot } }, watch:{ isHot:{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue) } }, // 简写 isHot(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue,this) } //监视多级结构中某个属性的变化 'numbers.a':{ handler(){ console.log('a被改变了') } } //监视多级结构中所有属性的变化 numbers:{ deep:true, handler(){ console.log('numbers改变了') } } } }) vm.$watch('isHot',{ immediate:true, handler(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue) } }) &lt;/script&gt; computed和watch之间的区别： computed能完成的功能，watch都可以完成。 watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则： 所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。 绑定样式 class样式 写法:class=”xxx” xxx可以是字符串、对象、数组。 字符串写法适用于：类名不确定，要动态获取。 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 style样式 :style=”{fontSize: xxx}”其中xxx是动态值。 :style=”[a,b]”其中a、b是样式对象。 &lt;style&gt; .basic{ width: 400px; height: 100px; border: 1px solid black; } .happy{ border: 4px solid red;; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg,yellow,pink,orange,yellow); } .sad{ border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal{ background-color: skyblue; } .style1{ background-color: yellowgreen; } .style2{ font-size: 30px; text-shadow:2px 2px 10px red; } .style3{ border-radius: 20px; } &lt;/style&gt; &lt;div id=\"root\"&gt; &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt; &lt;div class=\"basic\" :class=\"mood\" @click=\"changeMood\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt; &lt;div class=\"basic\" :class=\"classArr\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt; &lt;div class=\"basic\" :class=\"classObj\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--对象写法 --&gt; &lt;div class=\"basic\" :style=\"styleObj\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--数组写法 --&gt; &lt;div class=\"basic\" :style=\"styleArr\"&gt;{{name}}&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', mood:'normal', classArr:['style1','style2','style3'], classObj:{ style1:false, style2:false, }, styleObj:{ fontSize: '40px', color:'red', }, styleObj2:{ backgroundColor:'orange' }, styleArr:[ { fontSize: '40px', color:'blue', }, { backgroundColor:'gray' } ] }, methods: { changeMood(){ const arr = ['happy','sad','normal'] const index = Math.floor(Math.random()*3) this.mood = arr[index] } }, }) &lt;/script&gt; 条件渲染 v-if写法： v-if=”表达式” v-else-if=”表达式” v-else=”表达式” 适用于：切换频率较低的场景。特点：不展示的DOM元素直接被移除。注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。 v-show写法：v-show=”表达式”适用于：切换频率较高的场景。特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。 &lt;div id=\"root\"&gt; &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;!-- 使用v-show做条件渲染 --&gt; &lt;h2 v-show=\"false\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;h2 v-show=\"1 === 1\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;!-- 使用v-if做条件渲染 --&gt; &lt;h2 v-if=\"false\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;h2 v-if=\"1 === 1\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;!-- v-else和v-else-if --&gt; &lt;div v-if=\"n === 1\"&gt;Angular&lt;/div&gt; &lt;div v-else-if=\"n === 2\"&gt;React&lt;/div&gt; &lt;div v-else-if=\"n === 3\"&gt;Vue&lt;/div&gt; &lt;div v-else&gt;哈哈&lt;/div&gt; &lt;!-- v-if与template的配合使用 --&gt; &lt;template v-if=\"n === 1\"&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h2&gt;Serein&lt;/h2&gt; &lt;h2&gt;Sereinblog&lt;/h2&gt; &lt;/template&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', n:0 } }) &lt;/script&gt; 列表渲染1. 基本列表v-for指令: 1. 用于展示列表数据 2. 语法：v-for=”(item, index) in xxx” :key=”yyy” 3. 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 2. key的原理react、vue中的key有什么作用？（key的内部原理） 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下： 对比规则： 旧虚拟DOM中找到了与新虚拟DOM相同的key： 若虚拟DOM中内容没变, 直接使用之前的真实DOM！ 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。 旧虚拟DOM中未找到与新虚拟DOM相同的key： 创建新的真实DOM，随后渲染到到页面。 用index作为key可能会引发的问题： 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。 开发中如何选择key?: 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。 图解 3. 列表过滤&lt;div id=\"root\"&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\"&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) of filPerons\" :key=\"index\"&gt; {{p.name}}-{{p.age}}-{{p.sex}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:19,sex:'女'}, {id:'002',name:'周冬雨',age:20,sex:'女'}, {id:'003',name:'周杰伦',age:21,sex:'男'}, {id:'004',name:'温兆伦',age:22,sex:'男'} ] }, computed:{ filPerons(){ return this.persons.filter((p)=&gt;{ return p.name.indexOf(this.keyWord) !== -1 }) } } }) &lt;/script&gt; 4. 列表排序&lt;div id=\"root\"&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\"&gt; &lt;button @click=\"sortType = 2\"&gt;年龄升序&lt;/button&gt; &lt;button @click=\"sortType = 1\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"sortType = 0\"&gt;原顺序&lt;/button&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) of filPerons\" :key=\"p.id\"&gt; {{p.name}}-{{p.age}}-{{p.sex}} &lt;input type=\"text\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ keyWord:'', sortType:0, //0原顺序 1降序 2升序 persons:[ {id:'001',name:'马冬梅',age:30,sex:'女'}, {id:'002',name:'周冬雨',age:31,sex:'女'}, {id:'003',name:'周杰伦',age:18,sex:'男'}, {id:'004',name:'温兆伦',age:19,sex:'男'} ] }, computed:{ filPerons(){ const arr = this.persons.filter((p)=&gt;{ return p.name.indexOf(this.keyWord) !== -1 }) //判断一下是否需要排序 if(this.sortType){ arr.sort((p1,p2)=&gt;{ return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age }) } return arr } } }) &lt;/script&gt; 5. Vue的数据监测Vue监视数据的原理： vue会监视data中所有层次的数据。 如何监测对象中的数据？ 通过setter实现监视，且要在new Vue时就传入要监测的数据。 1. 对象中后追加的属性，Vue默认不做响应式处理 2. 如需给后添加的属性做响应式，请使用如下API： Vue.set(target，propertyName/index，value) 或 vm.$set(target，propertyName/index，value) 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事： 1. 调用原生对应的方法对数组进行更新。 2. 重新解析模板，进而更新页面。 在Vue修改数组中的某个元素一定要用如下方法： 使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse() Vue.set() 或 vm.$set() 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！ &lt;div id=\"root\"&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;button @click=\"student.age++\"&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addSex\"&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"student.sex = '未知' \"&gt;修改性别&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addFriend\"&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"updateFirstFriendName\"&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addHobby\"&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"updateHobby\"&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"removeSmoke\"&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt; &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt; &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt; &lt;h3 v-if=\"student.sex\"&gt;性别：{{student.sex}}&lt;/h3&gt; &lt;h3&gt;爱好：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(h,index) in student.hobby\" :key=\"index\"&gt; {{h}} &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;朋友们：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(h,index) in student.hobby\" :key=\"index\"&gt; {{h}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ student:{ name:'tom', age:18, hobby:['抽烟','喝酒','烫头'], friends:[ {name:'jerry',age:35}, {name:'tony',age:36} ] } }, methods: { addSex(){ // Vue.set(this.student,'sex','男') this.$set(this.student,'sex','男') }, addFriend(){ this.student.friends.unshift({name:'jack',age:70}) }, updateFirstFriendName(){ this.student.friends[0].name = '张三' }, addHobby(){ this.student.hobby.push('学习') }, updateHobby(){ // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby,0,'开车') }, removeSmoke(){ this.student.hobby = this.student.hobby.filter((h)=&gt;{ return h !== '抽烟' }) } } }) &lt;/script&gt; 搜集表单数据若：&lt;input type=\"text\"/&gt;，则v-model收集的是value值，用户输入的就是value值。 若：&lt;input type=\"radio\"/&gt;，则v-model收集的是value值，且要给标签配置value值。 若：&lt;input type=\"checkbox\"/&gt; 1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值） 2.配置input的value属性: (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） (2)v-model的初始值是数组，那么收集的的就是value组成的数组 备注：v-model的三个修饰符： lazy：失去焦点再收集数据 number：输入字符串转为有效的数字 trim：输入首尾空格过滤 &lt;div id=\"root\"&gt; &lt;form @submit.prevent=\"demo\"&gt; 账号：&lt;input type=\"text\" v-model.trim=\"userInfo.account\"&gt; &lt;br/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" v-model=\"userInfo.password\"&gt; &lt;br/&gt;&lt;br/&gt; 年龄：&lt;input type=\"number\" v-model.number=\"userInfo.age\"&gt; &lt;br/&gt;&lt;br/&gt; 性别： 男&lt;input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"male\"&gt; 女&lt;input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"female\"&gt; &lt;br/&gt;&lt;br/&gt; 爱好： 学习&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"study\"&gt; 打游戏&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"game\"&gt; 吃饭&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"eat\"&gt; &lt;br/&gt;&lt;br/&gt; 所属校区 &lt;select v-model=\"userInfo.city\"&gt; &lt;option value=\"\"&gt;请选择校区&lt;/option&gt; &lt;option value=\"beijing\"&gt;Sereinblog&lt;/option&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"shenzhen\"&gt;深圳&lt;/option&gt; &lt;option value=\"wuhan\"&gt;武汉&lt;/option&gt; &lt;/select&gt; &lt;br/&gt;&lt;br/&gt; 其他信息： &lt;textarea v-model.lazy=\"userInfo.other\"&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"userInfo.agree\"&gt;阅读并接受&lt;a href=\"http://www.blog.com\"&gt;《用户协议》&lt;/a&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ userInfo:{ account:'', password:'', age:18, sex:'female', hobby:[], city:'beijing', other:'', agree:'' } }, methods: { demo(){ console.log(JSON.stringify(this.userInfo)) } } }) &lt;/script&gt; 过滤器(Vue3已弃用)定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。语法： 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}} 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = “xxx | 过滤器名” 备注： 过滤器也可以接收额外参数、多个过滤器也可以串联 并没有改变原本的数据, 是产生新的对应的数据 &lt;script type=\"text/javascript\" src=\"../js/dayjs.min.js\"&gt;&lt;/script&gt; //第三方库：记录时间 &lt;div id=\"root\"&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：{{fmtTime}}&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：{{getFmtTime()}}&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}&lt;/h3&gt; &lt;h3 :x=\"msg | mySlice\"&gt;Serein&lt;/h3&gt; &lt;/div&gt; &lt;div id=\"root2\"&gt; &lt;h2&gt;{{msg | mySlice}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //全局过滤器 Vue.filter('mySlice',function(value){ return value.slice(0,4) }) new Vue({ el:'#root', data:{ time:1621561377603, //时间戳 msg:'你好，Serein' }, computed: { fmtTime(){ return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss') } }, methods: { getFmtTime(){ return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss') } }, //局部过滤器 filters:{ timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){ // console.log('@',value) return dayjs(value).format(str) } } }) new Vue({ el:'#root2', data:{ msg:'hello,blog!' } }) &lt;/script&gt; 内置指令1. v-text指令我们学过的指令： v-bind : 单向绑定解析表达式, 可简写为 :xxx v-model : 双向数据绑定 v-for : 遍历数组/对象/字符串 v-on : 绑定事件监听, 可简写为@ v-if : 条件渲染（动态控制节点是否存存在） v-else : 条件渲染（动态控制节点是否存存在） v-show : 条件渲染 (动态控制节点是否展示) v-text指令： 作用：向其所在的节点中渲染文本内容。 与插值语法的区别：v-text会替换掉节点中的内容，则不会。 &lt;div id=\"root\"&gt; &lt;div&gt;你好，{{name}}&lt;/div&gt; &lt;div v-text=\"name\"&gt;&lt;/div&gt; &lt;div v-text=\"str\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein', str:'&lt;h3&gt;你好啊！&lt;/h3&gt;' } }) &lt;/script&gt; 2. v-html指令v-html指令： 作用：向指定节点中渲染包含html结构的内容。 与插值语法的区别： v-html会替换掉节点中所有的内容，则不会。 v-html可以识别html结构。 严重注意：v-html有安全性问题！！！！ 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。 一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！ &lt;div id=\"root\"&gt; &lt;div&gt;你好，{{name}}&lt;/div&gt; &lt;div v-html=\"str\"&gt;&lt;/div&gt; &lt;div v-html=\"str2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein', str:'&lt;h3&gt;你好啊！&lt;/h3&gt;', str2:'&lt;a href=javascript:location.href=\"http://www.baidu.com?\"+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;', } }) &lt;/script&gt; 3. v-cloakv-cloak指令（没有值）： 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。 使用css配合v-cloak可以解决网速慢时页面展示出的问题。 &lt;style&gt; [v-cloak]{ display:none; } &lt;/style&gt; &lt;div id=\"root\"&gt; &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"http://localhost:8080/resource/5s/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; console.log(1) new Vue({ el:'#root', data:{ name:'Serein' } }) &lt;/script&gt; 4. v-once指令 v-once所在节点在初次动态渲染后，就视为静态内容了。 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。 &lt;div id=\"root\"&gt; &lt;h2 v-once&gt;初始化的n值是:{{n}}&lt;/h2&gt; &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ n:1 } }) &lt;/script&gt; 5. v-pre指令 跳过其所在节点的编译过程。 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。 &lt;div id=\"root\"&gt; &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt; &lt;h2 &gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ n:1 } }) &lt;/script&gt; 6. v-slotv-slot指令 作用：用于提供命名的插槽或需要接收prop的插槽 (具体使用请查看插槽知识点) 自定义指令自定义指令总结： 一、定义语法： 局部指令：new Vue({ directives:{指令名:配置对象} 或 }) new Vue({ directives{指令名:回调函数} }) 全局指令： Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数) 二、配置对象中常用的3个回调： bind：指令与元素成功绑定时调用。 inserted：指令所在元素被插入页面时调用。 update：指令所在模板结构被重新解析时调用。 三、备注： 指令定义时不加v-，但使用时要加v-； 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。 &lt;div id=\"root\"&gt; &lt;h2&gt;{{name}}&lt;/h2&gt; &lt;h2&gt;当前的n值是：&lt;span v-text=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; --&gt; &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;hr/&gt; &lt;input type=\"text\" v-fbind:value=\"n\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义全局指令 Vue.directive('fbind',{ //指令与元素成功绑定时（一上来） bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时 inserted(element,binding){ element.focus() }, //指令所在的模板被重新解析时 update(element,binding){ element.value = binding.value } }) new Vue({ el:'#root', data:{ name:'Serein', n:1 }, directives:{ //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。 //2.指令所在的模板被重新解析时。 'big-number'(element,binding){ // console.log('big') element.innerText = binding.value * 10 }, big(element,binding){ console.log('big',this) //注意此处的this是window // console.log('big') element.innerText = binding.value * 10 }, fbind:{ //指令与元素成功绑定时（一上来） bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时 inserted(element,binding){ element.focus() }, //指令所在的模板被重新解析时 update(element,binding){ element.value = binding.value } } } }) &lt;/script&gt; 生命周期1. 引出生命周期 又名：生命周期回调函数、生命周期函数、生命周期钩子。 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。 生命周期函数中的this指向是vm 或 组件实例对象。 &lt;div id=\"root\"&gt; &lt;h2 v-if=\"a\"&gt;你好啊&lt;/h2&gt; &lt;h2 :style=\"{opacity}\"&gt;欢迎学习Vue&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ a:false, opacity:1 }, methods: { }, //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted(){ console.log('mounted',this) setInterval(() =&gt; { this.opacity -= 0.01 if(this.opacity &lt;= 0) this.opacity = 1 },16) }, }) //通过外部的定时器实现（不推荐） setInterval(() =&gt; { vm.opacity -= 0.01 if(vm.opacity &lt;= 0) vm.opacity = 1 },16) &lt;/script&gt; 2. 分析生命周期 3. 总结生命周期常用的生命周期钩子： mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。 beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。 关于销毁Vue实例 销毁后借助Vue开发者工具看不到任何信息。 销毁后自定义事件会失效，但原生DOM事件依然有效。 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。 &lt;div id=\"root\"&gt; &lt;h2 :style=\"{opacity}\"&gt;欢迎学习Vue&lt;/h2&gt; &lt;button @click=\"opacity = 1\"&gt;透明度设置为1&lt;/button&gt; &lt;button @click=\"stop\"&gt;点我停止变换&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ opacity:1 }, methods: { stop(){ this.$destroy() } }, //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted(){ console.log('mounted',this) this.timer = setInterval(() =&gt; { console.log('setInterval') this.opacity -= 0.01 if(this.opacity &lt;= 0) this.opacity = 1 },16) }, beforeDestroy() { clearInterval(this.timer) console.log('vm即将驾鹤西游了') }, }) &lt;/script&gt; 非单文件组件1. 基本使用Vue中使用组件的三大步骤： 一、定义组件(创建组件)二、注册组件三、使用组件(写组件标签) 一、如何定义一个组件？使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；区别如下： el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。 data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。 备注：使用template可以配置组件结构。 二、如何注册组件？ 局部注册：靠new Vue的时候传入components选项 全局注册：靠Vue.component(‘组件名’,组件) 三、编写组件标签：&lt;school&gt;&lt;/school&gt; &lt;div id=\"root\"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hr&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;school&gt;&lt;/school&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; &lt;div id=\"root2\"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //第一步：创建school组件 const school = Vue.extend({ template:` &lt;div class=\"demo\"&gt; &lt;h2&gt;学校名称：{{schoolName}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, // el:'#root', //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。 data(){ return { schoolName:'Serein', address:'Sereinblog昌平' } }, methods: { showName(){ alert(this.schoolName) } }, }) //第一步：创建student组件 const student = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;学生姓名：{{studentName}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { studentName:'张三', age:18 } } }) //第一步：创建hello组件 const hello = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;你好啊！{{name}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { name:'Tom' } } }) //第二步：全局注册组件 Vue.component('hello',hello) //创建vm new Vue({ el:'#root', data:{ msg:'你好啊！' }, //第二步：注册组件（局部注册） components:{ school, student } }) new Vue({ el:'#root2', }) &lt;/script&gt; 2. 几个注意点 关于组件名: 一个单词组成： 第一种写法(首字母小写)：school 第二种写法(首字母大写)：School 多个单词组成： 第一种写法(kebab-case命名)：my-school 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持) 备注： 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。 可以使用name配置项指定组件在开发者工具中呈现的名字。 关于组件标签: 第一种写法：&lt;school&gt;&lt;/school&gt; 第二种写法：&lt;school/&gt; 备注：不用使用脚手架时，会导致后续组件不能渲染。 一个简写方式： const school = Vue.extend(options) 可简写为：const school = options 3. 组件的嵌套&lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义student组件 const student = Vue.extend({ name:'student', template:` &lt;div&gt; &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { name:'Serein', age:18 } } }) //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:'Sereinblog' } }, //注册组件（局部） components:{ student } }) //定义hello组件 const hello = Vue.extend({ template:`&lt;h1&gt;{{msg}}&lt;/h1&gt;`, data(){ return { msg:'欢迎来到Serein学习！' } } }) //定义app组件 const app = Vue.extend({ template:` &lt;div&gt; &lt;hello&gt;&lt;/hello&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; `, components:{ school, hello } }) //创建vm new Vue({ template:'&lt;app&gt;&lt;/app&gt;', el:'#root', //注册组件（局部） components:{app} }) &lt;/script&gt; 4. VueComponent关于VueComponent： school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。 我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象， 即Vue帮我们执行的：new VueComponent(options)。 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！ 关于this指向： 组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。 new Vue(options)配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。 VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。 Vue的实例对象，以后简称vm。 &lt;div id=\"root\"&gt; &lt;school&gt;&lt;/school&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:'Sereinblog' } }, methods: { showName(){ console.log('showName',this) } }, }) const test = Vue.extend({ template:`&lt;span&gt;blog&lt;/span&gt;` }) //定义hello组件 const hello = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;{{msg}}&lt;/h2&gt; &lt;test&gt;&lt;/test&gt; &lt;/div&gt; `, data(){ return { msg:'你好啊！' } }, components:{test} }) // console.log('@',school) // console.log('#',hello) //创建vm const vm = new Vue({ el:'#root', components:{school,hello} }) &lt;/script&gt; 5. 一个重要的内置关系VueComponent.prototype.proto === Vue.prototype 为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。 &lt;div id=\"root\"&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.prototype.x = 99 //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showX\"&gt;点我输出x&lt;/button&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:\"Sereinblog\" } }, methods: { showX(){ console.log(this.x) } }, }) //创建一个vm const vm = new Vue({ el:'#root', data:{ msg:'你好' }, components:{school} }) //定义一个构造函数 function Demo(){ this.a = 1 this.b = 2 } //创建一个Demo的实例对象 const d = new Demo() console.log(Demo.prototype) //显示原型属性 console.log(d.__proto__) //隐式原型属性 console.log(Demo.prototype === d.__proto__) //程序员通过显示原型属性操作原型对象，追加一个x属性，值为99 Demo.prototype.x = 99 console.log('@',d) &lt;/script&gt; 单文件组件&lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/body&gt; import App from './App.vue' new Vue({ el:'#root', template:`&lt;App&gt;&lt;/App&gt;`, components:{App}, }) &lt;template&gt; &lt;div&gt; &lt;School&gt;&lt;/School&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //引入组件 import School from './School.vue' import Student from './Student.vue' export default { name:'App', components:{ School, Student } } &lt;/script&gt; &lt;template&gt; &lt;div class=\"demo\"&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'School', data(){ return { name:'Serein', address:'Sereinblog' } }, methods: { showName(){ alert(this.name) } }, } &lt;/script&gt; &lt;style&gt; .demo{ background-color: orange; } &lt;/style&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Student', data(){ return { name:'张三', age:18 } } } &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://serein.icu/tags/Vue2/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-03-11T02:07:00.000Z","updated":"2022-03-12T05:01:24.126Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://serein.icu/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？纯属个人兴趣，拥有一个自己的博客，会有小许成就感吧，记录一些自己感兴趣的事或物。 展望博客我会整理一些个人所学的知识，以及在学习过程中遇到的一些难点和踩过的坑，或生活中有趣的事发到博客上与大家一同分享！ 关于博主热爱前端，不断前行 寄语： ​ Time waits for no one. ​ Treasure every moment you have. ​ 时间不等人，珍惜你所拥有的每分每秒吧！","categories":[{"name":"生活","slug":"生活","permalink":"https://serein.icu/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://serein.icu/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://serein.icu/categories/TypeScript/"},{"name":"Echarts","slug":"Echarts","permalink":"https://serein.icu/categories/Echarts/"},{"name":"Svg","slug":"Svg","permalink":"https://serein.icu/categories/Svg/"},{"name":"Canvas","slug":"Canvas","permalink":"https://serein.icu/categories/Canvas/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://serein.icu/categories/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"},{"name":"项目实战","slug":"项目实战","permalink":"https://serein.icu/categories/%E9%A1%B9%E7%9B%AE%E5%AE%9E%E6%88%98/"},{"name":"生活","slug":"生活","permalink":"https://serein.icu/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"TS","slug":"TS","permalink":"https://serein.icu/tags/TS/"},{"name":"Echarts","slug":"Echarts","permalink":"https://serein.icu/tags/Echarts/"},{"name":"Svg","slug":"Svg","permalink":"https://serein.icu/tags/Svg/"},{"name":"Canvas","slug":"Canvas","permalink":"https://serein.icu/tags/Canvas/"},{"name":"浅拷贝与深拷贝","slug":"浅拷贝与深拷贝","permalink":"https://serein.icu/tags/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"},{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"},{"name":"组件通信","slug":"组件通信","permalink":"https://serein.icu/tags/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/"},{"name":"Promise","slug":"Promise","permalink":"https://serein.icu/tags/Promise/"},{"name":"js","slug":"js","permalink":"https://serein.icu/tags/js/"},{"name":"ES6","slug":"ES6","permalink":"https://serein.icu/tags/ES6/"},{"name":"Vue2","slug":"Vue2","permalink":"https://serein.icu/tags/Vue2/"},{"name":"想法","slug":"想法","permalink":"https://serein.icu/tags/%E6%83%B3%E6%B3%95/"}]}