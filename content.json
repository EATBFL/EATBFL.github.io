{"meta":{"title":"Serein's blog","subtitle":"","description":"热爱大前端并怀揣着梦想","author":"Serein","url":"https://serein.icu","root":"/"},"pages":[{"title":"分类","date":"2020-11-24T07:12:19.000Z","updated":"2021-07-26T14:44:28.785Z","comments":false,"path":"categories/index.html","permalink":"https://serein.icu/categories/index.html","excerpt":"","text":""},{"title":"关于本站","date":"2022-03-10T15:19:56.000Z","updated":"2022-03-10T15:19:55.403Z","comments":false,"path":"about/index.html","permalink":"https://serein.icu/about/index.html","excerpt":"","text":"Serein“ 认识自我、超越自我 “ 那么你离成功就又进了一步！ 当你感觉所要学习的人和事越来越多时，说明你在 成长 。 当你感觉要责怪的人和事越来越少时，说明你在 成熟 。 当你在不断获得了友谊和朋友时，说明你将取得 成功 。 联系我B站：爆炸吧-现充（bilibili YYDS !） QQ：1297711534 (间接性失联) 座右铭：既然选择了远方 便只顾风雨兼程"},{"title":"archives","date":"2019-10-24T16:00:00.000Z","updated":"2022-03-13T03:14:57.264Z","comments":true,"path":"archives/index.html","permalink":"https://serein.icu/archives/index.html","excerpt":"","text":""},{"title":"我的歌单","date":"2019-05-17T08:14:00.000Z","updated":"2021-07-26T13:06:52.537Z","comments":true,"path":"music/index.html","permalink":"https://serein.icu/music/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2018-06-07T14:17:49.000Z","updated":"2021-07-27T07:31:10.990Z","comments":true,"path":"link/index.html","permalink":"https://serein.icu/link/index.html","excerpt":"","text":""},{"title":"留言板","date":"2020-10-31T02:11:28.000Z","updated":"2021-11-23T10:50:01.880Z","comments":false,"path":"comments/index.html","permalink":"https://serein.icu/comments/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-24T07:14:39.000Z","updated":"2021-07-26T14:44:42.337Z","comments":false,"path":"tags/index.html","permalink":"https://serein.icu/tags/index.html","excerpt":"","text":""},{"title":"","date":"2019-08-10T08:41:10.000Z","updated":"2022-03-11T06:56:26.059Z","comments":false,"path":"List/movies/index.html","permalink":"https://serein.icu/List/movies/index.html","excerpt":"","text":"奥斯卡最佳动画短片《鹬》（Piper）"},{"title":"","date":"2022-03-12T03:23:13.000Z","updated":"2022-03-13T03:23:35.157Z","comments":false,"path":"List/gallery/wallpaper/index.html","permalink":"https://serein.icu/List/gallery/wallpaper/index.html","excerpt":"","text":""},{"title":"Music-BOX","date":"2020-04-23T04:58:56.000Z","updated":"2022-03-11T06:18:21.494Z","comments":false,"path":"List/music/index.html","permalink":"https://serein.icu/List/music/index.html","excerpt":"","text":""},{"title":"相册","date":"2022-03-13T03:18:40.109Z","updated":"2022-03-13T03:18:40.109Z","comments":false,"path":"List/gallery/index.html","permalink":"https://serein.icu/List/gallery/index.html","excerpt":"","text":"壁紙 /List/gallery/wallpaper"}],"posts":[{"title":"Vue3快速上手","slug":"04-Vue3快速上手","date":"2022-03-14T06:00:00.000Z","updated":"2022-03-14T15:29:38.674Z","comments":true,"path":"posts/4.html","link":"","permalink":"https://serein.icu/posts/4.html","excerpt":"","text":"Vue3快速上手 1.Vue3简介 2020年9月18日，Vue.js发布3.0版本，代号：One Piece（海贼王） 耗时2年多、2600+次提交、30+个RFC、600+次PR、99位贡献者 github上的tags地址：https://github.com/vuejs/vue-next/releases/tag/v3.0.0 2.Vue3带来了什么1.性能的提升 打包大小减少41% 初次渲染快55%, 更新渲染快133% 内存减少54% …… 2.源码的升级 使用Proxy代替defineProperty实现响应式 重写虚拟DOM的实现和Tree-Shaking …… 3.拥抱TypeScript Vue3可以更好的支持TypeScript 4.新的特性 Composition API（组合API） setup配置 ref与reactive watch与watchEffect provide与inject …… 新的内置组件 Fragment Teleport Suspense 其他改变 新的生命周期钩子 data 选项应始终被声明为一个函数 移除keyCode支持作为 v-on 的修饰符 …… 一、创建Vue3.0工程1.使用 vue-cli 创建官方文档：https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create ## 查看@vue/cli版本，确保@vue/cli版本在4.5.0以上 vue --version ## 安装或者升级你的@vue/cli npm install -g @vue/cli ## 创建 vue create vue_test ## 启动 cd vue_test npm run serve 2.使用 vite 创建官方文档：https://v3.cn.vuejs.org/guide/installation.html#vite vite官网：https://vitejs.cn 什么是vite？—— 新一代前端构建工具。 优势如下： 开发环境中，无需打包操作，可快速的冷启动。 轻量快速的热重载（HMR）。 真正的按需编译，不再等待整个应用编译完成。 传统构建 与 vite构建对比图 ## 创建工程 npm init vite-app &lt;project-name&gt; ## 进入工程目录 cd &lt;project-name&gt; ## 安装依赖 npm install ## 运行 npm run dev 二、常用 Composition API官方文档: https://v3.cn.vuejs.org/guide/composition-api-introduction.html 1.拉开序幕的setup 理解：Vue3.0中一个新的配置项，值为一个函数。 setup是所有Composition API（组合API）“ 表演的舞台 ”。 组件中所用到的：数据、方法等等，均要配置在setup中。 setup函数的两种返回值： 若返回一个对象，则对象中的属性、方法, 在模板中均可以直接使用。（重点关注！） 若返回一个渲染函数：则可以自定义渲染内容。（了解） 注意点： 尽量不要与Vue2.x配置混用 Vue2.x配置（data、methos、computed…）中可以访问到setup中的属性、方法。 但在setup中不能访问到Vue2.x配置（data、methos、computed…）。 如果有重名, setup优先。 setup不能是一个async函数，因为返回值不再是return的对象, 而是promise, 模板看不到return对象中的属性。（后期也可以返回一个Promise实例，但需要Suspense和异步组件的配合） 2.ref函数 作用: 定义一个响应式的数据 语法: const xxx = ref(initValue) 创建一个包含响应式数据的引用对象（reference对象，简称ref对象）。 JS中操作数据： xxx.value 模板中读取数据: 不需要.value，直接：&lt;div&gt;{{xxx}}&lt;/div&gt; 备注： 接收的数据可以是：基本类型、也可以是对象类型。 基本类型的数据：响应式依然是靠Object.defineProperty()的get与set完成的。 对象类型的数据：内部 “ 求助 ” 了Vue3.0中的一个新函数—— reactive函数。 3.reactive函数 作用: 定义一个对象类型的响应式数据（基本类型不要用它，要用ref函数） 语法：const 代理对象= reactive(源对象)接收一个对象（或数组），返回一个代理对象（Proxy的实例对象，简称proxy对象） reactive定义的响应式数据是“深层次的”。 内部基于 ES6 的 Proxy 实现，通过代理对象操作源对象内部数据进行操作。 4.Vue3.0中的响应式原理vue2.x的响应式 实现原理： 对象类型：通过Object.defineProperty()对属性的读取、修改进行拦截（数据劫持）。 数组类型：通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。 Object.defineProperty(data, 'count', { get () {}, set () {} }) 存在问题： 新增属性、删除属性, 界面不会更新。 直接通过下标修改数组, 界面不会自动更新。 Vue3.0的响应式 实现原理: 通过Proxy（代理）: 拦截对象中任意属性的变化, 包括：属性值的读写、属性的添加、属性的删除等。 通过Reflect（反射）: 对源对象的属性进行操作。 MDN文档中描述的Proxy与Reflect： Proxy：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy Reflect：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect new Proxy(data, { // 拦截读取属性值 get (target, prop) { return Reflect.get(target, prop) }, // 拦截设置属性值或添加新属性 set (target, prop, value) { return Reflect.set(target, prop, value) }, // 拦截删除属性 deleteProperty (target, prop) { return Reflect.deleteProperty(target, prop) } }) proxy.name = 'tom' 5.reactive对比ref 从定义数据角度对比： ref用来定义：基本类型数据。 reactive用来定义：对象（或数组）类型数据。 备注：ref也可以用来定义对象（或数组）类型数据, 它内部会自动通过reactive转为代理对象。 从原理角度对比： ref通过Object.defineProperty()的get与set来实现响应式（数据劫持）。 reactive通过使用Proxy来实现响应式（数据劫持）, 并通过Reflect操作源对象内部的数据。 从使用角度对比： ref定义的数据：操作数据需要.value，读取数据时模板中直接读取不需要.value。 reactive定义的数据：操作数据与读取数据：均不需要.value。 6.setup的两个注意点 setup执行的时机 在beforeCreate之前执行一次，this是undefined。 setup的参数 props：值为对象，包含：组件外部传递过来，且组件内部声明接收了的属性。 context：上下文对象 attrs: 值为对象，包含：组件外部传递过来，但没有在props配置中声明的属性, 相当于 this.$attrs。 slots: 收到的插槽内容, 相当于 this.$slots。 emit: 分发自定义事件的函数, 相当于 this.$emit。 7.计算属性与监视1.computed函数 与Vue2.x中computed配置功能一致 写法 import {computed} from 'vue' setup(){ ... //计算属性——简写 let fullName = computed(()=&gt;{ return person.firstName + '-' + person.lastName }) //计算属性——完整 let fullName = computed({ get(){ return person.firstName + '-' + person.lastName }, set(value){ const nameArr = value.split('-') person.firstName = nameArr[0] person.lastName = nameArr[1] } }) } 2.watch函数 与Vue2.x中watch配置功能一致 两个小“坑”： 监视reactive定义的响应式数据时：oldValue无法正确获取、强制开启了深度监视（deep配置失效）。 监视reactive定义的响应式数据中某个属性时：deep配置有效。 //情况一：监视ref定义的响应式数据 watch(sum,(newValue,oldValue)=&gt;{ console.log('sum变化了',newValue,oldValue) },{immediate:true}) //情况二：监视多个ref定义的响应式数据 watch([sum,msg],(newValue,oldValue)=&gt;{ console.log('sum或msg变化了',newValue,oldValue) }) /* 情况三：监视reactive定义的响应式数据 若watch监视的是reactive定义的响应式数据，则无法正确获得oldValue！！ 若watch监视的是reactive定义的响应式数据，则强制开启了深度监视 */ watch(person,(newValue,oldValue)=&gt;{ console.log('person变化了',newValue,oldValue) },{immediate:true,deep:false}) //此处的deep配置不再奏效 //情况四：监视reactive定义的响应式数据中的某个属性 watch(()=&gt;person.job,(newValue,oldValue)=&gt;{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //情况五：监视reactive定义的响应式数据中的某些属性 watch([()=&gt;person.job,()=&gt;person.name],(newValue,oldValue)=&gt;{ console.log('person的job变化了',newValue,oldValue) },{immediate:true,deep:true}) //特殊情况 watch(()=&gt;person.job,(newValue,oldValue)=&gt;{ console.log('person的job变化了',newValue,oldValue) },{deep:true}) //此处由于监视的是reactive素定义的对象中的某个属性，所以deep配置有效 3.watchEffect函数 watch的套路是：既要指明监视的属性，也要指明监视的回调。 watchEffect的套路是：不用指明监视哪个属性，监视的回调中用到哪个属性，那就监视哪个属性。 watchEffect有点像computed： 但computed注重的计算出来的值（回调函数的返回值），所以必须要写返回值。 而watchEffect更注重的是过程（回调函数的函数体），所以不用写返回值。 //watchEffect所指定的回调中用到的数据只要发生变化，则直接重新执行回调。 watchEffect(()=&gt;{ const x1 = sum.value const x2 = person.age console.log('watchEffect配置的回调执行了') }) 8.生命周期 Vue3.0中可以继续使用Vue2.x中的生命周期钩子，但有有两个被更名： beforeDestroy改名为 beforeUnmount destroyed改名为 unmounted Vue3.0也提供了 Composition API 形式的生命周期钩子，与Vue2.x中钩子对应关系如下： beforeCreate===&gt;setup() created=======&gt;setup() beforeMount ===&gt;onBeforeMount mounted=======&gt;onMounted beforeUpdate===&gt;onBeforeUpdate updated =======&gt;onUpdated beforeUnmount&nbsp;==&gt;onBeforeUnmount unmounted =====&gt;onUnmounted 9.自定义hook函数 什么是hook？—— 本质是一个函数，把setup函数中使用的Composition API进行了封装。 类似于vue2.x中的mixin。 自定义hook的优势: 复用代码, 让setup中的逻辑更清楚易懂。 10.toRef 作用：创建一个 ref 对象，其value值指向另一个对象中的某个属性。 语法：const name = toRef(person,'name') 应用: 要将响应式对象中的某个属性单独提供给外部使用时。 扩展：toRefs 与toRef功能一致，但可以批量创建多个 ref 对象，语法：toRefs(person) 三、其它 Composition API1.shallowReactive 与 shallowRef shallowReactive：只处理对象最外层属性的响应式（浅响应式）。 shallowRef：只处理基本数据类型的响应式, 不进行对象的响应式处理。 什么时候使用? 如果有一个对象数据，结构比较深, 但变化时只是外层属性变化 ===&gt; shallowReactive。 如果有一个对象数据，后续功能不会修改该对象中的属性，而是生新的对象来替换 ===&gt; shallowRef。 2.readonly 与 shallowReadonly readonly: 让一个响应式数据变为只读的（深只读）。 shallowReadonly：让一个响应式数据变为只读的（浅只读）。 应用场景: 不希望数据被修改时。 3.toRaw 与 markRaw toRaw： 作用：将一个由reactive生成的响应式对象转为普通对象。 使用场景：用于读取响应式对象对应的普通对象，对这个普通对象的所有操作，不会引起页面更新。 markRaw： 作用：标记一个对象，使其永远不会再成为响应式对象。 应用场景: 有些值不应被设置为响应式的，例如复杂的第三方类库等。 当渲染具有不可变数据源的大列表时，跳过响应式转换可以提高性能。 4.customRef 作用：创建一个自定义的 ref，并对其依赖项跟踪和更新触发进行显式控制。 实现防抖效果： &lt;template&gt; &lt;input type=\"text\" v-model=\"keyword\"&gt; &lt;h3&gt;{{keyword}}&lt;/h3&gt; &lt;/template&gt; &lt;script&gt; import {ref,customRef} from 'vue' export default { name:'Demo', setup(){ // let keyword = ref('hello') //使用Vue准备好的内置ref //自定义一个myRef function myRef(value,delay){ let timer //通过customRef去实现自定义 return customRef((track,trigger)=&gt;{ return{ get(){ track() //告诉Vue这个value值是需要被“追踪”的 return value }, set(newValue){ clearTimeout(timer) timer = setTimeout(()=&gt;{ value = newValue trigger() //告诉Vue去更新界面 },delay) } } }) } let keyword = myRef('hello',500) //使用程序员自定义的ref return { keyword } } } &lt;/script&gt; 5.provide 与 inject 作用：实现祖与后代组件间通信 套路：父组件有一个 provide 选项来提供数据，后代组件有一个 inject 选项来开始使用这些数据 具体写法： 祖组件中： setup(){ ...... let car = reactive({name:'奔驰',price:'40万'}) provide('car',car) ...... } 后代组件中： setup(props,context){ ...... const car = inject('car') return {car} ...... } 6.响应式数据的判断 isRef: 检查一个值是否为一个 ref 对象 isReactive: 检查一个对象是否是由 reactive 创建的响应式代理 isReadonly: 检查一个对象是否是由 readonly 创建的只读代理 isProxy: 检查一个对象是否是由 reactive 或者 readonly 方法创建的代理 四、Composition API 的优势1.Options API 存在的问题使用传统OptionsAPI中，新增或者修改一个需求，就需要分别在data，methods，computed里修改 。 2.Composition API 的优势我们可以更加优雅的组织我们的代码，函数。让相关功能的代码更加有序的组织在一起。 五、新的组件1.Fragment 在Vue2中: 组件必须有一个根标签 在Vue3中: 组件可以没有根标签, 内部会将多个标签包含在一个Fragment虚拟元素中 好处: 减少标签层级, 减小内存占用 2.Teleport 什么是Teleport？—— Teleport 是一种能够将我们的组件html结构移动到指定位置的技术。 &lt;teleport to=\"移动位置\"&gt; &lt;div v-if=\"isShow\" class=\"mask\"&gt; &lt;div class=\"dialog\"&gt; &lt;h3&gt;我是一个弹窗&lt;/h3&gt; &lt;button @click=\"isShow = false\"&gt;关闭弹窗&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/teleport&gt; 3.Suspense 等待异步组件时渲染一些额外内容，让应用有更好的用户体验 使用步骤： 异步引入组件 import {defineAsyncComponent} from 'vue' const Child = defineAsyncComponent(()=&gt;import('./components/Child.vue')) 使用Suspense包裹组件，并配置好default 与 fallback &lt;template&gt; &lt;div class=\"app\"&gt; &lt;h3&gt;我是App组件&lt;/h3&gt; &lt;Suspense&gt; &lt;template v-slot:default&gt; &lt;Child/&gt; &lt;/template&gt; &lt;template v-slot:fallback&gt; &lt;h3&gt;加载中.....&lt;/h3&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;/template&gt; 六、其他1.全局API的转移 Vue 2.x 有许多全局 API 和配置。 例如：注册全局组件、注册全局指令等。 //注册全局组件 Vue.component('MyButton', { data: () =&gt; ({ count: 0 }), template: '&lt;button @click=\"count++\"&gt;Clicked {{ count }} times.&lt;/button&gt;' }) //注册全局指令 Vue.directive('focus', { inserted: el =&gt; el.focus() } Vue3.0中对这些API做出了调整： 将全局的API，即：Vue.xxx调整到应用实例（app）上 2.x 全局 API（Vue） 3.x 实例 API (app) Vue.config.xxxx app.config.xxxx Vue.config.productionTip 移除 Vue.component app.component Vue.directive app.directive Vue.mixin app.mixin Vue.use app.use Vue.prototype app.config.globalProperties 2.其他改变 data选项应始终被声明为一个函数。 过度类名的更改： Vue2.x写法 .v-enter, .v-leave-to { opacity: 0; } .v-leave, .v-enter-to { opacity: 1; } Vue3.x写法 .v-enter-from, .v-leave-to { opacity: 0; } .v-leave-from, .v-enter-to { opacity: 1; } 移除keyCode作为 v-on 的修饰符，同时也不再支持config.keyCodes 移除v-on.native修饰符 父组件中绑定事件 &lt;my-component v-on:close=\"handleComponentEvent\" v-on:click=\"handleNativeClickEvent\" /&gt; 子组件中声明自定义事件 &lt;script&gt; export default { emits: ['close'] } &lt;/script&gt; 移除过滤器（filter） 过滤器虽然这看起来很方便，但它需要一个自定义语法，打破大括号内表达式是 “只是 JavaScript” 的假设，这不仅有学习成本，而且有实现成本！建议用方法调用或计算属性去替换过滤器。 ……","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"}]},{"title":"Vue2进阶知识","slug":"03-Vue2进阶知识","date":"2022-03-14T04:00:00.000Z","updated":"2022-03-14T03:08:36.973Z","comments":true,"path":"posts/3.html","link":"","permalink":"https://serein.icu/posts/3.html","excerpt":"","text":"进阶知识篇","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"}]},{"title":"Vue2基础知识","slug":"02-Vue2基础知识","date":"2022-03-14T01:00:00.000Z","updated":"2022-03-14T02:38:12.449Z","comments":true,"path":"posts/2.html","link":"","permalink":"https://serein.icu/posts/2.html","excerpt":"","text":"基础知识篇初识Vue 想让Vue工作，就必须创建一个Vue实例，且要传入一个配置对象； root容器里的代码依然符合html规范，只不过混入了一些特殊的Vue语法； root容器里的代码被称为【Vue模板】； Vue实例和容器是一一对应的； 真实开发中只有一个Vue实例，并且会配合着组件一起使用； 中的xxx要写js表达式，且xxx可以自动读取到data中的所有属性； 一旦data中的数据发生改变，那么页面中用到该数据的地方也会自动更新； 注意区分：js表达式 和 js代码(语句) 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方： a a+b demo(1) x === y ? 'a' : 'b' js代码(语句) if(){} for(){} Vue模板语法Vue模板语法有两大类： 插值语法： 功能：用于解析标签体内容。 写法：，xxx是js表达式，且可以直接读取到data中的所有属性。 指令语法： 功能：用于解析标签（包括：标签属性、标签体内容、绑定事件…..）。 举例：v-bind:href=”xxx” 或 简写为 :href=”xxx”，xxx同样要写js表达式，且可以直接读取到data中的所有属性。 备注：Vue中有很多的指令，且形式都是：v-????，此处我们只是拿v-bind举个例子。 &lt;!-- 准备好一个容器--&gt; &lt;div id=\"root\"&gt; &lt;h1&gt;插值语法&lt;/h1&gt; &lt;h3&gt;你好，{{name}}&lt;/h3&gt; &lt;hr/&gt; &lt;h1&gt;指令语法&lt;/h1&gt; &lt;a v-bind:href=\"school.url.toUpperCase()\" x=\"hello\"&gt;点我去{{school.name}}学习1&lt;/a&gt; &lt;a :href=\"school.url\" x=\"hello\"&gt;点我去{{school.name}}学习2&lt;/a&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'Serein', school:{ name:\"Serein'blog\", url:'https://www.serein.icu', } } }) &lt;/script&gt; 数据绑定Vue中有2种数据绑定的方式： 单向绑定(v-bind)：数据只能从data流向页面。 双向绑定(v-model)：数据不仅能从data流向页面，还可以从页面流向data。 备注：1. 双向绑定一般都应用在表单类元素上（如：input、select等）2. v-model:value 可以简写为 v-model，因为v-model默认收集的就是value值。 &lt;div id=\"root\"&gt; &lt;!-- 普通写法 --&gt; &lt;!-- 单向数据绑定：&lt;input type=\"text\" v-bind:value=\"name\"&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=\"text\" v-model:value=\"name\"&gt;&lt;br/&gt; --&gt; &lt;!-- 简写 --&gt; 单向数据绑定：&lt;input type=\"text\" :value=\"name\"&gt;&lt;br/&gt; 双向数据绑定：&lt;input type=\"text\" v-model=\"name\"&gt;&lt;br/&gt; &lt;!-- 如下代码是错误的，因为v-model只能应用在表单类元素（输入类元素）上 --&gt; &lt;!-- &lt;h2 v-model:x=\"name\"&gt;你好啊&lt;/h2&gt; --&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 new Vue({ el:'#root', data:{ name:'Serein' } }) &lt;/script&gt; el与data的两种写法1. el有2种写法： new Vue时候配置el属性。 先创建Vue实例，随后再通过vm.$mount(‘#root’)指定el的值。 2. data有2种写法： 对象式 函数式 如何选择：目前哪种写法都可以，以后学习到组件时，data必须使用函数式，否则会报错。 3. 一个重要的原则： 由Vue管理的函数，一定不要写箭头函数，一旦写了箭头函数，this就不再是Vue实例了。 &lt;div id=\"root\"&gt; &lt;h1&gt;你好，{{name}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 //el的两种写法 const v = new Vue({ //el:'#root', //第一种写法 data:{ name:'Serein' } }) console.log(v) v.$mount('#root') //第二种写法 //data的两种写法 new Vue({ el:'#root', //data的第一种写法：对象式 data:{ name:'Serein' } //data的第二种写法：函数式 data(){ console.log('@@@',this) //此处的this是Vue实例对象 return{ name:'Serein' } } }) &lt;/script&gt; MVVM模型1. M：模型(Model) ：data中的数据 2. V：视图(View) ：模板代码 3. VM：视图模型(ViewModel)：Vue实例 观察发现： - data中所有的属性，最后都出现在了vm身上。 - vm身上所有的属性 及 Vue原型上所有属性，在Vue模板中都可以直接使用。 &lt;div id=\"root\"&gt; &lt;h1&gt;学校名称：{{name}}&lt;/h1&gt; &lt;h1&gt;学校地址：{{address}}&lt;/h1&gt; &lt;h1&gt;测试一下1：{{1+1}}&lt;/h1&gt; &lt;h1&gt;测试一下2：{{$options}}&lt;/h1&gt; &lt;h1&gt;测试一下3：{{$emit}}&lt;/h1&gt; &lt;h1&gt;测试一下4：{{_c}}&lt;/h1&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。 const vm = new Vue({ el:'#root', data:{ name:'Serein', address:\"Serein's blog\", } }) console.log(vm) &lt;/script&gt; 数据代理1. 回顾Object.defineProperty&lt;script type=\"text/javascript\" &gt; let number = 18 let person = { name:'张三', sex:'男', } Object.defineProperty(person,'age',{ // value:18, enumerable:true, //控制属性是否可以枚举，默认值是false writable:true, //控制属性是否可以被修改，默认值是false configurable:true //控制属性是否可以被删除，默认值是false //当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值 get(){ console.log('有人读取age属性了') return number }, //当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值 set(value){ console.log('有人修改了age属性，且值是',value) number = value } }) console.log(Object.keys(person)) //枚举person对象属性 console.log(person) &lt;/script&gt; 2. 何为数据代理&lt;!-- 数据代理：通过一个对象代理对另一个对象中属性的操作（读/写）--&gt; &lt;script type=\"text/javascript\" &gt; let obj = {x:100} let obj2 = {y:200} Object.defineProperty(obj2,'x',{ get(){ return obj.x }, set(value){ obj.x = value } }) &lt;/script&gt; 3.Vue中的数据代理1. Vue中的数据代理：通过vm对象来代理data对象中属性的操作（读/写） 2. Vue中数据代理的好处：更加方便的操作data中的数据 3. 基本原理：通过Object.defineProperty()把data对象中所有属性添加到vm上。为每一个添加到vm上的属性，都指定一个getter/setter。在getter/setter内部去操作（读/写）data中对应的属性。 &lt;div id=\"root\"&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', address:\"Serein's blog\" } }) &lt;/script&gt; 事件处理1. 事件的基本使用 使用v-on:xxx 或 @xxx 绑定事件，其中xxx是事件名； 事件的回调需要配置在methods对象中，最终会在vm上； methods中配置的函数，不要用箭头函数！否则this就不是vm了； methods中配置的函数，都是被Vue所管理的函数，this的指向是vm 或 组件实例对象； @click=”demo” 和 @click=”demo($event)” 效果一致，但后者可以传参； &lt;div id=\"root\"&gt; &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt; &lt;!-- &lt;button v-on:click=\"showInfo\"&gt;点我提示信息&lt;/button&gt; --&gt; &lt;button @click=\"showInfo1\"&gt;点我提示信息1（不传参）&lt;/button&gt; &lt;button @click=\"showInfo2($event,66)\"&gt;点我提示信息2（传参）&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', }, methods:{ showInfo1(event){ console.log(event.target.innerText) //获取按钮的文字数据 console.log(this) //此处的this是vm alert('同学你好！') }, showInfo2(event,number){ console.log(event,number) console.log(event.target.innerText) console.log(this) //此处的this是vm alert('同学你好！！') } } }) &lt;/script&gt; 2. 事件修饰符 prevent：阻止默认事件（常用）； stop：阻止事件冒泡（常用）； once：事件只触发一次（常用）； capture：使用事件的捕获模式； self：只有event.target是当前操作的元素时才触发事件； passive：事件的默认行为立即执行，无需等待事件回调执行完毕；（一般移动端使用它） 注意：passive和prevent冲突，不能同时绑定在一个监听器上。 事件冒泡： 即事件开始时由最具体的元素接收，然后逐级向上传播到较为不具体的节点 理解：想象气泡从水底开始往上升，由深到浅，升到最上面。在上升的过程中，气泡会经过不同深度层次的水。 相对应地：这个气泡就相当于我们这里的事件，而水则相当于我们的整个dom树；事件从dom 树的底层 层层往上传递，直至传递到dom的根节点。 事件捕获： 与事件冒泡完全相反 网景公司提出的事件流叫事件捕获流 事件捕获流的思想是不太具体的DOM节点应该更早接收到事件，而最具体的节点应该最后接收到事件 懵懵懂懂的小伙伴，请看图解: &lt;div id=\"root\"&gt; &lt;h2&gt;欢迎来到{{name}}学习&lt;/h2&gt; &lt;!-- 阻止默认事件（常用） --&gt; &lt;a href=\"https://www.serein.icu/\" @click.prevent=\"showInfo\"&gt;点我提示信息&lt;/a&gt; &lt;!-- 阻止事件冒泡（常用） --&gt; &lt;div class=\"demo1\" @click=\"showInfo\"&gt; &lt;button @click.stop=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;!-- 修饰符可以连续写 --&gt; &lt;!-- &lt;a href=\"https://www.serein.icu/\" @click.prevent.stop=\"showInfo\"&gt;点我提示信息&lt;/a&gt; --&gt; &lt;/div&gt; &lt;!-- 事件只触发一次（常用） --&gt; &lt;button @click.once=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;!-- 使用事件的捕获模式 --&gt; &lt;div class=\"box1\" @click.capture=\"showMsg(1)\"&gt; div1 &lt;div class=\"box2\" @click=\"showMsg(2)\"&gt; div2 &lt;/div&gt; &lt;/div&gt; &lt;!-- 只有event.target是当前操作的元素时才触发事件； --&gt; &lt;div class=\"demo1\" @click.self=\"showInfo\"&gt; &lt;button @click=\"showInfo\"&gt;点我提示信息&lt;/button&gt; &lt;/div&gt; &lt;!-- 事件的默认行为立即执行，无需等待事件回调执行完毕； --&gt; //wheel(scroll) 滚动鼠标滚轮(滚动条)触发事件 &lt;ul @wheel.passive=\"demo\" class=\"list\"&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein' }, methods:{ showInfo(e){ alert('同学你好！') console.log(e.target) }, showMsg(msg){ console.log(msg) }, demo(){ for (let i = 0; i &lt; 100000; i++) { console.log('#') } console.log('累坏了') } } }) &lt;/script&gt; 3. 键盘事件1. Vue中常用的按键别名： 回车 =&gt; enter 删除 =&gt; delete (捕获“删除”和“退格”键) 退出 =&gt; esc 空格 =&gt; space 换行 =&gt; tab (特殊，必须配合keydown去使用) 上 =&gt; up 下 =&gt; down 左 =&gt; left 右 =&gt; right 2. Vue未提供别名的按键，可以使用按键原始的key值去绑定，但注意要转为kebab-case（短横线命名） 3. 系统修饰键（用法特殊）：ctrl、alt、shift、meta 配合keyup使用：按下修饰键的同时，再按下其他键，随后释放其他键，事件才被触发。 配合keydown使用：正常触发事件。 4. 也可以使用keyCode去指定具体的按键（不推荐，Vue3已弃用） 5. Vue.config.keyCodes.自定义键名 = 键码，可以去定制按键别名(Vue3已弃用) 计算属性computed 定义：要用的属性不存在，要通过已有属性计算得来。 原理：底层借助了Objcet.defineproperty方法提供的getter和setter。 get函数什么时候执行？ 初次读取时会执行一次。 当依赖的数据发生改变时会被再次调用。 优势：与methods实现相比，内部有缓存机制（复用），效率更高，调试方便。 备注： 计算属性最终会出现在vm上，直接读取使用即可。 如果计算属性要被修改，那必须写set函数去响应修改，且set中要引起计算时依赖的数据发生改变。 &lt;div id=\"root\"&gt; 姓：&lt;input type=\"text\" v-model=\"firstName\"&gt; &lt;br/&gt;&lt;br/&gt; 名：&lt;input type=\"text\" v-model=\"lastName\"&gt; &lt;br/&gt;&lt;br/&gt; 全名：&lt;span&gt;{{fullName}}&lt;/span&gt; &lt;br/&gt;&lt;br/&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ firstName:'张', lastName:'三', }, computed:{ //完整写法 fullName:{ //get有什么作用？当有人读取fullName时，get就会被调用，且返回值就作为fullName的值 //get什么时候调用？1.初次读取fullName时。2.所依赖的数据发生变化时。 get(){ console.log('get被调用了') console.log(this) //此处的this是vm return this.firstName + '-' + this.lastName }, //set什么时候调用? 当fullName被修改时。 set(value){ console.log('set',value) const arr = value.split('-') this.firstName = arr[0] this.lastName = arr[1] } } //简写 fullName(){ console.log('get被调用了') return this.firstName + '-' + this.lastName } } }) &lt;/script&gt; 监视属性watch 当被监视的属性变化时, 回调函数自动调用, 进行相关操作 监视的属性必须存在，才能进行监视！！ 监视的两种写法： new Vue时传入watch配置 通过vm.$watch监视 深度监视 Vue中的watch默认不监测对象内部值的改变（一层）。 配置deep:true可以监测对象内部值改变（多层）。 备注： Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以！ 使用watch时根据数据的具体结构，决定是否采用深度监视。 &lt;div id=\"root\"&gt; &lt;h2&gt;今天天气很{{info}}&lt;/h2&gt; &lt;button @click=\"changeWeather\"&gt;切换天气&lt;/button&gt; &lt;hr/&gt; &lt;h3&gt;a的值是:{{numbers.a}}&lt;/h3&gt; &lt;button @click=\"numbers.a++\"&gt;点我让a+1&lt;/button&gt; &lt;h3&gt;b的值是:{{numbers.b}}&lt;/h3&gt; &lt;button @click=\"numbers.b++\"&gt;点我让b+1&lt;/button&gt; &lt;button @click=\"numbers = {a:666,b:888}\"&gt;彻底替换掉numbers&lt;/button&gt; {{numbers.c.d.e}} &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ isHot:true, numbers:{ a:1, b:1, c:{ d:{ e:100 } } } }, computed:{ info(){ return this.isHot ? '炎热' : '凉爽' } }, methods: { changeWeather(){ this.isHot = !this.isHot } }, watch:{ isHot:{ immediate:true, //初始化时让handler调用一下 //handler什么时候调用？当isHot发生改变时。 handler(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue) } }, // 简写 isHot(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue,this) } //监视多级结构中某个属性的变化 'numbers.a':{ handler(){ console.log('a被改变了') } } //监视多级结构中所有属性的变化 numbers:{ deep:true, handler(){ console.log('numbers改变了') } } } }) vm.$watch('isHot',{ immediate:true, handler(newValue,oldValue){ console.log('isHot被修改了',newValue,oldValue) } }) &lt;/script&gt; computed和watch之间的区别： computed能完成的功能，watch都可以完成。 watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作。 两个重要的小原则： 所被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象。 所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数等、Promise的回调函数），最好写成箭头函数，这样this的指向才是vm 或 组件实例对象。 绑定样式 class样式 写法:class=”xxx” xxx可以是字符串、对象、数组。 字符串写法适用于：类名不确定，要动态获取。 数组写法适用于：要绑定多个样式，个数不确定，名字也不确定。 对象写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。 style样式 :style=”{fontSize: xxx}”其中xxx是动态值。 :style=”[a,b]”其中a、b是样式对象。 &lt;style&gt; .basic{ width: 400px; height: 100px; border: 1px solid black; } .happy{ border: 4px solid red;; background-color: rgba(255, 255, 0, 0.644); background: linear-gradient(30deg,yellow,pink,orange,yellow); } .sad{ border: 4px dashed rgb(2, 197, 2); background-color: gray; } .normal{ background-color: skyblue; } .style1{ background-color: yellowgreen; } .style2{ font-size: 30px; text-shadow:2px 2px 10px red; } .style3{ border-radius: 20px; } &lt;/style&gt; &lt;div id=\"root\"&gt; &lt;!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 --&gt; &lt;div class=\"basic\" :class=\"mood\" @click=\"changeMood\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 --&gt; &lt;div class=\"basic\" :class=\"classArr\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定、名字也确定，但要动态决定用不用 --&gt; &lt;div class=\"basic\" :class=\"classObj\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--对象写法 --&gt; &lt;div class=\"basic\" :style=\"styleObj\"&gt;{{name}}&lt;/div&gt; &lt;br/&gt;&lt;br/&gt; &lt;!-- 绑定style样式--数组写法 --&gt; &lt;div class=\"basic\" :style=\"styleArr\"&gt;{{name}}&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', mood:'normal', classArr:['style1','style2','style3'], classObj:{ style1:false, style2:false, }, styleObj:{ fontSize: '40px', color:'red', }, styleObj2:{ backgroundColor:'orange' }, styleArr:[ { fontSize: '40px', color:'blue', }, { backgroundColor:'gray' } ] }, methods: { changeMood(){ const arr = ['happy','sad','normal'] const index = Math.floor(Math.random()*3) this.mood = arr[index] } }, }) &lt;/script&gt; 条件渲染 v-if写法： v-if=”表达式” v-else-if=”表达式” v-else=”表达式” 适用于：切换频率较低的场景。特点：不展示的DOM元素直接被移除。注意：v-if可以和:v-else-if、v-else一起使用，但要求结构不能被“打断”。 v-show写法：v-show=”表达式”适用于：切换频率较高的场景。特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉 备注：使用v-if的时，元素可能无法获取到，而使用v-show一定可以获取到。 &lt;div id=\"root\"&gt; &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;!-- 使用v-show做条件渲染 --&gt; &lt;h2 v-show=\"false\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;h2 v-show=\"1 === 1\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;!-- 使用v-if做条件渲染 --&gt; &lt;h2 v-if=\"false\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;h2 v-if=\"1 === 1\"&gt;欢迎来到{{name}}&lt;/h2&gt; &lt;!-- v-else和v-else-if --&gt; &lt;div v-if=\"n === 1\"&gt;Angular&lt;/div&gt; &lt;div v-else-if=\"n === 2\"&gt;React&lt;/div&gt; &lt;div v-else-if=\"n === 3\"&gt;Vue&lt;/div&gt; &lt;div v-else&gt;哈哈&lt;/div&gt; &lt;!-- v-if与template的配合使用 --&gt; &lt;template v-if=\"n === 1\"&gt; &lt;h2&gt;你好&lt;/h2&gt; &lt;h2&gt;Serein&lt;/h2&gt; &lt;h2&gt;Sereinblog&lt;/h2&gt; &lt;/template&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ name:'Serein', n:0 } }) &lt;/script&gt; 列表渲染1. 基本列表v-for指令: 1. 用于展示列表数据 2. 语法：v-for=”(item, index) in xxx” :key=”yyy” 3. 可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少） 2. key的原理react、vue中的key有什么作用？（key的内部原理） 虚拟DOM中key的作用： key是虚拟DOM对象的标识，当数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】, 随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下： 对比规则： 旧虚拟DOM中找到了与新虚拟DOM相同的key： 若虚拟DOM中内容没变, 直接使用之前的真实DOM！ 若虚拟DOM中内容变了, 则生成新的真实DOM，随后替换掉页面中之前的真实DOM。 旧虚拟DOM中未找到与新虚拟DOM相同的key： 创建新的真实DOM，随后渲染到到页面。 用index作为key可能会引发的问题： 若对数据进行：逆序添加、逆序删除等破坏顺序操作:会产生没有必要的真实DOM更新 ==&gt; 界面效果没问题, 但效率低。 如果结构中还包含输入类的DOM：会产生错误DOM更新 ==&gt; 界面有问题。 开发中如何选择key?: 最好使用每条数据的唯一标识作为key, 比如id、手机号、身份证号、学号等唯一值。 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，使用index作为key是没有问题的。 图解 3. 列表过滤&lt;div id=\"root\"&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\"&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) of filPerons\" :key=\"index\"&gt; {{p.name}}-{{p.age}}-{{p.sex}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ keyWord:'', persons:[ {id:'001',name:'马冬梅',age:19,sex:'女'}, {id:'002',name:'周冬雨',age:20,sex:'女'}, {id:'003',name:'周杰伦',age:21,sex:'男'}, {id:'004',name:'温兆伦',age:22,sex:'男'} ] }, computed:{ filPerons(){ return this.persons.filter((p)=&gt;{ return p.name.indexOf(this.keyWord) !== -1 }) } } }) &lt;/script&gt; 4. 列表排序&lt;div id=\"root\"&gt; &lt;h2&gt;人员列表&lt;/h2&gt; &lt;input type=\"text\" placeholder=\"请输入名字\" v-model=\"keyWord\"&gt; &lt;button @click=\"sortType = 2\"&gt;年龄升序&lt;/button&gt; &lt;button @click=\"sortType = 1\"&gt;年龄降序&lt;/button&gt; &lt;button @click=\"sortType = 0\"&gt;原顺序&lt;/button&gt; &lt;ul&gt; &lt;li v-for=\"(p,index) of filPerons\" :key=\"p.id\"&gt; {{p.name}}-{{p.age}}-{{p.sex}} &lt;input type=\"text\"&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ keyWord:'', sortType:0, //0原顺序 1降序 2升序 persons:[ {id:'001',name:'马冬梅',age:30,sex:'女'}, {id:'002',name:'周冬雨',age:31,sex:'女'}, {id:'003',name:'周杰伦',age:18,sex:'男'}, {id:'004',name:'温兆伦',age:19,sex:'男'} ] }, computed:{ filPerons(){ const arr = this.persons.filter((p)=&gt;{ return p.name.indexOf(this.keyWord) !== -1 }) //判断一下是否需要排序 if(this.sortType){ arr.sort((p1,p2)=&gt;{ return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age }) } return arr } } }) &lt;/script&gt; 5. Vue的数据监测Vue监视数据的原理： vue会监视data中所有层次的数据。 如何监测对象中的数据？ 通过setter实现监视，且要在new Vue时就传入要监测的数据。 1. 对象中后追加的属性，Vue默认不做响应式处理 2. 如需给后添加的属性做响应式，请使用如下API： Vue.set(target，propertyName/index，value) 或 vm.$set(target，propertyName/index，value) 如何监测数组中的数据？ 通过包裹数组更新元素的方法实现，本质就是做了两件事： 1. 调用原生对应的方法对数组进行更新。 2. 重新解析模板，进而更新页面。 在Vue修改数组中的某个元素一定要用如下方法： 使用这些API:push()、pop()、shift()、unshift()、splice()、sort()、reverse() Vue.set() 或 vm.$set() 特别注意：Vue.set() 和 vm.$set() 不能给vm 或 vm的根数据对象 添加属性！！！ &lt;div id=\"root\"&gt; &lt;h1&gt;学生信息&lt;/h1&gt; &lt;button @click=\"student.age++\"&gt;年龄+1岁&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addSex\"&gt;添加性别属性，默认值：男&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"student.sex = '未知' \"&gt;修改性别&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addFriend\"&gt;在列表首位添加一个朋友&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"updateFirstFriendName\"&gt;修改第一个朋友的名字为：张三&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"addHobby\"&gt;添加一个爱好&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"updateHobby\"&gt;修改第一个爱好为：开车&lt;/button&gt; &lt;br/&gt; &lt;button @click=\"removeSmoke\"&gt;过滤掉爱好中的抽烟&lt;/button&gt; &lt;br/&gt; &lt;h3&gt;姓名：{{student.name}}&lt;/h3&gt; &lt;h3&gt;年龄：{{student.age}}&lt;/h3&gt; &lt;h3 v-if=\"student.sex\"&gt;性别：{{student.sex}}&lt;/h3&gt; &lt;h3&gt;爱好：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(h,index) in student.hobby\" :key=\"index\"&gt; {{h}} &lt;/li&gt; &lt;/ul&gt; &lt;h3&gt;朋友们：&lt;/h3&gt; &lt;ul&gt; &lt;li v-for=\"(h,index) in student.hobby\" :key=\"index\"&gt; {{h}} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; const vm = new Vue({ el:'#root', data:{ student:{ name:'tom', age:18, hobby:['抽烟','喝酒','烫头'], friends:[ {name:'jerry',age:35}, {name:'tony',age:36} ] } }, methods: { addSex(){ // Vue.set(this.student,'sex','男') this.$set(this.student,'sex','男') }, addFriend(){ this.student.friends.unshift({name:'jack',age:70}) }, updateFirstFriendName(){ this.student.friends[0].name = '张三' }, addHobby(){ this.student.hobby.push('学习') }, updateHobby(){ // this.student.hobby.splice(0,1,'开车') // Vue.set(this.student.hobby,0,'开车') this.$set(this.student.hobby,0,'开车') }, removeSmoke(){ this.student.hobby = this.student.hobby.filter((h)=&gt;{ return h !== '抽烟' }) } } }) &lt;/script&gt; 搜集表单数据若：&lt;input type=\"text\"/&gt;，则v-model收集的是value值，用户输入的就是value值。 若：&lt;input type=\"radio\"/&gt;，则v-model收集的是value值，且要给标签配置value值。 若：&lt;input type=\"checkbox\"/&gt; 1.没有配置input的value属性，那么收集的就是checked（勾选 or 未勾选，是布尔值） 2.配置input的value属性: (1)v-model的初始值是非数组，那么收集的就是checked（勾选 or 未勾选，是布尔值） (2)v-model的初始值是数组，那么收集的的就是value组成的数组 备注：v-model的三个修饰符： lazy：失去焦点再收集数据 number：输入字符串转为有效的数字 trim：输入首尾空格过滤 &lt;div id=\"root\"&gt; &lt;form @submit.prevent=\"demo\"&gt; 账号：&lt;input type=\"text\" v-model.trim=\"userInfo.account\"&gt; &lt;br/&gt;&lt;br/&gt; 密码：&lt;input type=\"password\" v-model=\"userInfo.password\"&gt; &lt;br/&gt;&lt;br/&gt; 年龄：&lt;input type=\"number\" v-model.number=\"userInfo.age\"&gt; &lt;br/&gt;&lt;br/&gt; 性别： 男&lt;input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"male\"&gt; 女&lt;input type=\"radio\" name=\"sex\" v-model=\"userInfo.sex\" value=\"female\"&gt; &lt;br/&gt;&lt;br/&gt; 爱好： 学习&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"study\"&gt; 打游戏&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"game\"&gt; 吃饭&lt;input type=\"checkbox\" v-model=\"userInfo.hobby\" value=\"eat\"&gt; &lt;br/&gt;&lt;br/&gt; 所属校区 &lt;select v-model=\"userInfo.city\"&gt; &lt;option value=\"\"&gt;请选择校区&lt;/option&gt; &lt;option value=\"beijing\"&gt;Sereinblog&lt;/option&gt; &lt;option value=\"shanghai\"&gt;上海&lt;/option&gt; &lt;option value=\"shenzhen\"&gt;深圳&lt;/option&gt; &lt;option value=\"wuhan\"&gt;武汉&lt;/option&gt; &lt;/select&gt; &lt;br/&gt;&lt;br/&gt; 其他信息： &lt;textarea v-model.lazy=\"userInfo.other\"&gt;&lt;/textarea&gt; &lt;br/&gt;&lt;br/&gt; &lt;input type=\"checkbox\" v-model=\"userInfo.agree\"&gt;阅读并接受&lt;a href=\"http://www.blog.com\"&gt;《用户协议》&lt;/a&gt; &lt;button&gt;提交&lt;/button&gt; &lt;/form&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ userInfo:{ account:'', password:'', age:18, sex:'female', hobby:[], city:'beijing', other:'', agree:'' } }, methods: { demo(){ console.log(JSON.stringify(this.userInfo)) } } }) &lt;/script&gt; 过滤器(Vue3已弃用)定义：对要显示的数据进行特定格式化后再显示（适用于一些简单逻辑的处理）。语法： 注册过滤器：Vue.filter(name,callback) 或 new Vue{filters:{}} 使用过滤器：{{ xxx | 过滤器名}} 或 v-bind:属性 = “xxx | 过滤器名” 备注： 过滤器也可以接收额外参数、多个过滤器也可以串联 并没有改变原本的数据, 是产生新的对应的数据 &lt;script type=\"text/javascript\" src=\"../js/dayjs.min.js\"&gt;&lt;/script&gt; //第三方库：记录时间 &lt;div id=\"root\"&gt; &lt;h2&gt;显示格式化后的时间&lt;/h2&gt; &lt;!-- 计算属性实现 --&gt; &lt;h3&gt;现在是：{{fmtTime}}&lt;/h3&gt; &lt;!-- methods实现 --&gt; &lt;h3&gt;现在是：{{getFmtTime()}}&lt;/h3&gt; &lt;!-- 过滤器实现 --&gt; &lt;h3&gt;现在是：{{time | timeFormater}}&lt;/h3&gt; &lt;!-- 过滤器实现（传参） --&gt; &lt;h3&gt;现在是：{{time | timeFormater('YYYY_MM_DD') | mySlice}}&lt;/h3&gt; &lt;h3 :x=\"msg | mySlice\"&gt;Serein&lt;/h3&gt; &lt;/div&gt; &lt;div id=\"root2\"&gt; &lt;h2&gt;{{msg | mySlice}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //全局过滤器 Vue.filter('mySlice',function(value){ return value.slice(0,4) }) new Vue({ el:'#root', data:{ time:1621561377603, //时间戳 msg:'你好，Serein' }, computed: { fmtTime(){ return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss') } }, methods: { getFmtTime(){ return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss') } }, //局部过滤器 filters:{ timeFormater(value,str='YYYY年MM月DD日 HH:mm:ss'){ // console.log('@',value) return dayjs(value).format(str) } } }) new Vue({ el:'#root2', data:{ msg:'hello,blog!' } }) &lt;/script&gt; 内置指令1. v-text指令我们学过的指令： v-bind : 单向绑定解析表达式, 可简写为 :xxx v-model : 双向数据绑定 v-for : 遍历数组/对象/字符串 v-on : 绑定事件监听, 可简写为@ v-if : 条件渲染（动态控制节点是否存存在） v-else : 条件渲染（动态控制节点是否存存在） v-show : 条件渲染 (动态控制节点是否展示) v-text指令： 作用：向其所在的节点中渲染文本内容。 与插值语法的区别：v-text会替换掉节点中的内容，则不会。 &lt;div id=\"root\"&gt; &lt;div&gt;你好，{{name}}&lt;/div&gt; &lt;div v-text=\"name\"&gt;&lt;/div&gt; &lt;div v-text=\"str\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein', str:'&lt;h3&gt;你好啊！&lt;/h3&gt;' } }) &lt;/script&gt; 2. v-html指令v-html指令： 作用：向指定节点中渲染包含html结构的内容。 与插值语法的区别： v-html会替换掉节点中所有的内容，则不会。 v-html可以识别html结构。 严重注意：v-html有安全性问题！！！！ 在网站上动态渲染任意HTML是非常危险的，容易导致XSS攻击。 一定要在可信的内容上使用v-html，永不要用在用户提交的内容上！ &lt;div id=\"root\"&gt; &lt;div&gt;你好，{{name}}&lt;/div&gt; &lt;div v-html=\"str\"&gt;&lt;/div&gt; &lt;div v-html=\"str2\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ name:'Serein', str:'&lt;h3&gt;你好啊！&lt;/h3&gt;', str2:'&lt;a href=javascript:location.href=\"http://www.baidu.com?\"+document.cookie&gt;兄弟我找到你想要的资源了，快来！&lt;/a&gt;', } }) &lt;/script&gt; 3. v-cloakv-cloak指令（没有值）： 本质是一个特殊属性，Vue实例创建完毕并接管容器后，会删掉v-cloak属性。 使用css配合v-cloak可以解决网速慢时页面展示出的问题。 &lt;style&gt; [v-cloak]{ display:none; } &lt;/style&gt; &lt;div id=\"root\"&gt; &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\" src=\"http://localhost:8080/resource/5s/vue.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; console.log(1) new Vue({ el:'#root', data:{ name:'Serein' } }) &lt;/script&gt; 4. v-once指令 v-once所在节点在初次动态渲染后，就视为静态内容了。 以后数据的改变不会引起v-once所在结构的更新，可以用于优化性能。 &lt;div id=\"root\"&gt; &lt;h2 v-once&gt;初始化的n值是:{{n}}&lt;/h2&gt; &lt;h2&gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ n:1 } }) &lt;/script&gt; 5. v-pre指令 跳过其所在节点的编译过程。 可利用它跳过：没有使用指令语法、没有使用插值语法的节点，会加快编译。 &lt;div id=\"root\"&gt; &lt;h2 v-pre&gt;Vue其实很简单&lt;/h2&gt; &lt;h2 &gt;当前的n值是:{{n}}&lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ n:1 } }) &lt;/script&gt; 6. v-slotv-slot指令 作用：用于提供命名的插槽或需要接收prop的插槽 (具体使用请查看插槽知识点) 自定义指令自定义指令总结： 一、定义语法： 局部指令：new Vue({ directives:{指令名:配置对象} 或 }) new Vue({ directives{指令名:回调函数} }) 全局指令： Vue.directive(指令名,配置对象) 或 Vue.directive(指令名,回调函数) 二、配置对象中常用的3个回调： bind：指令与元素成功绑定时调用。 inserted：指令所在元素被插入页面时调用。 update：指令所在模板结构被重新解析时调用。 三、备注： 指令定义时不加v-，但使用时要加v-； 指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。 &lt;div id=\"root\"&gt; &lt;h2&gt;{{name}}&lt;/h2&gt; &lt;h2&gt;当前的n值是：&lt;span v-text=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;!-- &lt;h2&gt;放大10倍后的n值是：&lt;span v-big-number=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; --&gt; &lt;h2&gt;放大10倍后的n值是：&lt;span v-big=\"n\"&gt;&lt;/span&gt; &lt;/h2&gt; &lt;button @click=\"n++\"&gt;点我n+1&lt;/button&gt; &lt;hr/&gt; &lt;input type=\"text\" v-fbind:value=\"n\"&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义全局指令 Vue.directive('fbind',{ //指令与元素成功绑定时（一上来） bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时 inserted(element,binding){ element.focus() }, //指令所在的模板被重新解析时 update(element,binding){ element.value = binding.value } }) new Vue({ el:'#root', data:{ name:'Serein', n:1 }, directives:{ //big函数何时会被调用？1.指令与元素成功绑定时（一上来）。 //2.指令所在的模板被重新解析时。 'big-number'(element,binding){ // console.log('big') element.innerText = binding.value * 10 }, big(element,binding){ console.log('big',this) //注意此处的this是window // console.log('big') element.innerText = binding.value * 10 }, fbind:{ //指令与元素成功绑定时（一上来） bind(element,binding){ element.value = binding.value }, //指令所在元素被插入页面时 inserted(element,binding){ element.focus() }, //指令所在的模板被重新解析时 update(element,binding){ element.value = binding.value } } } }) &lt;/script&gt; 生命周期1. 引出生命周期 又名：生命周期回调函数、生命周期函数、生命周期钩子。 是什么：Vue在关键时刻帮我们调用的一些特殊名称的函数。 生命周期函数的名字不可更改，但函数的具体内容是程序员根据需求编写的。 生命周期函数中的this指向是vm 或 组件实例对象。 &lt;div id=\"root\"&gt; &lt;h2 v-if=\"a\"&gt;你好啊&lt;/h2&gt; &lt;h2 :style=\"{opacity}\"&gt;欢迎学习Vue&lt;/h2&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ a:false, opacity:1 }, methods: { }, //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted(){ console.log('mounted',this) setInterval(() =&gt; { this.opacity -= 0.01 if(this.opacity &lt;= 0) this.opacity = 1 },16) }, }) //通过外部的定时器实现（不推荐） setInterval(() =&gt; { vm.opacity -= 0.01 if(vm.opacity &lt;= 0) vm.opacity = 1 },16) &lt;/script&gt; 2. 分析生命周期 3. 总结生命周期常用的生命周期钩子： mounted: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【初始化操作】。 beforeDestroy: 清除定时器、解绑自定义事件、取消订阅消息等【收尾工作】。 关于销毁Vue实例 销毁后借助Vue开发者工具看不到任何信息。 销毁后自定义事件会失效，但原生DOM事件依然有效。 一般不会在beforeDestroy操作数据，因为即便操作数据，也不会再触发更新流程了。 &lt;div id=\"root\"&gt; &lt;h2 :style=\"{opacity}\"&gt;欢迎学习Vue&lt;/h2&gt; &lt;button @click=\"opacity = 1\"&gt;透明度设置为1&lt;/button&gt; &lt;button @click=\"stop\"&gt;点我停止变换&lt;/button&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; new Vue({ el:'#root', data:{ opacity:1 }, methods: { stop(){ this.$destroy() } }, //Vue完成模板的解析并把初始的真实DOM元素放入页面后（挂载完毕）调用mounted mounted(){ console.log('mounted',this) this.timer = setInterval(() =&gt; { console.log('setInterval') this.opacity -= 0.01 if(this.opacity &lt;= 0) this.opacity = 1 },16) }, beforeDestroy() { clearInterval(this.timer) console.log('vm即将驾鹤西游了') }, }) &lt;/script&gt; 非单文件组件1. 基本使用Vue中使用组件的三大步骤： 一、定义组件(创建组件)二、注册组件三、使用组件(写组件标签) 一、如何定义一个组件？使用Vue.extend(options)创建，其中options和new Vue(options)时传入的那个options几乎一样，但也有点区别；区别如下： el不要写，为什么？ ——— 最终所有的组件都要经过一个vm的管理，由vm中的el决定服务哪个容器。 data必须写成函数，为什么？ ———— 避免组件被复用时，数据存在引用关系。 备注：使用template可以配置组件结构。 二、如何注册组件？ 局部注册：靠new Vue的时候传入components选项 全局注册：靠Vue.component(‘组件名’,组件) 三、编写组件标签：&lt;school&gt;&lt;/school&gt; &lt;div id=\"root\"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;hr&gt; &lt;h1&gt;{{msg}}&lt;/h1&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;school&gt;&lt;/school&gt; &lt;hr&gt; &lt;!-- 第三步：编写组件标签 --&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; &lt;div id=\"root2\"&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //第一步：创建school组件 const school = Vue.extend({ template:` &lt;div class=\"demo\"&gt; &lt;h2&gt;学校名称：{{schoolName}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, // el:'#root', //组件定义时，一定不要写el配置项，因为最终所有的组件都要被一个vm管理，由vm决定服务于哪个容器。 data(){ return { schoolName:'Serein', address:'Sereinblog昌平' } }, methods: { showName(){ alert(this.schoolName) } }, }) //第一步：创建student组件 const student = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;学生姓名：{{studentName}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { studentName:'张三', age:18 } } }) //第一步：创建hello组件 const hello = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;你好啊！{{name}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { name:'Tom' } } }) //第二步：全局注册组件 Vue.component('hello',hello) //创建vm new Vue({ el:'#root', data:{ msg:'你好啊！' }, //第二步：注册组件（局部注册） components:{ school, student } }) new Vue({ el:'#root2', }) &lt;/script&gt; 2. 几个注意点 关于组件名: 一个单词组成： 第一种写法(首字母小写)：school 第二种写法(首字母大写)：School 多个单词组成： 第一种写法(kebab-case命名)：my-school 第二种写法(CamelCase命名)：MySchool (需要Vue脚手架支持) 备注： 组件名尽可能回避HTML中已有的元素名称，例如：h2、H2都不行。 可以使用name配置项指定组件在开发者工具中呈现的名字。 关于组件标签: 第一种写法：&lt;school&gt;&lt;/school&gt; 第二种写法：&lt;school/&gt; 备注：不用使用脚手架时，会导致后续组件不能渲染。 一个简写方式： const school = Vue.extend(options) 可简写为：const school = options 3. 组件的嵌套&lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义student组件 const student = Vue.extend({ name:'student', template:` &lt;div&gt; &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; `, data(){ return { name:'Serein', age:18 } } }) //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;student&gt;&lt;/student&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:'Sereinblog' } }, //注册组件（局部） components:{ student } }) //定义hello组件 const hello = Vue.extend({ template:`&lt;h1&gt;{{msg}}&lt;/h1&gt;`, data(){ return { msg:'欢迎来到Serein学习！' } } }) //定义app组件 const app = Vue.extend({ template:` &lt;div&gt; &lt;hello&gt;&lt;/hello&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; `, components:{ school, hello } }) //创建vm new Vue({ template:'&lt;app&gt;&lt;/app&gt;', el:'#root', //注册组件（局部） components:{app} }) &lt;/script&gt; 4. VueComponent关于VueComponent： school组件本质是一个名为VueComponent的构造函数，且不是程序员定义的，是Vue.extend生成的。 我们只需要写&lt;school/&gt;或&lt;school&gt;&lt;/school&gt;，Vue解析时会帮我们创建school组件的实例对象， 即Vue帮我们执行的：new VueComponent(options)。 特别注意：每次调用Vue.extend，返回的都是一个全新的VueComponent！！！！ 关于this指向： 组件配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【VueComponent实例对象】。 new Vue(options)配置中： data函数、methods中的函数、watch中的函数、computed中的函数 它们的this均是【Vue实例对象】。 VueComponent的实例对象，以后简称vc（也可称之为：组件实例对象）。 Vue的实例对象，以后简称vm。 &lt;div id=\"root\"&gt; &lt;school&gt;&lt;/school&gt; &lt;hello&gt;&lt;/hello&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:'Sereinblog' } }, methods: { showName(){ console.log('showName',this) } }, }) const test = Vue.extend({ template:`&lt;span&gt;blog&lt;/span&gt;` }) //定义hello组件 const hello = Vue.extend({ template:` &lt;div&gt; &lt;h2&gt;{{msg}}&lt;/h2&gt; &lt;test&gt;&lt;/test&gt; &lt;/div&gt; `, data(){ return { msg:'你好啊！' } }, components:{test} }) // console.log('@',school) // console.log('#',hello) //创建vm const vm = new Vue({ el:'#root', components:{school,hello} }) &lt;/script&gt; 5. 一个重要的内置关系VueComponent.prototype.proto === Vue.prototype 为什么要有这个关系：让组件实例对象（vc）可以访问到 Vue原型上的属性、方法。 &lt;div id=\"root\"&gt; &lt;school&gt;&lt;/school&gt; &lt;/div&gt; &lt;script type=\"text/javascript\"&gt; Vue.prototype.x = 99 //定义school组件 const school = Vue.extend({ name:'school', template:` &lt;div&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showX\"&gt;点我输出x&lt;/button&gt; &lt;/div&gt; `, data(){ return { name:'Serein', address:\"Sereinblog\" } }, methods: { showX(){ console.log(this.x) } }, }) //创建一个vm const vm = new Vue({ el:'#root', data:{ msg:'你好' }, components:{school} }) //定义一个构造函数 function Demo(){ this.a = 1 this.b = 2 } //创建一个Demo的实例对象 const d = new Demo() console.log(Demo.prototype) //显示原型属性 console.log(d.__proto__) //隐式原型属性 console.log(Demo.prototype === d.__proto__) //程序员通过显示原型属性操作原型对象，追加一个x属性，值为99 Demo.prototype.x = 99 console.log('@',d) &lt;/script&gt; 单文件组件&lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=\"root\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\" src=\"../js/vue.js\"&gt;&lt;/script&gt; &lt;/body&gt; import App from './App.vue' new Vue({ el:'#root', template:`&lt;App&gt;&lt;/App&gt;`, components:{App}, }) &lt;template&gt; &lt;div&gt; &lt;School&gt;&lt;/School&gt; &lt;Student&gt;&lt;/Student&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; //引入组件 import School from './School.vue' import Student from './Student.vue' export default { name:'App', components:{ School, Student } } &lt;/script&gt; &lt;template&gt; &lt;div class=\"demo\"&gt; &lt;h2&gt;学校名称：{{name}}&lt;/h2&gt; &lt;h2&gt;学校地址：{{address}}&lt;/h2&gt; &lt;button @click=\"showName\"&gt;点我提示学校名&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'School', data(){ return { name:'Serein', address:'Sereinblog' } }, methods: { showName(){ alert(this.name) } }, } &lt;/script&gt; &lt;style&gt; .demo{ background-color: orange; } &lt;/style&gt; &lt;template&gt; &lt;div&gt; &lt;h2&gt;学生姓名：{{name}}&lt;/h2&gt; &lt;h2&gt;学生年龄：{{age}}&lt;/h2&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name:'Student', data(){ return { name:'张三', age:18 } } } &lt;/script&gt;","categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://serein.icu/tags/Vue2/"}]},{"title":"博客与博主","slug":"01-博客诞生","date":"2022-03-11T02:07:00.000Z","updated":"2022-03-12T05:01:24.126Z","comments":true,"path":"posts/1.html","link":"","permalink":"https://serein.icu/posts/1.html","excerpt":"","text":"相遇皆是缘分 为什么建博客？纯属个人兴趣，拥有一个自己的博客，会有小许成就感吧，记录一些自己感兴趣的事或物。 展望博客我会整理一些个人所学的知识，以及在学习过程中遇到的一些难点和踩过的坑，或生活中有趣的事发到博客上与大家一同分享！ 关于博主热爱前端，不断前行 寄语： ​ Time waits for no one. ​ Treasure every moment you have. ​ 时间不等人，珍惜你所拥有的每分每秒吧！","categories":[{"name":"生活","slug":"生活","permalink":"https://serein.icu/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"想法","slug":"想法","permalink":"https://serein.icu/tags/%E6%83%B3%E6%B3%95/"}]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/categories/Vue/"},{"name":"生活","slug":"生活","permalink":"https://serein.icu/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://serein.icu/tags/Vue/"},{"name":"Vue2","slug":"Vue2","permalink":"https://serein.icu/tags/Vue2/"},{"name":"想法","slug":"想法","permalink":"https://serein.icu/tags/%E6%83%B3%E6%B3%95/"}]}